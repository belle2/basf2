// Class: ReadBDTG
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTG
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/18       [336402]
Creator        : zupanc
Date           : Thu Jun 12 15:44:07 2014
Host           : Linux can62.cc.kek.jp 2.6.18-308.1.1.el5 #1 SMP Thu Mar 8 09:54:23 EST 2012 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /gpfs/home/belle/zupanc/belle2/maketag/MC3.5/neutrals/pi0/TMVATraining
Training events: 859232
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
nCuts: "200" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
UseBaggedGrad: "True" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "ignorenegweightsintraining" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 8
p_CMS                         p_CMS                         p_CMS                         p_CMS                                                           'F'    [0.000638258643448,30.4221420288]
cosTheta                      cosTheta                      cosTheta                      cosTheta                                                        'F'    [-0.999998927116,0.99999576807]
ErrM                          ErrM                          ErrM                          ErrM                                                            'F'    [0.00470399530604,159.342559814]
decayAngle                    decayAngle                    decayAngle                    decayAngle                                                      'F'    [-0.999971807003,0.999974906445]
daughter0E                    daughter0E                    daughter0E                    daughter0E                                                      'F'    [0.0600000396371,36.7101020813]
daughter1E                    daughter1E                    daughter1E                    daughter1E                                                      'F'    [0.0600000396371,36.7101020813]
daughter0clusterE9E25         daughter0clusterE9E25         daughter0clusterE9E25         daughter0clusterE9E25                                           'F'    [0.0241658650339,1]
daughter1clusterE9E25         daughter1clusterE9E25         daughter1clusterE9E25         daughter1clusterE9E25                                           'F'    [0.0191722456366,1]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTGNode
   
#ifndef BDTGNode__def
#define BDTGNode__def
   
class BDTGNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTGNode ( BDTGNode* left,BDTGNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTGNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTGNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTGNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTGNode*   fLeft;     // pointer to the left daughter node
   BDTGNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTGNode::~BDTGNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTGNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTGNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTG : public IClassifierReader {

 public:

   // constructor
   ReadBDTG( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTG" ),
        fNvars( 8 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "p_CMS", "cosTheta", "ErrM", "decayAngle", "daughter0E", "daughter1E", "daughter0clusterE9E25", "daughter1clusterE9E25" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTG() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[8];
   double fVmax[8];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[8];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTGNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTG::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTGNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTGNode*)current->GetRight();
         else current=(BDTGNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDTG::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.090514,-0.0742113) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.377743,-0.00845398) , 
6, 0.665012, 1, 0, 0.22472,-0.27528) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.360072,-0.0100586) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.823557,0.0114157) , 
6, 0.674648, 1, 0, 0.740427,0.240427) , 
0, 0.30334, 1, 0, 0.499696,-0.000303573)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.119775,-0.0546746) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.482941,-0.000926938) , 
6, 0.684432, 1, 0, 0.301964,-0.182756) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.578323,0.00389495) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890017,0.0126382) , 
6, 0.725226, 1, 0, 0.840479,0.336048) , 
0, 0.455877, 1, 0, 0.498472,0.00655842)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.120584,-0.0505504) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.484307,-0.000819421) , 
6, 0.684119, 1, 0, 0.302916,-0.168001) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583439,0.00401988) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889932,0.0124347) , 
6, 0.725226, 1, 0, 0.84073,0.330715) , 
0, 0.455135, 1, 0, 0.498851,0.0136904)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0705628,-0.0718479) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353985,-0.00935975) , 
6, 0.626686, 1, 0, 0.22126,-0.227635) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.380378,-0.00622313) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.829466,0.0110536) , 
6, 0.693867, 1, 0, 0.741976,0.236084) , 
0, 0.304532, 1, 0, 0.499609,0.0202465)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0901867,-0.0638438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.316646,-0.0095677) , 
7, 0.668178, 1, 0, 0.232679,-0.202211) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.39283,-0.00551151) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.836374,0.0110894) , 
6, 0.630653, 1, 0, 0.787341,0.273882) , 
2, 0.0282089, 1, 0, 0.499059,0.0264363)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.186018,-0.0272802) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528123,0.00263205) , 
2, 0.0195361, 1, 0, 0.303556,-0.130885) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572454,0.00351141) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.89051,0.0119133) , 
6, 0.725277, 1, 0, 0.840464,0.315746) , 
0, 0.454691, 1, 0, 0.499066,0.0317517)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0978931,-0.0499271) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465207,-0.000502771) , 
6, 0.645593, 1, 0, 0.304645,-0.121859) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.578457,0.00368148) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888013,0.0116827) , 
6, 0.725107, 1, 0, 0.838315,0.308404) , 
0, 0.455088, 1, 0, 0.497738,0.0338198)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.204617,-0.0214499) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.574134,0.00448533) , 
2, 0.0227937, 1, 0, 0.305769,-0.110913) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.577248,0.00355136) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.89027,0.0115597) , 
6, 0.725107, 1, 0, 0.840516,0.30543) , 
0, 0.454346, 1, 0, 0.500706,0.0408614)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0849357,-0.0576698) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.333968,-0.00555719) , 
7, 0.653538, 1, 0, 0.250053,-0.144575) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.42481,-0.00306052) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.846401,0.0106712) , 
6, 0.636739, 1, 0, 0.800265,0.268824) , 
2, 0.0304851, 1, 0, 0.502545,0.0451335)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0911398,-0.0475517) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.457115,9.15537e-05) , 
6, 0.631028, 1, 0, 0.305584,-0.0956094) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57753,0.00339398) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889223,0.0112186) , 
6, 0.726516, 1, 0, 0.839024,0.294198) , 
0, 0.454869, 1, 0, 0.499178,0.0458578)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0956405,-0.048671) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375176,-0.0023127) , 
7, 0.648659, 1, 0, 0.289388,-0.0998198) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.594672,0.00460391) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88006,0.010956) , 
6, 0.72062, 1, 0, 0.836065,0.290519) , 
2, 0.0404342, 1, 0, 0.502739,0.0525169)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193928,-0.0191554) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554817,0.00427145) , 
2, 0.0214533, 1, 0, 0.302153,-0.0839813) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570767,0.00298639) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887336,0.0108818) , 
6, 0.72344, 1, 0, 0.837621,0.283412) , 
0, 0.453948, 1, 0, 0.497142,0.0498035)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.111778,-0.035287) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.482335,0.00152322) , 
6, 0.669867, 1, 0, 0.306144,-0.0751859) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580195,0.00331537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888058,0.0107472) , 
6, 0.725107, 1, 0, 0.838139,0.279372) , 
0, 0.454346, 1, 0, 0.498705,0.0531503)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.115146,-0.0361443) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347287,-0.00252162) , 
7, 0.702336, 1, 0, 0.249613,-0.103598) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421462,-0.00282767) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.846324,0.00999483) , 
6, 0.64206, 1, 0, 0.7992,0.248675) , 
2, 0.0304977, 1, 0, 0.501342,0.0577544)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.164722,-0.0215277) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4924,0.00298254) , 
2, 0.0163742, 1, 0, 0.30653,-0.0628222) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572474,0.00281016) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88867,0.010483) , 
6, 0.726516, 1, 0, 0.838144,0.270135) , 
0, 0.455088, 1, 0, 0.499199,0.0578488)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0860214,-0.0413272) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.390989,-0.00144012) , 
6, 0.635883, 1, 0, 0.248383,-0.092562) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427467,-0.00241085) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.845268,0.00970297) , 
6, 0.641396, 1, 0, 0.798542,0.240069) , 
2, 0.0304977, 1, 0, 0.499078,0.0590101)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.112174,-0.0335025) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.343035,-0.00176107) , 
7, 0.702336, 1, 0, 0.24602,-0.0867999) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425803,-0.00242372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.844278,0.00954998) , 
6, 0.636739, 1, 0, 0.798255,0.23585) , 
2, 0.0305055, 1, 0, 0.49937,0.061223)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.127467,-0.0253399) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490044,0.00237532) , 
6, 0.694142, 1, 0, 0.303848,-0.0506162) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584726,0.00310358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890193,0.0101344) , 
6, 0.729766, 1, 0, 0.840027,0.259386) , 
0, 0.455088, 1, 0, 0.498041,0.0616603)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.132638,-0.0238571) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490155,0.00219568) , 
6, 0.703851, 1, 0, 0.299724,-0.0527274) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.66453,0.00575375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.894895,0.0101856) , 
6, 0.764238, 1, 0, 0.850666,0.267719) , 
2, 0.0457334, 1, 0, 0.499667,0.0635666)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.138003,-0.0245352) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.417954,0.00193869) , 
7, 0.716975, 1, 0, 0.304748,-0.0415544) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584835,0.00313232) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.891071,0.00990963) , 
6, 0.725107, 1, 0, 0.841774,0.253047) , 
0, 0.455135, 1, 0, 0.501229,0.0662309)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173745,-0.0153961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.505364,0.00382829) , 
2, 0.0174019, 1, 0, 0.307342,-0.0358405) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580786,0.00286954) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88913,0.00974017) , 
6, 0.726516, 1, 0, 0.839284,0.246345) , 
0, 0.454869, 1, 0, 0.500163,0.0664473)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0689332,-0.047914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.314407,-0.00175204) , 
7, 0.604741, 1, 0, 0.247763,-0.0623401) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.419064,-0.0027571) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.847456,0.00907595) , 
6, 0.641642, 1, 0, 0.800172,0.220474) , 
2, 0.0304851, 1, 0, 0.500657,0.0671333)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0799827,-0.0377737) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.433778,0.00188579) , 
6, 0.601898, 1, 0, 0.303232,-0.0326406) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582682,0.0028417) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890491,0.00954656) , 
6, 0.725226, 1, 0, 0.841125,0.240229) , 
0, 0.454691, 1, 0, 0.500403,0.0673831)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.146053,-0.0184818) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.457548,0.00301139) , 
2, 0.0143463, 1, 0, 0.302116,-0.02991) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5808,0.00264024) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889244,0.0093994) , 
6, 0.726516, 1, 0, 0.838856,0.234015) , 
0, 0.455611, 1, 0, 0.495717,0.0652871)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0719678,-0.0394704) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432663,0.00217405) , 
6, 0.592065, 1, 0, 0.306966,-0.0237445) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57871,0.00253938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890754,0.00932659) , 
6, 0.725107, 1, 0, 0.841049,0.232092) , 
0, 0.45548, 1, 0, 0.501425,0.0694052)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.166258,-0.0151124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.434487,0.00335316) , 
7, 0.751133, 1, 0, 0.305411,-0.0208368) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.603189,0.00294278) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.892227,0.00925357) , 
6, 0.748512, 1, 0, 0.838655,0.225942) , 
0, 0.454346, 1, 0, 0.498364,0.068459)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0626009,-0.0468262) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.294849,-0.00135349) , 
7, 0.580805, 1, 0, 0.237856,-0.0474228) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.396661,-0.00284732) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.836476,0.0084647) , 
6, 0.625917, 1, 0, 0.788477,0.199931) , 
2, 0.0282089, 1, 0, 0.501529,0.0710265)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.143557,-0.0161808) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558537,0.00406507) , 
6, 0.698996, 1, 0, 0.361279,-0.00117459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887813,0.00934307) , 
0, 0.605968, 1, 0, 0.497169,0.0672756)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.207558,-0.00741231) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.578062,0.00507687) , 
2, 0.0233757, 1, 0, 0.304673,-0.015385) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678218,0.00287069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.879904,0.00913555) , 
7, 0.78859, 1, 0, 0.839747,0.21702) , 
0, 0.454691, 1, 0, 0.499595,0.0692777)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0788744,-0.0379349) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382246,0.00183427) , 
7, 0.614501, 1, 0, 0.305464,-0.0163631) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.687383,0.00452791) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889464,0.00907449) , 
4, 0.169354, 1, 0, 0.847328,0.222793) , 
2, 0.0457106, 1, 0, 0.499606,0.0693227)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0777355,-0.0310852) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.373884,0.00111397) , 
6, 0.607541, 1, 0, 0.249907,-0.0310519) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414678,-0.00274536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.847456,0.00822001) , 
6, 0.641463, 1, 0, 0.800191,0.192853) , 
2, 0.0305046, 1, 0, 0.502492,0.0717223)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.159024,-0.0122838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.571516,0.00440975) , 
6, 0.718416, 1, 0, 0.364033,0.00647625) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.886101,0.00891163) , 
0, 0.606957, 1, 0, 0.49659,0.0674858)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.169541,-0.0129702) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.462081,0.00388495) , 
7, 0.741374, 1, 0, 0.331809,-0.00242609) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.806406,0.00677958) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.914405,0.00951316) , 
0, 0.764856, 1, 0, 0.868742,0.228496) , 
2, 0.0562855, 1, 0, 0.500771,0.0702403)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.099786,-0.0233118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522242,0.00370147) , 
6, 0.631028, 1, 0, 0.364968,0.0091466) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888513,0.00877041) , 
0, 0.606041, 1, 0, 0.499225,0.0685733)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.168363,-0.0127424) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.495407,0.00425318) , 
7, 0.731614, 1, 0, 0.365263,0.0111202) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88848,0.00867677) , 
0, 0.605052, 1, 0, 0.499913,0.0692749)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.165248,-0.00990714) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570558,0.00422065) , 
6, 0.723271, 1, 0, 0.362649,0.0097742) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887301,0.00854067) , 
0, 0.606041, 1, 0, 0.497789,0.0669528)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0540513,-0.0461432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.294656,-0.000264207) , 
7, 0.565703, 1, 0, 0.240971,-0.0286354) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579297,-0.000804193) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834868,0.007997) , 
7, 0.736911, 1, 0, 0.800106,0.177675) , 
2, 0.0304851, 1, 0, 0.49781,0.0661336)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.117607,-0.0161304) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539322,0.00388947) , 
6, 0.655302, 1, 0, 0.366225,0.0144508) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887155,0.00838019) , 
0, 0.605968, 1, 0, 0.500086,0.068603)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.197799,-0.00806014) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.509217,0.00441747) , 
7, 0.760893, 1, 0, 0.364496,0.0137719) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889245,0.00833525) , 
0, 0.605968, 1, 0, 0.500295,0.0679405)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.150496,-0.0108095) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.383623,0.00303091) , 
2, 0.0142223, 1, 0, 0.226421,-0.0265213) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.401494,-0.00428433) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.801586,0.00755621) , 
7, 0.709233, 1, 0, 0.741657,0.151063) , 
0, 0.30334, 1, 0, 0.5022,0.0685299)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0791497,-0.0264383) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.434893,0.00266013) , 
6, 0.601898, 1, 0, 0.303605,-0.00266068) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653866,0.00348861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.894359,0.0081529) , 
6, 0.76238, 1, 0, 0.84849,0.189877) , 
2, 0.0457232, 1, 0, 0.500104,0.0667733)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173884,-0.00727904) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576455,0.00420635) , 
2, 0.0180336, 1, 0, 0.364299,0.0143597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888734,0.00808752) , 
0, 0.607565, 1, 0, 0.499724,0.0656456)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.168194,-0.0102746) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494514,0.00409035) , 
7, 0.730173, 1, 0, 0.365791,0.0163322) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.887445,0.00797577) , 
0, 0.605447, 1, 0, 0.499711,0.0657116)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.105028,-0.0200104) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345568,0.00149752) , 
6, 0.567527, 1, 0, 0.225675,-0.0299951) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.230637,-0.0145484) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.791449,0.00733012) , 
7, 0.628988, 1, 0, 0.712859,0.13708) , 
6, 0.742691, 1, 0, 0.498262,0.0634861)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.187614,-0.00749039) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502934,0.0041591) , 
7, 0.749447, 1, 0, 0.364603,0.0170655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.889196,0.00789875) , 
0, 0.605052, 1, 0, 0.501493,0.0660623)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0598222,-0.0355956) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293237,0.000592814) , 
7, 0.590442, 1, 0, 0.23268,-0.0181681) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.380433,-0.0039806) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834763,0.00696565) , 
6, 0.622768, 1, 0, 0.786688,0.150326) , 
2, 0.0282089, 1, 0, 0.497105,0.062253)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.163067,-0.00724927) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570239,0.00394084) , 
6, 0.717621, 1, 0, 0.365313,0.0167935) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888528,0.00773777) , 
0, 0.606437, 1, 0, 0.500095,0.0635575)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0952927,-0.0226363) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.411417,0.00266063) , 
7, 0.62914, 1, 0, 0.329004,0.00650719) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.753001,0.0048201) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912795,0.00808285) , 
6, 0.830251, 1, 0, 0.867783,0.181833) , 
2, 0.0562661, 1, 0, 0.498845,0.0617755)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.110308,-0.0209238) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300726,0.0013945) , 
4, 0.0765816, 1, 0, 0.232352,-0.0227302) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.209721,-0.0154097) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.787497,0.00695817) , 
7, 0.609715, 1, 0, 0.714298,0.130635) , 
6, 0.746338, 1, 0, 0.498959,0.0621097)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.140359,-0.00965392) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346087,0.00233159) , 
2, 0.0127248, 1, 0, 0.223845,-0.0169007) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376196,-0.00504696) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.794645,0.00677286) , 
7, 0.685233, 1, 0, 0.740335,0.131403) , 
0, 0.30334, 1, 0, 0.49952,0.0622558)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0876255,-0.0204353) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.488327,0.00330619) , 
6, 0.587334, 1, 0, 0.363772,0.0176179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888812,0.00749563) , 
0, 0.606041, 1, 0, 0.499396,0.0616519)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.108745,-0.0158868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.381926,0.0021649) , 
6, 0.577324, 1, 0, 0.246061,-0.0163474) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.255353,-0.00946384) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.801003,0.00689513) , 
7, 0.637732, 1, 0, 0.722441,0.129236) , 
6, 0.760696, 1, 0, 0.500052,0.0612731)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.106669,-0.0174221) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427657,0.00296702) , 
7, 0.663298, 1, 0, 0.330849,0.00983019) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.804064,0.00519074) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.916733,0.00818577) , 
0, 0.782008, 1, 0, 0.866868,0.169658) , 
2, 0.0562661, 1, 0, 0.498727,0.0598874)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.202681,-0.00515594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513523,0.00395823) , 
7, 0.770652, 1, 0, 0.362182,0.0164933) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88791,0.00728209) , 
0, 0.607749, 1, 0, 0.496915,0.0582766)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.186998,-0.00542518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.459509,0.00347303) , 
7, 0.768571, 1, 0, 0.318706,0.00779639) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.739865,0.00368307) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.90301,0.00762133) , 
4, 0.211519, 1, 0, 0.86094,0.161891) , 
2, 0.0516885, 1, 0, 0.500428,0.0594393)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176675,-0.00485824) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576948,0.00379883) , 
6, 0.732981, 1, 0, 0.365646,0.0185175) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.88846,0.00715441) , 
0, 0.607222, 1, 0, 0.500025,0.0585674)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.146728,-0.00639689) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489274,0.0029406) , 
6, 0.723271, 1, 0, 0.292334,0.00325239) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.660285,0.0019239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882738,0.00710562) , 
4, 0.1505, 1, 0, 0.841415,0.148654) , 
2, 0.0422877, 1, 0, 0.501718,0.058699)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0818144,-0.0242399) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.408326,0.0026966) , 
7, 0.609621, 1, 0, 0.33123,0.011301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.804976,0.00485483) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.918671,0.00793308) , 
0, 0.783819, 1, 0, 0.868596,0.158616) , 
2, 0.0562846, 1, 0, 0.499649,0.0574719)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.142824,-0.0077124) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355472,0.00222707) , 
2, 0.0132101, 1, 0, 0.223452,-0.0129379) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.36899,-0.00490393) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.794771,0.00630194) , 
7, 0.675837, 1, 0, 0.742921,0.119153) , 
0, 0.30377, 1, 0, 0.501946,0.0578778)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0745166,-0.0225386) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.432436,0.00256094) , 
6, 0.564467, 1, 0, 0.328736,0.00978701) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.804704,0.00465105) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.917743,0.00778224) , 
0, 0.783819, 1, 0, 0.867595,0.15226) , 
2, 0.0562864, 1, 0, 0.497818,0.0544918)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.117011,-0.0172341) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.366246,0.00120569) , 
7, 0.574636, 1, 0, 0.286786,-0.0122373) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.179275,-0.00987326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.797013,0.00667351) , 
6, 0.597583, 1, 0, 0.681406,0.113373) , 
7, 0.799931, 1, 0, 0.497627,0.054875)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.088435,-0.0162246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.496977,0.00309239) , 
6, 0.597044, 1, 0, 0.364917,0.0193436) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888177,0.00678653) , 
0, 0.607222, 1, 0, 0.499903,0.0555768)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.118484,-0.0154193) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.316304,0.00196323) , 
4, 0.0761843, 1, 0, 0.248194,-0.00904762) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.262865,-0.00682809) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.803127,0.00622209) , 
7, 0.643443, 1, 0, 0.723225,0.112748) , 
6, 0.76211, 1, 0, 0.500171,0.0555581)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0779953,-0.0193753) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472152,0.00293675) , 
6, 0.563059, 1, 0, 0.3657,0.0197531) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.888306,0.00668422) , 
0, 0.607222, 1, 0, 0.498999,0.0544253)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.111133,-0.0181944) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.360411,0.00111744) , 
7, 0.559583, 1, 0, 0.285657,-0.0119932) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.260519,-0.00487532) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.78364,0.00665176) , 
4, 0.0818701, 1, 0, 0.681295,0.109788) , 
7, 0.795051, 1, 0, 0.502237,0.0546722)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.107959,-0.0187762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.310346,0.00037817) , 
7, 0.539483, 1, 0, 0.245378,-0.0199048) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277818,-0.0032171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.772658,0.00640708) , 
4, 0.0895042, 1, 0, 0.655079,0.0993069) , 
7, 0.760893, 1, 0, 0.499956,0.0541705)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.21984,-0.00354481) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.561396,0.00387245) , 
7, 0.770652, 1, 0, 0.404809,0.0241497) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.916163,0.007416) , 
0, 0.757392, 1, 0, 0.500437,0.0521472)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.108486,-0.0168961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382068,0.001337) , 
7, 0.555943, 1, 0, 0.312269,-0.00376417) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.179265,-0.00931328) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.797976,0.00638148) , 
6, 0.572769, 1, 0, 0.701599,0.110838) , 
7, 0.824329, 1, 0, 0.497004,0.050614)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.163044,-0.00435098) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.570355,0.00309402) , 
2, 0.0165366, 1, 0, 0.37832,0.017879) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.901772,0.00686975) , 
2, 0.0867172, 1, 0, 0.498302,0.0498482)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0861586,-0.0186239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.430564,0.00261964) , 
7, 0.609621, 1, 0, 0.352556,0.0160245) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.882404,0.00631) , 
2, 0.0662366, 1, 0, 0.500768,0.0513723)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.173126,-0.00441894) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.339724,0.003044) , 
0, 0.219004, 1, 0, 0.22539,-0.00679047) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486343,-0.00034579) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.817116,0.00602102) , 
7, 0.768564, 1, 0, 0.741142,0.100895) , 
0, 0.30334, 1, 0, 0.501118,0.0507797)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.091172,-0.0148585) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.531902,0.00303062) , 
6, 0.587334, 1, 0, 0.404427,0.022848) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.912502,0.00701442) , 
0, 0.759282, 1, 0, 0.498487,0.0479932)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.115619,-0.00826422) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.539956,0.00280552) , 
6, 0.655302, 1, 0, 0.365955,0.0163071) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.892753,0.0063975) , 
2, 0.0751991, 1, 0, 0.500914,0.0486187)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.143767,-0.0115691) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.344996,0.00110014) , 
5, 0.0770813, 1, 0, 0.280024,-0.010098) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.256305,-0.00470853) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.778161,0.0060125) , 
4, 0.0818701, 1, 0, 0.674928,0.0939828) , 
7, 0.792812, 1, 0, 0.497542,0.047231)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.165288,-0.00490198) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498389,0.00303242) , 
0, 0.207604, 1, 0, 0.365396,0.0172898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890833,0.00623035) , 
2, 0.0751808, 1, 0, 0.500026,0.0479433)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.112082,-0.0148833) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.315758,0.00165162) , 
4, 0.0736467, 1, 0, 0.253207,-0.00638115) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.228364,-0.00868007) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.799873,0.0055429) , 
7, 0.62426, 1, 0, 0.72473,0.0958752) , 
6, 0.766965, 1, 0, 0.498934,0.0469083)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19214,-0.00380535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.544866,0.00336459) , 
7, 0.741374, 1, 0, 0.405431,0.0238163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.915235,0.00688446) , 
0, 0.758997, 1, 0, 0.500518,0.0476476)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.101089,-0.0128015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.465333,0.00235813) , 
6, 0.620526, 1, 0, 0.29123,-0.000511706) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.301002,-0.00554242) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.816439,0.0060237) , 
5, 0.0833125, 1, 0, 0.736304,0.100324) , 
4, 0.155147, 1, 0, 0.502344,0.0473181)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0788499,-0.0196129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.427008,0.00226812) , 
6, 0.577624, 1, 0, 0.288733,-0.000654391) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.27187,-0.0056616) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.822791,0.00590236) , 
7, 0.643443, 1, 0, 0.736012,0.0991604) , 
4, 0.155147, 1, 0, 0.501179,0.046755)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.220433,-0.00160497) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.629188,0.00330898) , 
6, 0.766965, 1, 0, 0.403375,0.0212284) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.913651,0.00669943) , 
0, 0.758997, 1, 0, 0.497508,0.0439881)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.116897,-0.0129589) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.331433,0.00185776) , 
1, -0.631841, 1, 0, 0.287673,0.00593541) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.648112,0.000534842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.877521,0.00583975) , 
4, 0.147481, 1, 0, 0.835097,0.104507) , 
2, 0.0404536, 1, 0, 0.499686,0.0441115)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0762951,-0.0197416) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.403561,0.00209803) , 
6, 0.53393, 1, 0, 0.311328,0.00581436) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.345555,-0.00558465) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.842266,0.00595581) , 
5, 0.0845467, 1, 0, 0.769949,0.0994158) , 
4, 0.178017, 1, 0, 0.501138,0.0445534)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.120795,-0.0111864) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.325674,0.00182829) , 
4, 0.0765816, 1, 0, 0.255722,-0.00342724) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.197405,-0.0116904) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.787486,0.00512333) , 
7, 0.575463, 1, 0, 0.726204,0.0875996) , 
6, 0.766965, 1, 0, 0.501627,0.0441495)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.128623,-0.0148511) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.336598,0.000986837) , 
1, -0.701493, 1, 0, 0.290173,-0.0056575) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.260171,-0.00364015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.7824,0.00554221) , 
4, 0.0818701, 1, 0, 0.680399,0.084448) , 
7, 0.799931, 1, 0, 0.498678,0.0424875)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.171983,-0.00368333) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347913,0.00263332) , 
0, 0.219169, 1, 0, 0.243728,-0.0001076) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.571761,-0.0016679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.83529,0.00530656) , 
7, 0.727612, 1, 0, 0.80231,0.0930981) , 
2, 0.0304977, 1, 0, 0.501374,0.0428835)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.137482,-0.00757621) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515878,0.00277045) , 
7, 0.682817, 1, 0, 0.406714,0.0204313) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.913626,0.00645847) , 
0, 0.757392, 1, 0, 0.499634,0.0413925)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0775823,-0.0196748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.438731,0.00239112) , 
7, 0.585356, 1, 0, 0.368296,0.0161581) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.890663,0.00570488) , 
2, 0.0751808, 1, 0, 0.500687,0.0418194)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0825766,-0.0154576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.433126,0.00216125) , 
6, 0.564467, 1, 0, 0.312816,0.00597354) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.484645,-0.000426339) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.876459,0.0061158) , 
5, 0.12312, 1, 0, 0.769324,0.0919936) , 
4, 0.178017, 1, 0, 0.501196,0.04147)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.215929,-0.00252151) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563277,0.00309146) , 
7, 0.765772, 1, 0, 0.408213,0.0200463) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.915116,0.00635556) , 
0, 0.758908, 1, 0, 0.50218,0.0404287)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.26621,-0.000978594) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.588364,0.00320815) , 
7, 0.81457, 1, 0, 0.403707,0.0182107) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.913894,0.00625684) , 
0, 0.756155, 1, 0, 0.497581,0.0382235)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0757039,-0.0177322) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.419622,0.00213345) , 
7, 0.580535, 1, 0, 0.351682,0.0140377) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.879275,0.00521226) , 
2, 0.065298, 1, 0, 0.499996,0.0394954)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273543,-0.000953069) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.59656,0.0032329) , 
7, 0.824329, 1, 0, 0.403723,0.0170881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.914585,0.00619283) , 
0, 0.758303, 1, 0, 0.498386,0.0369411)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0731158,-0.0195129) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.395696,0.00165664) , 
6, 0.548495, 1, 0, 0.285388,-0.00140203) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.302465,-0.00421064) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.80846,0.00525984) , 
5, 0.0851925, 1, 0, 0.722804,0.0801028) , 
4, 0.148513, 1, 0, 0.50205,0.0389691)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.193665,-0.0017457) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.622307,0.00270624) , 
6, 0.739112, 1, 0, 0.405898,0.0185801) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.913182,0.00607521) , 
0, 0.757392, 1, 0, 0.499135,0.0373071)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.176935,-0.0135497) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352223,0.00117496) , 
3, -0.54222, 1, 0, 0.334274,0.00315191) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.280828,-0.00323298) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.808523,0.0053523) , 
4, 0.0803392, 1, 0, 0.715643,0.0819811) , 
7, 0.838969, 1, 0, 0.49958,0.0373207)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.192814,-0.00309326) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517929,0.00232194) , 
7, 0.756013, 1, 0, 0.372119,0.0111232) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.897615,0.0054829) , 
2, 0.0820472, 1, 0, 0.496789,0.0339035)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.273419,-0.00612536) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.412554,0.00226054) , 
3, -0.581939, 1, 0, 0.394491,0.016929) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.90919,0.00580589) , 
2, 0.098673, 1, 0, 0.500141,0.0366749)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.131648,-0.0111044) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364499,0.00165686) , 
4, 0.070059, 1, 0, 0.311758,0.00312784) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.336177,-0.00525981) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.839491,0.00522669) , 
5, 0.0833124, 1, 0, 0.768284,0.0811435) , 
4, 0.178933, 1, 0, 0.498847,0.0350994)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.0671419,-0.023046) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.430604,0.00195895) , 
7, 0.541304, 1, 0, 0.375761,0.0139278) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.896171,0.00525854) , 
2, 0.0820597, 1, 0, 0.498085,0.034328)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.12635,-0.0131068) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446907,0.00195383) , 
1, -0.701488, 1, 0, 0.403089,0.0147032) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.913817,0.00582142) , 
0, 0.758566, 1, 0, 0.497631,0.0325729)    );
   return;
};
 
// Clean up
inline void ReadBDTG::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTG::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
