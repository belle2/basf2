// Class: ReadBDTGradient
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDTGradient
TMVA Release   : 4.2.0         [262656]
ROOT Release   : 5.34/13       [336397]
Creator        : cpulvermacher
Date           : Mon May  5 16:38:25 2014
Host           : Linux ekplx12 3.11.0-20-generic #34-Ubuntu SMP Tue Apr 1 20:40:25 UTC 2014 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /local/scratch/cpulvermacher/basf2
Training events: 48862
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "True" [Create PDFs for classifier outputs (signal and background)]
NTrees: "100" [Number of trees in the forest]
MaxDepth: "2" [Max depth of the decision tree allowed]
nCuts: "200" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "1.000000e-01" [Learning rate for GradBoost algorithm]
UseBaggedGrad: "True" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "5.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "True" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Possion distribution in each split with RandomisedTree option]
BaggedSampleFraction: "5.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "ignorenegweightsintraining" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in traning sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 2
eid                           eid                           eid                           eid                                                             'F'    [0,1]
p                             p                             p                             p                                                               'F'    [0.00528030842543,555.807495117]
NSpec 0


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTGradientNode
   
#ifndef BDTGradientNode__def
#define BDTGradientNode__def
   
class BDTGradientNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTGradientNode ( BDTGradientNode* left,BDTGradientNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTGradientNode();

   // test event if it decends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTGradientNode* GetRight( void )  {return fRight; };

   // test event if it decends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTGradientNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTGradientNode*   fLeft;     // pointer to the left daughter node
   BDTGradientNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value appplied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTGradientNode::~BDTGradientNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTGradientNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTGradientNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it decends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDTGradient : public IClassifierReader {

 public:

   // constructor
   ReadBDTGradient( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDTGradient" ),
        fNvars( 2 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "eid", "p" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDTGradient() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[2];
   double fVmax[2];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[2];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTGradientNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDTGradient::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTGradientNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTGradientNode*)current->GetRight();
         else current=(BDTGradientNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDTGradient::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.857469,0.00982789) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827718,0.00913648) , 
1, 0.416379, 1, 0, 0.843061,0.343061) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.476551,-0.00163001) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358164,-0.00860468) , 
0, 0.162714, 0, 0, 0.369213,-0.130787) , 
0, 0.860696, 0, 0, 0.497154,-0.0028461)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86845,0.00977969) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.813899,0.00901703) , 
1, 0.431882, 1, 0, 0.844592,0.339843) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.697285,0.00641771) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.219939,-0.0204836) , 
1, 1.01589, 0, 0, 0.358238,-0.137827) , 
0, 0.895522, 0, 0, 0.488828,-0.0095685)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.862024,0.00951321) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.836849,0.00886647) , 
1, 0.418194, 1, 0, 0.850241,0.341372) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.426828,-0.00176171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346283,-0.00796634) , 
0, 0.14544, 0, 0, 0.353345,-0.136135) , 
0, 0.835821, 0, 0, 0.495208,0.000192321)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.857293,0.00924666) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.816728,0.00870844) , 
1, 0.389449, 1, 0, 0.836946,0.324133) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427196,-0.00379629) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355177,-0.00769557) , 
0, 0.0902571, 0, 0, 0.361692,-0.12411) , 
0, 0.756219, 0, 0, 0.502752,0.00893382)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.84941,0.00914915) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.72868,0.00713216) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244233,-0.0171093) , 
1, 1.09373, 0, 0, 0.369433,-0.113432) , 
0, 0.920398, 0, 0, 0.498163,0.00573418)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.838576,0.00899042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.831159,0.0084765) , 
1, 0.397257, 1, 0, 0.834675,0.314637) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463283,-0.00271557) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353905,-0.00720133) , 
0, 0.170936, 0, 0, 0.361938,-0.114354) , 
0, 0.731343, 0, 0, 0.502738,0.0134162)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.837144,0.00887438) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.815758,0.00836423) , 
1, 0.39662, 1, 0, 0.82685,0.302666) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.696861,0.00661586) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238394,-0.02028) , 
1, 1.02013, 0, 0, 0.37128,-0.102085) , 
0, 0.731343, 0, 0, 0.50404,0.0158658)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.871294,0.00912622) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.830989,0.00832089) , 
1, 0.425282, 1, 0, 0.853246,0.321721) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444544,0.000635943) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.348216,-0.00660873) , 
0, 0.19261, 0, 0, 0.357224,-0.110491) , 
0, 0.900497, 0, 0, 0.495316,0.00983641)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.857462,0.00889883) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.821053,0.00820115) , 
1, 0.437173, 1, 0, 0.841404,0.306446) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.725421,0.00710484) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244619,-0.0164265) , 
1, 1.08744, 0, 0, 0.370872,-0.0941918) , 
0, 0.870647, 0, 0, 0.495758,0.0121432)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.876787,0.00876864) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827218,0.00811638) , 
1, 0.396112, 1, 0, 0.852802,0.314107) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62344,0.00500684) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.220965,-0.0228142) , 
1, 0.801673, 0, 0, 0.375556,-0.0837623) , 
0, 0.830846, 0, 0, 0.511725,0.0297589)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.852656,0.00867872) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834496,0.00798403) , 
1, 0.43806, 1, 0, 0.844145,0.300712) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.71795,0.00693712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.24079,-0.0151809) , 
1, 1.09373, 0, 0, 0.3628,-0.0910417) , 
0, 0.865672, 0, 0, 0.494145,0.0158566)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.838164,0.00828349) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.422323,0.000724799) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.350773,-0.00559144) , 
0, 0.171232, 0, 0, 0.357004,-0.0917964) , 
0, 0.860696, 0, 0, 0.487641,0.0120725)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.852529,0.00833147) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.818897,0.00774803) , 
1, 0.396112, 1, 0, 0.837002,0.289498) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584438,0.00441478) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.178525,-0.025097) , 
1, 0.728287, 0, 0, 0.356134,-0.0893946) , 
0, 0.731343, 0, 0, 0.497414,0.0219248)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.853961,0.00821635) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.62676,0.00503403) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.202557,-0.0176739) , 
1, 0.810704, 0, 0, 0.363105,-0.0790799) , 
0, 0.925373, 0, 0, 0.497003,0.0235737)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.83971,0.00817418) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.817714,0.00751487) , 
1, 0.417484, 1, 0, 0.829564,0.275138) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.454381,0.000237078) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356399,-0.00490998) , 
0, 0.163418, 0, 0, 0.36382,-0.0716195) , 
0, 0.731343, 0, 0, 0.498163,0.0284022)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.877621,0.0082207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.840546,0.00748365) , 
1, 0.418673, 1, 0, 0.861097,0.299005) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.588336,0.00449179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.187596,-0.0208424) , 
1, 0.737318, 0, 0, 0.3601,-0.0738658) , 
0, 0.845771, 0, 0, 0.510529,0.0380924)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.849113,0.00802394) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.822441,0.00738458) , 
1, 0.396112, 1, 0, 0.836063,0.273637) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.366621,-0.00385716) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.283382,-0.00530501) , 
0, 0.00368306, 1, 0, 0.354657,-0.0746691) , 
0, 0.741294, 0, 0, 0.495487,0.0272239)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.851239,0.00792812) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827098,0.00729105) , 
1, 0.397257, 1, 0, 0.839493,0.274814) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435243,0.00037205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35708,-0.00433362) , 
0, 0.177658, 0, 0, 0.362647,-0.0653852) , 
0, 0.731343, 0, 0, 0.508393,0.0385954)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.850371,0.00775255) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.682007,0.00637904) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.243464,-0.0130046) , 
1, 1.00003, 0, 0, 0.369257,-0.0582232) , 
0, 0.920398, 0, 0, 0.497919,0.0307044)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.841282,0.00779284) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.821216,0.00711641) , 
1, 0.396112, 1, 0, 0.830941,0.259371) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.452967,0.00117042) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365658,-0.00409445) , 
0, 0.163662, 0, 0, 0.371998,-0.0509021) , 
0, 0.731343, 0, 0, 0.50474,0.0388391)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.878496,0.00788393) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.807891,0.00706092) , 
1, 0.431413, 1, 0, 0.849082,0.266227) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.466259,0.00246389) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367423,-0.00394516) , 
0, 0.16929, 0, 0, 0.376492,-0.044047) , 
0, 0.895522, 0, 0, 0.504846,0.0402229)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.837802,0.00753099) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.810571,0.00685647) , 
1, 0.41699, 1, 0, 0.826032,0.25048) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.431013,0.000574221) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358398,-0.00386673) , 
0, 0.100233, 0, 0, 0.364278,-0.0532056) , 
0, 0.671642, 0, 0, 0.501707,0.0371785)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.836408,0.00747354) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826436,0.00682821) , 
1, 0.439926, 1, 0, 0.8322,0.251301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.626431,0.00540753) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.186522,-0.0183349) , 
1, 0.823582, 0, 0, 0.357536,-0.0594477) , 
0, 0.731343, 0, 0, 0.49694,0.0318158)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.860632,0.00753299) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.746862,0.00578195) , 
0, 0.998366, 0, 0, 0.826334,0.243071) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.70024,0.00687453) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.220581,-0.0125163) , 
1, 1.08744, 0, 0, 0.341094,-0.0701891) , 
0, 0.671642, 0, 0, 0.491404,0.0268477)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.854799,0.00744903) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.729521,0.00544247) , 
0, 0.997921, 0, 0, 0.817062,0.235494) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579473,0.00435126) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.156652,-0.0226321) , 
1, 0.674597, 0, 0, 0.367798,-0.042245) , 
0, 0.58209, 0, 0, 0.501708,0.0405392)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.861814,0.00724857) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515465,0.00334372) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368071,-0.00308487) , 
0, 0.160721, 0, 0, 0.384901,-0.0276733) , 
0, 0.950249, 0, 0, 0.511813,0.0491164)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.856966,0.00701787) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.641889,0.0055974) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.216928,-0.0137063) , 
1, 0.869193, 0, 0, 0.367652,-0.0382007) , 
0, 0.870647, 0, 0, 0.506938,0.0451237)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.858576,0.00703961) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.803228,0.00835044) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.297843,-0.00634416) , 
1, 1.45976, 0, 0, 0.37364,-0.0291856) , 
0, 0.920398, 0, 0, 0.50332,0.0457626)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.862744,0.00699342) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47786,0.00333559) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.347184,-0.00272871) , 
0, 0.161944, 0, 0, 0.360451,-0.0410277) , 
0, 0.930348, 0, 0, 0.495956,0.0379481)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.850774,0.00706985) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.821968,0.00632049) , 
1, 0.398128, 1, 0, 0.8363,0.230482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.449826,0.00264128) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.332526,-0.00264875) , 
0, 0.160708, 0, 0, 0.341684,-0.0539041) , 
0, 0.751244, 0, 0, 0.492474,0.0327946)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.871882,0.0069678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649006,0.00466926) , 
0, 0.987754, 0, 0, 0.820545,0.224692) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.743867,0.00726961) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.235943,-0.00946951) , 
1, 1.21075, 0, 0, 0.352212,-0.0451766) , 
0, 0.507463, 0, 0, 0.499252,0.0395527)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.852121,0.00664681) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.726189,0.00661931) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.247768,-0.00946013) , 
1, 1.0856, 0, 0, 0.374653,-0.0219092) , 
0, 0.855721, 0, 0, 0.511832,0.0517221)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856425,0.00671315) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493293,0.00329163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353755,-0.00229363) , 
0, 0.157317, 0, 0, 0.369212,-0.0248358) , 
0, 0.930348, 0, 0, 0.496589,0.0424253)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.856359,0.00664443) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.692613,0.00654737) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.234926,-0.00824906) , 
1, 1.08744, 0, 0, 0.347702,-0.0462623) , 
0, 0.930348, 0, 0, 0.489206,0.0304491)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.848615,0.00677794) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.820988,0.00594955) , 
1, 0.396112, 1, 0, 0.834906,0.216537) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.604028,0.00480636) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.192983,-0.0167283) , 
1, 0.729188, 0, 0, 0.379713,-0.0104021) , 
0, 0.731343, 0, 0, 0.511599,0.0553504)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.865218,0.0065125) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428801,0.00271561) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.36114,-0.00194273) , 
0, 0.0462697, 0, 0, 0.370384,-0.0195395) , 
0, 0.930348, 0, 0, 0.505083,0.0490037)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.840003,0.00664674) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.835059,0.00581306) , 
1, 0.396112, 1, 0, 0.837457,0.215045) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.596685,0.00482914) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.175935,-0.0160109) , 
1, 0.737318, 0, 0, 0.360813,-0.0238603) , 
0, 0.731343, 0, 0, 0.501417,0.046614)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.863302,0.00648731) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.653515,0.00430364) , 
0, 0.980406, 0, 0, 0.816084,0.203308) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58737,0.00457643) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.16264,-0.0181962) , 
1, 0.701203, 0, 0, 0.362292,-0.0197299) , 
0, 0.507463, 0, 0, 0.505247,0.0505322)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.867541,0.00658924) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.816063,0.00565797) , 
1, 0.404897, 1, 0, 0.843513,0.20787) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.403594,0.00289084) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.351222,-0.00158028) , 
0, 0.0483295, 0, 0, 0.357283,-0.0232764) , 
0, 0.810945, 0, 0, 0.499536,0.0443482)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.833895,0.00610345) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.679777,0.00565259) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22735,-0.00981322) , 
1, 0.928572, 0, 0, 0.375452,-0.0049152) , 
0, 0.835821, 0, 0, 0.499864,0.0493364)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.849927,0.00620874) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.456109,0.00352748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34643,-0.00142643) , 
0, 0.102335, 0, 0, 0.360077,-0.021405) , 
0, 0.935323, 0, 0, 0.486813,0.0365265)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.852794,0.00613807) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486657,0.00358251) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368085,-0.00133127) , 
0, 0.180289, 0, 0, 0.379912,-0.00363052) , 
0, 0.930348, 0, 0, 0.501582,0.0494344)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.85308,0.00629226) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.826184,0.00542756) , 
1, 0.396112, 1, 0, 0.839493,0.196707) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605721,0.00469239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.183761,-0.0138141) , 
1, 0.737318, 0, 0, 0.372279,-0.00459579) , 
0, 0.756219, 0, 0, 0.507187,0.0535303)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.847704,0.00593402) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.772022,0.00729574) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.265906,-0.00485576) , 
1, 1.33922, 0, 0, 0.360158,-0.0190085) , 
0, 0.895522, 0, 0, 0.493233,0.0391646)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.848516,0.0059609) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.560069,0.00302656) , 
0, 0.93032, 0, 0, 0.792069,0.175423) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.689561,0.00579445) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.201764,-0.00946538) , 
1, 1.00691, 0, 0, 0.349528,-0.0225378) , 
0, 0.363184, 0, 0, 0.48917,0.0399275)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.851313,0.00612772) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.834599,0.00524219) , 
1, 0.396112, 1, 0, 0.842613,0.192301) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.741785,0.0065243) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.249128,-0.00588374) , 
1, 1.20651, 0, 0, 0.357155,-0.0137971) , 
0, 0.751244, 0, 0, 0.503056,0.0481444)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.859624,0.00583539) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.730729,0.00639835) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.265529,-0.00493171) , 
1, 1.19752, 0, 0, 0.365339,-0.0098436) , 
0, 0.925373, 0, 0, 0.498774,0.0457962)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.861431,0.00595751) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71467,0.00430241) , 
0, 0.995103, 0, 0, 0.816765,0.180396) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.569675,0.00446163) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.158202,-0.0157657) , 
1, 0.692218, 0, 0, 0.352085,-0.0157562) , 
0, 0.507463, 0, 0, 0.499033,0.0462741)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856766,0.0058738) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.602256,0.00431929) , 
0, 0.991504, 0, 0, 0.770299,0.16387) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.723532,0.00584114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.211803,-0.00845158) , 
1, 1.09314, 0, 0, 0.353552,-0.0150784) , 
0, 0.144279, 0, 0, 0.498928,0.0473452)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.861012,0.00593723) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.828819,0.00500353) , 
1, 0.437173, 1, 0, 0.846586,0.180467) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.720591,0.00571955) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.243214,-0.00568615) , 
1, 1.0856, 0, 0, 0.36488,-0.00236076) , 
0, 0.855721, 0, 0, 0.49941,0.0486992)    );
  // itree = 50
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.87045,0.00599632) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.822618,0.00497287) , 
1, 0.432471, 1, 0, 0.849265,0.177489) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.472587,0.00435579) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.350546,-0.000607704) , 
0, 0.165734, 0, 0, 0.362416,-0.00293264) , 
0, 0.900497, 0, 0, 0.494725,0.0460997)    );
  // itree = 51
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.879852,0.00598255) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.831162,0.00499836) , 
1, 0.440428, 1, 0, 0.858665,0.182805) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473736,0.00397) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367569,-0.000579519) , 
0, 0.170137, 0, 0, 0.378299,0.00743415) , 
0, 0.925373, 0, 0, 0.509274,0.0552503)    );
  // itree = 52
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.871064,0.00568986) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.624641,0.00415991) , 
0, 0.995991, 0, 0, 0.790213,0.167017) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570465,0.0043849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.114522,-0.0192197) , 
1, 0.674597, 0, 0, 0.346974,-0.019121) , 
0, 0.19403, 0, 0, 0.502881,0.046352)    );
  // itree = 53
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.869413,0.00558197) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.586645,0.00400723) , 
0, 0.983374, 0, 0, 0.786859,0.165819) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.707977,0.00556571) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.207698,-0.00766046) , 
1, 1.07941, 0, 0, 0.35217,-0.0121118) , 
0, 0.164179, 0, 0, 0.505848,0.0507929)    );
  // itree = 54
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.862682,0.00553634) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62863,0.0037194) , 
0, 0.98377, 0, 0, 0.788743,0.166384) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.730403,0.00599573) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.22525,-0.00571181) , 
1, 1.20651, 0, 0, 0.334386,-0.0221271) , 
0, 0.18408, 0, 0, 0.499891,0.0465405)    );
  // itree = 55
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856715,0.00536416) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493824,0.00362489) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.346728,-0.000230221) , 
0, 0.171253, 0, 0, 0.362138,0.000801998) , 
0, 0.930348, 0, 0, 0.496337,0.0470217)    );
  // itree = 56
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.856612,0.00544171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.576109,0.00378296) , 
0, 0.987303, 0, 0, 0.770288,0.145286) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.637791,0.00480432) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.16901,-0.0126809) , 
1, 0.833124, 0, 0, 0.359588,-0.00127221) , 
0, 0.149254, 0, 0, 0.502316,0.04966)    );
  // itree = 57
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.800843,0.00693083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.8427,0.00506836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.287927,-0.00283078) , 
0, 0.845771, 0, 0, 0.464141,0.0261591) , 
1, 1.442, 0, 0, 0.503184,0.0510461)    );
  // itree = 58
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.843668,0.00547164) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.829433,0.00449957) , 
1, 0.397257, 1, 0, 0.83657,0.157715) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.794374,0.00688881) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27112,-0.00300005) , 
1, 1.45286, 0, 0, 0.350465,-0.00561882) , 
0, 0.736318, 0, 0, 0.494698,0.0428445)    );
  // itree = 59
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.868912,0.00531162) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.709919,0.00346195) , 
0, 0.990206, 0, 0, 0.827395,0.164919) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.606425,0.00452901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.167627,-0.00968888) , 
1, 0.801673, 0, 0, 0.346834,-0.00722004) , 
0, 0.507463, 0, 0, 0.503908,0.0490448)    );
  // itree = 60
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.849056,0.00496971) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.781513,0.00626799) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.270095,-0.0028164) , 
1, 1.34548, 0, 0, 0.365691,0.00611858) , 
0, 0.855721, 0, 0, 0.502794,0.0490084)    );
  // itree = 61
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.842073,0.00485682) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.381908,0.00450122) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.357307,-1.96751e-05) , 
0, 0.0942675, 0, 0, 0.359292,0.0052183) , 
0, 0.731343, 0, 0, 0.505626,0.0513044)    );
  // itree = 62
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.853041,0.00516205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.567885,0.00358985) , 
0, 0.990547, 0, 0, 0.742041,0.132165) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.736411,0.00571899) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.228526,-0.00518278) , 
1, 1.22514, 0, 0, 0.345565,-0.0103705) , 
0, 0.0497512, 0, 0, 0.490332,0.0416741)    );
  // itree = 63
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.870803,0.00511158) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.658972,0.00303208) , 
0, 0.985604, 0, 0, 0.824769,0.150129) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.710901,0.00513672) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.216104,-0.00467352) , 
1, 1.09643, 0, 0, 0.344445,-0.00885275) , 
0, 0.517413, 0, 0, 0.500457,0.0427853)    );
  // itree = 64
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.850641,0.00500943) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446192,0.00294244) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.370343,0.000136775) , 
0, 0.0144772, 0, 0, 0.383846,0.0124796) , 
0, 0.970149, 0, 0, 0.497463,0.0448229)    );
  // itree = 65
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.871963,0.005171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.827854,0.00410262) , 
1, 0.416853, 1, 0, 0.852208,0.154982) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.370284,0.00349989) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365127,0.000100092) , 
0, 0.0322707, 0, 0, 0.365742,0.0103796) , 
0, 0.810945, 0, 0, 0.511008,0.0535601)    );
  // itree = 66
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.853654,0.00484856) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.611107,0.0043597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.218889,-0.00598795) , 
1, 0.801673, 0, 0, 0.367424,0.0067642) , 
0, 0.935323, 0, 0, 0.495096,0.0430122)    );
  // itree = 67
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.833675,0.00520427) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.809381,0.00391885) , 
1, 0.360032, 1, 0, 0.82063,0.13853) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.699883,0.004836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.208801,-0.00538315) , 
1, 1.01016, 0, 0, 0.35757,0.00383122) , 
0, 0.522388, 0, 0, 0.502724,0.0460546)    );
  // itree = 68
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.786228,0.00394985) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.763667,0.00520843) , 
1, 0.351333, 0, 0, 0.775717,0.129267) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.597849,0.00422634) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.142015,-0.0138297) , 
1, 0.737318, 0, 0, 0.356176,0.00456491) , 
0, 0.164179, 0, 0, 0.499028,0.0470255)    );
  // itree = 69
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.846876,0.00456454) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582467,0.00408651) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.188234,-0.00720494) , 
1, 0.734607, 0, 0, 0.357212,0.00542946) , 
0, 0.860696, 0, 0, 0.49523,0.042629)    );
  // itree = 70
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.867207,0.00485083) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.584701,0.00354103) , 
0, 0.995446, 0, 0, 0.759551,0.131522) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.580279,0.00401925) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.134361,-0.0140239) , 
1, 0.728287, 0, 0, 0.345666,-0.00609065) , 
0, 0.0845771, 0, 0, 0.494595,0.0434265)    );
  // itree = 71
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.863092,0.00465159) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553922,0.002993) , 
0, 0.948537, 0, 0, 0.787099,0.132983) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.575715,0.00399915) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.13481,-0.0111862) , 
1, 0.741578, 0, 0, 0.333287,-0.0119474) , 
0, 0.20398, 0, 0, 0.493259,0.0391418)    );
  // itree = 72
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86513,0.00476087) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.580229,0.00350307) , 
0, 0.99552, 0, 0, 0.762653,0.121264) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.590031,0.00400512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.161724,-0.0101805) , 
1, 0.801673, 0, 0, 0.341288,-0.00370245) , 
0, 0.0995025, 0, 0, 0.492532,0.0411529)    );
  // itree = 73
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.832403,0.00430572) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.373424,0.00425133) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.34274,0.000518763) , 
0, 0.047575, 0, 0, 0.346078,0.000602332) , 
0, 0.736318, 0, 0, 0.493794,0.038645)    );
  // itree = 74
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.789558,0.00583023) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.858311,0.00445169) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.297744,-0.00154787) , 
0, 0.935323, 0, 0, 0.463563,0.0298181) , 
1, 1.36991, 0, 0, 0.505474,0.0514288)    );
  // itree = 75
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.795706,0.00575914) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.780609,0.00419546) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266468,-0.00281253) , 
0, 0.164179, 0, 0, 0.467689,0.0302642) , 
1, 1.37134, 0, 0, 0.510725,0.0528787)    );
  // itree = 76
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.862503,0.00449667) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.550818,0.00314348) , 
0, 0.972676, 0, 0, 0.766805,0.121593) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558289,0.0038474) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.120988,-0.0142747) , 
1, 0.691768, 0, 0, 0.336229,-0.00825456) , 
0, 0.0845771, 0, 0, 0.494502,0.0394756)    );
  // itree = 77
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.855913,0.00450694) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517497,0.00304696) , 
0, 0.985522, 0, 0, 0.729552,0.107479) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.60922,0.00382654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.160339,-0.00983932) , 
1, 0.801673, 0, 0, 0.357014,0.00844463) , 
0, 0.0298507, 0, 0, 0.495248,0.0451923)    );
  // itree = 78
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.855695,0.00433423) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.379531,0.00273752) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.370353,0.000733043) , 
0, 0.013945, 0, 0, 0.371749,0.0185684) , 
0, 0.935323, 0, 0, 0.499338,0.0467268)    );
  // itree = 79
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.804888,0.00339842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.793827,0.00449867) , 
1, 0.39662, 0, 0, 0.798811,0.124821) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.755645,0.00477578) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.239421,-0.00282947) , 
1, 1.19752, 0, 0, 0.363629,0.0176408) , 
0, 0.18408, 0, 0, 0.520752,0.0563382)    );
  // itree = 80
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.755233,0.0047523) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.813629,0.00389257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.252467,-0.00217172) , 
0, 0.507463, 0, 0, 0.4594,0.028923) , 
1, 1.1929, 0, 0, 0.509309,0.0507417)    );
  // itree = 81
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.855297,0.00439049) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.664857,0.00247119) , 
0, 0.996462, 0, 0, 0.787645,0.107513) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.747938,0.00463952) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.241633,-0.0021672) , 
1, 1.20381, 0, 0, 0.358857,0.0127988) , 
0, 0.288557, 0, 0, 0.498204,0.0435789)    );
  // itree = 82
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.860848,0.00428013) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553542,0.00271263) , 
0, 0.978472, 0, 0, 0.771081,0.106482) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.759147,0.00519707) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.244097,-0.00230079) , 
1, 1.33922, 0, 0, 0.344393,0.00153333) , 
0, 0.134328, 0, 0, 0.493258,0.0381483)    );
  // itree = 83
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.865085,0.00426866) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.583288,0.00270961) , 
0, 0.987082, 0, 0, 0.778732,0.110609) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59776,0.00363024) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.146015,-0.010159) , 
1, 0.734607, 0, 0, 0.362246,0.0165396) , 
0, 0.134328, 0, 0, 0.508878,0.0496586)    );
  // itree = 84
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.812411,0.00315748) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.785794,0.004343) , 
1, 0.39662, 0, 0, 0.797962,0.126508) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557119,0.00357016) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.126669,-0.0126351) , 
1, 0.622249, 0, 0, 0.359464,0.0179359) , 
0, 0.169154, 0, 0, 0.516899,0.056917)    );
  // itree = 85
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.85204,0.00406409) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.486004,0.0011209) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.359454,0.00120019) , 
0, 0.350709, 0, 0, 0.369013,0.0164095) , 
0, 0.940298, 0, 0, 0.49638,0.0413628)    );
  // itree = 86
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.743733,0.00445495) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.737671,0.00371376) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.234471,-0.00271059) , 
0, 0.0447761, 0, 0, 0.451216,0.0243197) , 
1, 1.19435, 0, 0, 0.498889,0.0428017)    );
  // itree = 87
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.861288,0.00413593) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554513,0.00247266) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.348986,0.00093533) , 
0, 0.137906, 0, 0, 0.379122,0.0129681) , 
0, 0.99005, 0, 0, 0.493272,0.0373535)    );
  // itree = 88
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.843646,0.0036746) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.423663,0.00368299) , 
0, 0.767057, 0, 0, 0.768582,0.103921) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.76658,0.00504348) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.255887,-0.00207945) , 
1, 1.35238, 0, 0, 0.353307,0.00936862) , 
0, 0.0995025, 0, 0, 0.503034,0.0434594)    );
  // itree = 89
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.859088,0.00399844) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503306,0.00248017) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.341657,0.000861151) , 
0, 0.097024, 0, 0, 0.36488,0.00531047) , 
0, 0.975124, 0, 0, 0.489201,0.0319841)    );
  // itree = 90
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.871236,0.00398017) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.539836,0.003168) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.230533,-0.00362067) , 
1, 0.591528, 0, 0, 0.387087,0.025445) , 
0, 0.980099, 0, 0, 0.511967,0.050301)    );
  // itree = 91
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.862885,0.00385905) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.626307,0.00332629) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.21333,-0.00258396) , 
1, 0.810704, 0, 0, 0.37405,0.0111859) , 
0, 0.955224, 0, 0, 0.501031,0.0375578)    );
  // itree = 92
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.74715,0.00423669) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.729742,0.0034939) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.227457,-0.00261428) , 
0, 0.0348259, 0, 0, 0.445322,0.0134277) , 
1, 1.1929, 0, 0, 0.494438,0.0328566)    );
  // itree = 93
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.853945,0.00377298) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.477501,0.000758654) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.360463,0.0011236) , 
0, 0.348515, 0, 0, 0.368743,0.015594) , 
0, 0.935323, 0, 0, 0.49466,0.0378182)    );
  // itree = 94
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.774378,0.0025387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.732046,0.0039656) , 
1, 0.460155, 0, 0, 0.745469,0.10354) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.782686,0.00516082) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.249186,-0.00201781) , 
1, 1.4203, 0, 0, 0.344397,-0.00125047) , 
0, 0.0298507, 0, 0, 0.500952,0.0396536)    );
  // itree = 95
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.859764,0.00383449) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.682055,0.00170515) , 
0, 0.985311, 0, 0, 0.817288,0.0963832) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.794536,0.00523186) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.27995,-0.00116103) , 
1, 1.45286, 0, 0, 0.35939,0.0184357) , 
0, 0.507463, 0, 0, 0.505268,0.0432684)    );
  // itree = 96
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.853066,0.00373966) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.498627,0.00215095) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.351413,0.000832843) , 
0, 0.0723891, 0, 0, 0.372338,0.011203) , 
0, 0.970149, 0, 0, 0.490442,0.0319036)    );
  // itree = 97
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.86696,0.00375421) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544749,0.00229768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.365735,0.000772444) , 
0, 0.0882115, 0, 0, 0.392575,0.0225425) , 
0, 0.985075, 0, 0, 0.507177,0.0431649)    );
  // itree = 98
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.863088,0.00366752) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.725512,0.00393359) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277245,-0.000911815) , 
1, 1.1929, 0, 0, 0.369491,0.00927651) , 
0, 0.970149, 0, 0, 0.497252,0.0335163)    );
  // itree = 99
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.786777,0.00253796) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.767339,0.0038443) , 
1, 0.396112, 0, 0, 0.776117,0.0869948) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.584423,0.00317379) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.15407,-0.00831041) , 
1, 0.728287, 0, 0, 0.354517,0.0134676) , 
0, 0.169154, 0, 0, 0.499731,0.038793)    );
   return;
};
 
// Clean up
inline void ReadBDTGradient::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDTGradient::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
