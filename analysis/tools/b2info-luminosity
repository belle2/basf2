#!/bin/env python3
# -*- mode: Python; coding: utf-8 -*-

"""
Script to get the integrated luminosity of a set of runs

Usage:
    b2info-luminosity --exp <E> --runs <Range> --what [online|offline] --plot [DAY|WEEK|RUN] [--verbose]

"""

__author__ = "Stefano Lacaprara, Marco Milesi"
__email__ = "stefano.lacaprara@pd.infn.it, marco.milesi@unimelb.edu.au"


import argparse
import re
import sqlite3
import time
from datetime import datetime
import os
import basf2 as b2

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np



def parseNumRange(string):
    """
    Parse range of integers like xx-yy
    """
    m = re.match(r'(\d+)(?:-(\d+))?$', string)
    if not m:
        raise argparse.ArgumentTypeError("'" + string + "' is not a range of number. Expected forms like '0-5' or '2'.")
    start = m.group(1)
    end = m.group(2) or start
    return set(range(int(start, 10), int(end, 10) + 1))


def parseNumList(string):
    """
    Parse range of integers like xx-yy,zz
    """
    result = set()
    for rr in [x.strip() for x in string.split(',')]:
        result |= parseNumRange(rr)

    return sorted(list(result))


def argparser():
    """
    Parse options as command-line arguments.
    """

    description = "Script to get the integrated luminosity."

    parser = argparse.ArgumentParser(description=description, usage=__doc__, add_help=True)

    parser.add_argument("--exp",
                        dest="exp",
                        action="store",
                        type=parseNumList,
                        required=True,
                        help="Experiment numbers (required). Range allowed: eg 3,7-10")
    parser.add_argument("--runs",
                        dest="runs",
                        action="store",
                        type=parseNumList,
                        required=False,
                        default=None,
                        help="Process only the selected run range. Syntax is xx-yy,zz. Multiple ranges allowed xx-yy,zz,aa-bb")
    parser.add_argument("--what",
                        dest="what",
                        action="store",
                        type=str,
                        required=False,
                        default='offline',
                        choices=["offline","online"],
                        help="Which luminosity: offline (default) or online")
    parser.add_argument("--verbose",
                        dest="verb",
                        action="store_true",
                        default=False,
                        help="Print luminosity for each run")
    parser.add_argument("--dbonline",
                        dest="dbonlie",
                        action="store",
                        default="/gpfs/group/belle2/group/detector/ECL/ecl_lom.db",
                        help="ECL DataBase path (for developers)")
    parser.add_argument("--dboffline",
                        dest="dbofflie",
                        action="store",
                        default="/group/belle2/dataprod/Luminosity/OffLineLuminosity.db",
                        help="DataBase path for OffLine Lumi (for developers)")

    plot_actions = {
        "DAY"  : "Histogram of daily integrated luminosity",
        "WEEK" : "Histogram of weekly integrated luminosity",
        "RUN"  : "Histogram of integrated luminosity per run",
        }

    parser.add_argument("--plot",
                        dest="plot",
                        action="store",
                        nargs='+',
                        choices=list(plot_actions.keys()),
                        default=None,
                        help="Produce plot of integrated luminosity for each run, day, or week")

    return parser

class Luminosity:
    """
    class to read lumi info from DB and serve in various way
    """

    def __init__(self, args):
        """
        initializiation 

        :param args: command-line args.
        """
        self.DBonline = args.dbonlie
        self.DBoffline = args.dbofflie
        self.what=args.what
        self.conn = self.create_connection()
        self.exp=args.exp
        self.expstr="-".join(str(_) for _ in args.exp)
        self.runs=args.runs
        if len(self.exp)>1 and self.runs:
            b2.B2FATAL(f"No run range (--runs ) allowed if multiple experiments are selected (--exp {self.exp})")
        if args.plot == 'RUN' and len(self.exp)>1:
            b2.B2FATAL(f"If plotting lumi per run (--plot RUN) you can select only one experiment (--exp {self.exp})")


        self.runRangeStr="All runs"
        if self.runs:
            self.runRangeStr=f"Runs {min(self.runs)}-{max(self.runs)}"

        self.verb=args.verb

        if not self.conn:
            b2.B2FATAL(f"could not establish connection to db: {db}")

        if self.what=='offline':
            self.col_lumi = "lee"
            self.df = self.getDataFrameFromDBOffLine()
        else:
            self.col_lumi = "lum_det_shift"
            self.df = self.getDataFrameFromDBOnline()

    
        

    def create_connection(self):
        """
        Create a database connection to the SQLite database specified by the db_file.

        :param db_file: database file
        :return: Connection object or None
        """

        DB=None
        if self.what=='offline':
            DB=self.DBoffline
        else:
            DB=self.DBonline

        if not os.path.exists(DB):
            b2.B2FATAL(f"DB {DB} not found. The live luminosity is only available on KEKCC (sorry)")

        connection = None
        try:
            connection = sqlite3.connect(DB)
        except sqlite3.Error as e:
            print(e)

        return connection

    def getDataFrameFromDBOffLine(self):
        """
        create a panda dataframe from Offline DB
        """
        cmdexp = f"SELECT {self.col_lumi} as lumi, exp, run, start_time as date FROM RunLumi WHERE exp IN ({', '.join(['?' for _ in self.exp])})  "
        if args.runs:
            cmdexp += f" AND run >= {min(self.runs)} AND run <= {max(self.runs)}"

        # Get the DB as a pandas.Dataframe.
        df = pd.read_sql(cmdexp, self.conn, params=self.exp)
        df = df.sort_values(by=['date'])
        print(f"Read {len(df)} runs for experiment {self.expstr}")

        # # convert epoch to date
        df['date'] = pd.to_datetime(df['date'],unit='s')

        # lumi in /fb
        df['lumi'] *= 1E-6
        # cumulative integrated luminosity
        df['intLumi'] = df['lumi'].cumsum()

        return df

    def getDataFrameFromDBOnline(self):
        """
        create a panda dataframe from online DB
        """

        #cmdexp = f"SELECT {self.col_lumi} as lumi, run, start_time as date, end_time FROM prev_bhacnt_det_run WHERE exp = :exp "
        cmdexp = f"SELECT exp, {self.col_lumi} as lumi, run, start_time as date, end_time FROM prev_bhacnt_det_run WHERE exp IN ({', '.join(['?' for _ in self.exp])}) AND start_time > 0 "
        if args.runs:
            cmdexp += f" AND run >= {min(self.runs)} AND run <= {max(self.runs)}"

        # Get the DB as a pandas.Dataframe.
        df = pd.read_sql(cmdexp, self.conn, params=self.exp)
        df = df.sort_values(by=['date'])
        print(f"Read {len(df)} runs for experiment {self.expstr}")

        # convert epoch to date
        df['date'] = pd.to_datetime(df['date'],unit='s')

        # lumi in /fb
        df['lumi'] *= 1E-6
        # cumulative integrated luminosity
        df['intLumi'] = df['lumi'].cumsum()

        return df

    def plotLumiPerPeriod(self, period=1):
        """
        Make monitoring plots of luminosity.

        :param period: 1 for day, 2 for week (start on monday)
        """

        # Group runs by date, and store the int lumi per date as the max cumulative lumi.
        # This returns a pandas.Series object.
        srs_lumi_date = []
        if period==1: # daily
            srs_lumi_date = self.df.groupby(self.df["date"].dt.floor('d'))["lumi"].sum()
            label="Daily"
            freq='D'
            width=1.0
        if period==2: # weekly
            srs_lumi_date = self.df.groupby(self.df["date"].dt.floor('7d'))["lumi"].sum()
            label="Weekly"
            freq='7d'
            width=3.5
    
        srs_lumi_date = srs_lumi_date.asfreq(freq, fill_value=0.0)

        x = srs_lumi_date.index.values
        y = srs_lumi_date.values

        figure, ax1 = plt.subplots()

        # there must be a cleaner way to do this
        yInt = np.append(np.array([0]), np.cumsum(srs_lumi_date.values)[1:])
        
        ax1.bar(x, y, label=f"{label}", color="blue", width=width)

        ax1.set_xlabel(r"Date")
        ax1.set_ylabel(rf"Total integrated {label} luminosity [$\mathrm{{fb}}^{{-1}}$]", color="blue")
        ax1.tick_params(axis='y', labelcolor="blue")

        if period==1:
            ax1.xaxis.set_major_locator(ticker.AutoLocator())
            ax1.xaxis.set_minor_locator(ticker.MultipleLocator(1))
        if period==2:
            ax1.xaxis.set_major_locator(ticker.AutoLocator())
            ax1.xaxis.set_minor_locator(ticker.AutoLocator())
        ax1.tick_params(axis="x", labelrotation=45, labelsize="small", length=8)

        # plot integrate lumi
        ax2 = ax1.twinx()
        ax2.set_ylabel(r"Total integrated luminosity [$\mathrm{fb}^{-1}$]", color="red")
        ax2.tick_params(axis='y', labelcolor="red")
        ax2.plot(x, yInt, color="red", label="Total",lw=3)
        if period==1:
            ax2.xaxis.set_major_locator(ticker.AutoLocator())
            ax2.xaxis.set_minor_locator(ticker.MultipleLocator(1))
        if period==2:
            ax2.xaxis.set_major_locator(ticker.AutoLocator())
            ax2.xaxis.set_minor_locator(ticker.MultipleLocator(7))
        ax2.set_ylim(bottom=0)

        h1, l1 = ax1.get_legend_handles_labels()
        h2, l2 = ax2.get_legend_handles_labels()

        # addtext=rf"Total $\int\mathcal{{L}}dt = {self.df['intLumi'].max():.2f}\ [\mathrm{{fb}}^{{-1}}]$"
        # h1.append(mpatches.Patch(color='none', label=addtext))

        ax2.legend(h1+h2, l1+l2, loc="upper left",title=r"Integrated luminosity [$\mathrm{fb}^{-1}$]")

        # Text box. Use axis coords.
        plt.text(0., 1.03, rf"Belle II {self.what.title()} luminosity", transform=ax1.transAxes, fontsize=12)
        plt.text(.5, 1.03, rf"Exp: {self.expstr} - {self.runRangeStr}", transform=ax1.transAxes, fontsize=12)

        props = dict(boxstyle='square', facecolor='white', alpha=0.8, edgecolor='None')
        plt.text(.02, 0.7, rf"Total $\int\mathcal{{L}}dt\  = {self.df['intLumi'].max():.2f}\ [\mathrm{{fb}}^{{-1}}]$", transform=ax1.transAxes, fontsize=12, bbox=props)
        plt.text(1, -0.25, f"Plot on {datetime.now().strftime('%Y/%m/%d %H:%M %Z')}", transform=ax1.transAxes, fontsize=6, ha="right")

        filename=f"Lumi{self.what.title()}_{label}_Exp{self.expstr}"
        if self.runs:
            filename+=f"_RunRange{min(self.runs)}-{max(self.runs)}"
        print(f"Creating {filename}.pdf|png files")
        for fileformat in ['pdf','png']:
            plt.savefig(f"{filename}.{fileformat}", bbox_inches="tight", dpi=150)

    def plotLumiPerRun(self):
        """
        Make lumi plot per run
        """

        # create a reduced dataframe with only runs selected
        # these are the runs to be selected
        if (self.runs):
            dfRuns=self.df[self.df['run'].isin(self.runs)].copy()
            dfRuns['intLumi'] = dfRuns['lumi'].cumsum()
        else:
            dfRuns=self.df

        figure, ax1 = plt.subplots()

        ax1.bar(dfRuns['run'], dfRuns['lumi'], label=f"Run by run", color="blue", width=1.0)
        ax1.set_xlabel(r"Run")
        ax1.set_ylabel(rf"Total integrated luminosity by run [$\mathrm{{fb}}^{{-1}}$]", color="blue")
        ax1.tick_params(axis='y', labelcolor="blue")
        ax1.tick_params(axis="x", labelrotation=45, labelsize="small", length=8)
        ax1.set_xlim(left=dfRuns['run'].min())
        ax1.xaxis.set_major_locator(ticker.LinearLocator(numticks=10))

        # plot integrate lumi
        ax2 = ax1.twinx()
        ax2.set_ylabel(r"Total integrated luminosity [$\mathrm{fb}^{-1}$]", color="red")
        ax2.set_ylim(bottom=0,top=dfRuns['intLumi'].max()*1.2)
        ax2.tick_params(axis='y', labelcolor="red")
        ax2.xaxis.set_major_locator(ticker.LinearLocator(numticks=10))
        ax2.plot(dfRuns['run'], dfRuns['intLumi'], color="red", label="Total")

        h1, l1 = ax1.get_legend_handles_labels()
        h2, l2 = ax2.get_legend_handles_labels()
        ax2.legend(h1+h2, l1+l2, loc=2, title=r"Integrated luminosity [$\mathrm{fb}^{-1}$]")

        # Text box. Use axis coords.
        plt.text(0., 1.03, rf"Belle II {self.what.title()} luminosity", transform=ax1.transAxes, fontsize=12)
        plt.text(.5, 1.03, rf"Exp: {self.expstr} - {self.runRangeStr}", transform=ax1.transAxes, fontsize=12)

        props = dict(boxstyle='square', facecolor='white', alpha=0.8, edgecolor='None')
        plt.text(.02, 0.7, rf"Total $\int\mathcal{{L}}dt\  = {self.df['intLumi'].max():.2f}\ [\mathrm{{fb}}^{{-1}}]$", transform=ax1.transAxes, fontsize=12, bbox=props)
        plt.text(1, -0.25, f"Plot on {datetime.now().strftime('%Y/%m/%d %H:%M %Z')}", transform=ax1.transAxes, fontsize=6, ha="right")

        filename=f"Lumi{self.what.title()}PerRun_Exp{self.expstr}"
        if self.runs:
            filename+=f"_RunRange{min(self.runs)}-{max(self.runs)}"
        print(f"Creating {filename}.pdf|png files")
        for fileformat in ['pdf','png']:
            plt.savefig(f"{filename}.{fileformat}", bbox_inches="tight")

    def printLumi(self):
        """
        print luminosity for runs and total
        """
        # these are the runs to be selected
        if (self.runs):
            dfRuns=self.df[self.df['run'].isin(self.runs)].copy()
            dfRuns['intLumi'] = dfRuns['lumi'].cumsum()
        else:
            dfRuns=self.df
        # create a reduced dataframe with only runs selected

        cols=['exp','run','lumi','date','intLumi']
        if (self.verb):
            print('-' * 61)
            print('-' * 20,f"{self.what} Luminosity",'-'*20)
            print('-' * 61)
            print(dfRuns[cols]
                .to_string(index=False,
                    formatters={
                    "exp" : "{:3d}".format,
                    "run" : "{:5d}".format,
                    "lumi" : "{:,.2f}".format,
                    "data" : "".format,
                    "intLumi" : "{:,.2f}".format,
                    }
                                ))
            print('-' * 61)
        L=dfRuns['lumi'].sum()
        print(f"TOTAL {self.what}   : L = {L*1E6:8.2f} /nb = {L*1E3:8.2f} /pb = {L:8.3f} /fb = {L/1E3:8.4f} /ab")
        
        pass


if __name__ == '__main__':

    from pandas.plotting import register_matplotlib_converters
    register_matplotlib_converters()

    args = argparser().parse_args()
    
    lumi=Luminosity(args)

    lumi.printLumi()


    if args.plot:

        if 'DAY' in args.plot:
            lumi.plotLumiPerPeriod(1)
        if 'WEEK' in args.plot:
            lumi.plotLumiPerPeriod(2)
        if 'RUN' in args.plot:
            lumi.plotLumiPerRun()
