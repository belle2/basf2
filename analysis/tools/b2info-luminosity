#!/bin/env python3

##########################################################################
# basf2 (Belle II Analysis Software Framework)                           #
# Author: The Belle II Collaboration                                     #
#                                                                        #
# See git log for contributors and copyright holders.                    #
# This file is licensed under LGPL-3.0, see LICENSE.md.                  #
##########################################################################

"""
Script to get the integrated luminosity of a set of runs
"""

import argparse
import getpass
import re
import sqlite3
import time
from datetime import datetime
import os
import basf2 as b2

import pandas as pd
import numpy as np

import requests


def parseNumRange(string):
    """
    Parse range of integers like xx-yy
    """
    m = re.match(r'(\d+)(?:-(\d+))?$', string)
    if not m:
        raise argparse.ArgumentTypeError("'" + string + "' is not a range of number. Expected forms like '0-5' or '2'.")
    start = m.group(1)
    end = m.group(2) or start
    return set(range(int(start, 10), int(end, 10) + 1))


def parseNumList(string):
    """
    Parse range of integers like xx-yy,zz
    """
    result = set()
    for rr in [x.strip() for x in string.split(',')]:
        result |= parseNumRange(rr)

    return sorted(list(result))

def fill_zeros_with_last(arr):
    """
    fill the zeros and nan of an array with previous non zero value
    """
    prev = np.arange(len(arr))
    prev[arr == 0] = 0
    prev[arr == np.nan] = 0
    prev = np.maximum.accumulate(prev)
    return arr[prev]


def argparser():
    """
    Parse options as command-line arguments.
    """

    description = "Script to get the integrated luminosity."

    parser = argparse.ArgumentParser(description=description, usage=__doc__, add_help=True)

    parser.add_argument("--exp",
                        dest="exp",
                        action="store",
                        type=parseNumList,
                        required=True,
                        help="Experiment numbers (required). Range allowed: eg 3,7-10")
    parser.add_argument("--runs",
                        dest="runs",
                        action="store",
                        type=parseNumList,
                        required=False,
                        default=None,
                        help="Process only the selected run range. Syntax is xx-yy,zz. Multiple ranges allowed xx-yy,zz,aa-bb")
    parser.add_argument("--what",
                        dest="what",
                        action="store",
                        type=str,
                        required=False,
                        default='online',
                        choices=["offline","online"],
                        help="Which luminosity: online (default) or offline")
    parser.add_argument("--verbose",
                        dest="verb",
                        action="store_true",
                        default=False,
                        help="Print luminosity for each run")
    parser.add_argument("--delivered",
                        dest="delivered",
                        action="store_true",
                        default=False,
                        help="Show also delivered lumi")
    parser.add_argument("--good",
                        dest="good",
                        action="store_true",
                        default=False,
                        help="Consider only good and recoverable runs (default False)")
    parser.add_argument("--beam-energy",
                        dest="beam_energy",
                        action="store",
                        choices=[None, '4S','4S_offres','4S_scan'],
                        default=None,
                        help="Consider only runs with given beam energy None(default)/4S/4S_offres/4S_scan")
    parser.add_argument("--dbonline",
                        dest="dbonline",
                        action="store",
                        default="/group/belle2/dataprod/Luminosity/ecl_lom.db",
                        help="ECL DataBase path (for developers)")
    parser.add_argument("--dboffline",
                        dest="dbofflie",
                        action="store",
                        default="/group/belle2/dataprod/Luminosity/OffLineLuminosity.db",
                        help="DataBase path for OffLine Lumi (for developers)")
    parser.add_argument("--token",
                        dest="token",
                        type=str,
                        required=False,
                        help="Use the read-only token to automatize the script")
    parser.add_argument("--username",
                        dest="username",
                        type=str,
                        required=False,
                        help="Provide DESY username for crediantial access")

    return parser

class Luminosity:
    """
    class to read lumi info from DB and serve in various way
    """

    def __init__(self, args):
        """
        initialization 

        :param args: command-line args.
        """
        self.DBonline = args.dbonline
        self.DBoffline = args.dbofflie
        self.Token = args.token
        self.Username = args.username
        self.what=args.what

        self.URL = "https://rundb.belle2.org"
        self.session = requests.Session()
        if self.Token is None:
            # If no specific username use the local system username or provide one to authenticate
            b2.B2INFO(f"Please provide your DESY credentials to access the rundb.")
            if self.Username is None:
                localUsername = getpass.getuser()
                self.Username=input(f"DESY username (return for {localUsername}) : ") or localUsername
            self.session.auth = (self.Username, getpass.getpass("DESY password: "))
        else:
            # Otherwise use the api key
            self.session.headers.update({'Authorization': f'Bearer {self.Token}'})
        
        self.exp = args.exp
        self.expstr = f"{min(args.exp)}"
        if min(args.exp) != max(args.exp):
            self.expstr = f"{min(args.exp)}-{max(args.exp)}"

        self.runs=args.runs
        if len(self.exp)>1 and self.runs:
            b2.B2FATAL(f"No run range (--runs ) allowed if multiple experiments are selected (--exp {self.exp})")
        self.runRangeStr = "All runs"
        if self.runs:
            self.runRangeStr=f"Runs {min(self.runs)}-{max(self.runs)}"

        self.verb = args.verb
        self.delivered = args.delivered

        # Fill df with data
        self.df = self.getDataFrame(self.exp)

        nAllRuns = len(self.df)
        if (args.good):
            self.df = self.df[self.df['quality']]
            b2.B2INFO(f"Selecting good runs: Good/Total: {len(self.df)}/{nAllRuns}")
        else:
            b2.B2INFO(f"No Selection on good runs (use --good)")

        self.beam_energy = args.beam_energy
        if (args.beam_energy):
            self.df = self.df[self.df['beam_energy']==args.beam_energy]
            b2.B2INFO(f"Selecting beam-energy {args.beam_energy}/Total= {len(self.df)}/{nAllRuns}")
        else:
            b2.B2INFO(f"No Selection on beam-energy (use --beam-energy XX)")

    def create_connection(self, what):
        """
        Create a database connection to the SQLite database specified by the db_file.

        :param db_file: database file
        :return: Connection object or None
        """

        DB=None
        if what=='offline':
            DB=self.DBoffline
        elif what=='online':
            DB=self.DBonline

        if not os.path.exists(DB):
            b2.B2FATAL(f"DB {DB} not found. The live luminosity is only available on KEKCC (sorry)")

        connection = None
        try:
            connection = sqlite3.connect(DB, uri=True)
        except sqlite3.Error as e:
            b2.B2FATAL(f"Cannot conntect to sql DB {DB}: {e}")

        return connection

    def getDataFrameFromDBOffLine(self):
        """
        create a panda dataframe from Offline DB
        """
        cmdexp = f"SELECT lee as lumi, exp, run, start_time as date, s as beam_energy FROM RunLumi WHERE exp IN ({', '.join(['?' for _ in self.exp])})  "
        if args.runs:
            cmdexp += f" AND run >= {min(self.runs)} AND run <= {max(self.runs)}"

        # Get the DB as a pandas.Dataframe.
        df = pd.read_sql(cmdexp, self.conn, params=self.exp)
        df = df.sort_values(by=['date'])
        b2.B2INFO(f"Read {len(df)} runs for experiment {self.expstr}")

        # lumi in /fb
        df['lumi'] *= 1E-6

        # cumulative integrated luminosity
        df['intLumi'] = df['lumi'].cumsum()

        df['intLumiDel']= None

        # No way to get run quality for old experiment
        df["quality"] = True

        return df

    def getDataFrameFromDBOnline(self, exp):
        """
        create a panda dataframe from online DB
        """

        cmdexp = f"SELECT exp, lum_det_shift as lumi, run, start_time as date, end_time FROM prev_bhacnt_det_run WHERE exp IN ({', '.join(['?' for _ in exp])}) AND start_time > 0 "
        if args.runs:
            cmdexp += f" AND run >= {min(self.runs)} AND run <= {max(self.runs)}"

        # Get the DB as a pandas.Dataframe.
        df = pd.read_sql(cmdexp, self.conn, params=exp)
        df = df.sort_values(by=['date'])

        # lumi in /fb
        df['lumi'] *= 1E-6
        b2.B2INFO(f"Read {len(df)} runs for experiment {exp}")

        return df

    def pagination(self, request):
        """Deal with api pagination of an initial request to the api.

        It will return all the objects from all pages lazily requesting new pages
        as objects are consumed. Will work for all list requests to the server

        Parameters:
            request (requests.Request): A get request to paginate through the results
        """
        while True:
            # check the return value and raise exception on error
            request.raise_for_status()
            # and otherwise get the json
            result = request.json()
            # and return the objects one by one by yielding objects from the list
            # of results
            yield from result['results']
            # check if there's a next page, if not done
            if result['next'] is None:
                break
            # otherwise continue with the next page
            # yees, global variable ... should be a class ... whatever
            request = self.session.get(result['next'])

    def get_run_info(self, **search_params):
        """Return the run information from the run registry"""
        try:
            req = self.session.get(f'{self.URL}/rest/v1/runs/', params=search_params)
            req.raise_for_status()
        except requests.exceptions.RequestException as e:  # This is the correct syntax
            b2.B2FATAL(f"Cannot access to RunDB. {e}")

        return self.pagination(req)

    def getDataFrameFromRunRegistry(self, exp, runs=None):
        """Return a dataframe with the luminosity information form run registry"""
        import json
        import getpass
        import dateutil.parser
           
        # temporary hack to get exp 7 and 8 from online DB
        columns=["exp", "run", "date", "date_stop", "lumi","intLumi","intLumiDel", "quality","beam_energy"]
        df=pd.DataFrame(columns=columns)
        rows=[]

        b2.B2INFO(f"Reading exp {exp} from rundb (this can take a while depending on the size of the query)")
        
        run_params = dict()
        run_params['min_experiment'] = exp
        run_params['max_experiment'] = exp
        run_params['run_type'] = "physics"
        run_params['expand'] = True

        det = ["pxd", "svd", "cdc", "top", "ari", "ecl", "klm", "trg"],


        if runs:
            run_params['min_run'] = np.min(runs)
            run_params['max_run'] = np.max(runs)

        for run in self.get_run_info(**run_params):
            if (run in runs):
                continue
            if not run['time_stop']:
                run['time_stop']=run['time_start']
            row={"exp":run['experiment'],
                 "run":run['run'],
                 "date":int(dateutil.parser.parse(run['time_start']).timestamp()),
                 "date_stop":int(dateutil.parser.parse(run['time_stop']).timestamp()),
                 "lumi":run['statistics']['lumi_recorded'],
                 }
            if(run['statistics']['lumi_exp_delivered']):
                row['intLumiDel']=run['statistics']['lumi_exp_delivered']
            else:
                row['intLumiDel']=None
            
            # Quality
            qualityShift = not any(expQ == "BAD" for expQ in run['quality_shifter'].values())
            quality = not any(expQ == "BAD" for expQ in run['quality_expert'].values())
            noEvents = not any(expQ == "NO EVENTS" for expQ in run['quality_expert'].values())
            
            row["quality"] = quality & noEvents

            # beam energy
            beam_energy = "4S"
            try:
                if run["ler"]["momentum"] >= 4.0 and run["her"]["momentum"] >= 7.0:
                    beam_energy = "4S"
                else:
                    beam_energy = "4S_offres"
            except:
                b2.B2WARNING(f"Beam energy not set in RunDB for exp/run {run['experiment']}/{run['run']}. Assuming 4S")
            row["beam_energy"] = beam_energy

            rows.append(row)

        df = pd.DataFrame(rows,columns=columns)
        b2.B2INFO(f"Read {len(df)} runs from exp {exp}")

        # lumi in /fb
        df['lumi'] *= 1E-6
        df['intLumiDel'] *= 1E-6
        #df.fillna(0)

        return df

    def fixDeliveredLumi(self, df, exp_rr):
        """
        fix the delivered luminosity if multiple experiments are requested, as it is reset to null at the experiment change
        """
        cumulativeLumi = 0
        for exp in exp_rr:
            b2.B2INFO(f"Fixing delivered Lumi for exp {exp}")
            df['intLumiDel'].loc[df['exp'] == exp] += cumulativeLumi
            cumulativeLumi = df[df['exp']==exp]['intLumiDel'].max()
        return df

    def getDataFrame(self, expreq):
        """ get pandas dataframe for a set of experiment, taking into account the source: DB or RR """

        # Load from cache if any

        df = pd.DataFrame(columns=["exp", "run", "date", "date_stop", "lumi", "intLumi", "intLumiDel"])

        # this is not working yet.
        # try:
        #     df = pd.read_csv("luminosity.csv")
        # except:
        #     print("empty cache")
        #     pass
    
    
        allrunsCache = dict()
        for exp in args.exp:
            try:
                allrunsCache[exp] = df.groupby(['exp'])['run'].apply(list).loc[exp]
            except:
                pass

        # get list of all runs in RunDB for the range required.
        allruns = dict()

        # if run range is defined, use it.
        if self.runs:
            for exp in args.exp:
                allruns[exp] = self.runs
        else:
            for exp in args.exp:
                allruns[exp] = []
                for info in self.get_run_info(min_experiment=exp, max_experiment=exp,  run_type='physics'):
                    allruns[exp].append(info.get('run'))
            
        new_runs = dict()
        for exp in args.exp:
            if exp not in allrunsCache.keys():
                new_runs[exp] = sorted(allruns[exp])
            else:
                new_runs[exp] = sorted(list(set(allruns[exp]).difference(allrunsCache[exp])))
            
        expTBU = [exp for exp,value in new_runs.items() if value != [] ]

        # see if some is missing from cache
        if all(x == [] for x in new_runs.values()):
            b2.B2INFO("No new runs wrt to cache")

            # need to fix delivered lumi for al exp newer than the first one updated
            if len(expTBU)>0:
                firstRunTBU = expTBU[0]
                exp_rr = [exp for exp,value in new_runs.items() if exp > expTBU[0] ]
                if len(exp_rr)>1:
                    df = self.fixDeliveredLumi(df, exp_rr)
        else:

            # which exp have runs not in cache
            b2.B2INFO(f"Need to get some runs from RunDB for exp {expTBU}")

            if self.what=='online':
                # temporary hack to get exp 7 and 8 from online DB
                if expTBU[0]<9:
                    # need to 
                    self.conn = self.create_connection(self.what)
                    if not self.conn:
                        b2.B2FATAL(f"could not establish connection to db: {db}")
                if 7  in expTBU:
                    df=df.append(self.getDataFrameFromDBOnline([7]), sort=False, ignore_index=True)
                if 8  in expTBU:
                    df=df.append(self.getDataFrameFromDBOnline([8]), sort=False, ignore_index=True)
                # experiment >10
                exp_rr= [e for e in expTBU if e>9]
                for exp in exp_rr:
                    df=df.append(self.getDataFrameFromRunRegistry(exp, new_runs[exp]), sort=False, ignore_index=True)

                # in case of multiple experiment, need to fix the delivered lumi as it is reste to 0 at the exp change.
                if len(exp_rr)>1:
                    df = self.fixDeliveredLumi(df, exp_rr)
                
                # cumulative integrated luminosity
                df = df.sort_values(by=['exp','run'])

                df['intLumi'] = df['lumi'].cumsum()
                df['lumiDel'] = df['intLumiDel'].diff()
            else:
                self.conn = self.create_connection(self.what)
                df=pd.DataFrame(columns=["exp", "run", "date", "date_stop", "lumi", "intLumi", "intLumiDel"])
                df=df.append(self.getDataFrameFromDBOffLine(),sort=False)
                df['intLumi'] = df['lumi'].cumsum()
                df['lumiDel'] = np.nan

        if len(df)==0:
            b2.B2FATAL(f"No runs found in exp {self.exp} for range {self.runRangeStr}")


        #store luminosity values for each run in a .csv file
        df.sort_values(by=['exp','run']).to_csv("luminosity.csv", index=False)

        # # select only the requested experiments
        # intLumiPrevoiousExp = df[~df['exp'].isin(args.exp)]['intLumi'].max()

        # df = df[df['exp'].isin(args.exp)]

        # fix integreated lumi considering only requested exp
        
        # df['intLumi'] -= intLumiPrevoiousExp

        return df

    def printLumi(self):
        """
        print luminosity for runs and total
        """
        # these are the runs to be selected
        if (self.runs):
            dfRuns=self.df[self.df['run'].isin(self.runs)].copy()
        else:
            dfRuns=self.df
        # create a reduced dataframe with only runs selected

        cols=['exp','run','lumi','date','length','intLumi','intLumiDel','quality','beam_energy']
        dfRuns['length'] = dfRuns['date_stop'] - dfRuns['date']
        dfRuns['date'].fillna(pd.Timedelta(seconds=0))
        dfRuns = dfRuns[dfRuns['date']>0]
        if (self.verb):
            print('-' * 100)
            print('-' * 40,f"{self.what} Luminosity",'-'*41)
            print('-' * 100)
            print(dfRuns[cols]
                .to_string(index=False,
                    col_space=3,
                    header=['Exp','Run','Lumi [/pb]','date','length','int Lumi [/fb]','int Lumi Delivered [/fb]',"Good","Beam Energy"],
                    formatters={
                    "exp" : "{:3d}".format,
                    "run" : "{:5d}".format,
                    "lumi" : lambda x: "{:,.3f}".format(x*1000),
                    "date" : lambda x: "{:%Y/%m/%d %H:%M}".format(pd.to_datetime(x, unit='s')),
                    "length" : lambda x: "{:%H:%M}".format(pd.to_datetime(x, unit='s')),
                    "intLumi" : "{:,.3f}".format,
                    "intLumiDel" : "{:,.3f}".format,
                    "good" : "{:5s}".format,
                    "beam_energy" : "{:8s}".format,
                    }
                                ))
            print('-' * 100)

        b2.B2INFO(f"Num runs: {len(dfRuns)}")

        LL = dfRuns.groupby(["beam_energy"])['lumi'].sum()
        for i,L in LL.items():
            b2.B2INFO(f"RECORDED {self.what} {i:9s} : L = {L*1E6:12.2f} /nb = {L*1E3:8.2f} /pb = {L:8.3f} /fb = {L/1E3:8.4f} /ab")
        L=dfRuns['lumi'].sum()
        b2.B2INFO(f"RECORDED {self.what} Total     : L = {L*1E6:12.2f} /nb = {L*1E3:8.2f} /pb = {L:8.3f} /fb = {L/1E3:8.4f} /ab")
    
        if self.what=='online' and self.delivered:
            Ld=dfRuns['lumiDel'].sum()
            b2.B2INFO(f"DELIVERED {self.what}   : L = {Ld*1E6:12.2f} /nb = {Ld*1E3:8.2f} /pb = {Ld:8.3f} /fb = {Ld/1E3:8.4f} /ab")
        
        #store luminosity values for each run in a .csv file
        dfRuns.to_csv("dfruns.csv")

        pass


if __name__ == '__main__':

    args = argparser().parse_args()
    
    lumi = Luminosity(args)

    lumi.printLumi()
