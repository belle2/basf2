#!/bin/env python3
# -*- mode: Python; coding: utf-8 -*-

"""
Script to get the integrated luminosity of a set of runs

Based on a bash script by Mikhail Remnev mikhail.remnev@desy.de
https://confluence.desy.de/display/BI/ECL+LM+Integrated+luminosity+in+Phase+3

Usage:
    b2info-luminosity-online --exp <E> --runs <Range> [--verbose] [--db db_path]

<E> experiment number (mandatory)
<Range> run range (mandatory)
    syntax is: xx-yy,zz
    all runs between xx and yy (included) and run zz. Can have multiple ranges xx-yy,zz-ww
--verbose print lumi for each run
--db path of database to use

"""

__author__ = "Stefano Lacaprara, Marco Milesi"
__email__ = "stefano.lacaprara@pd.infn.it, marco.milesi@unimelb.edu.au"


import argparse
import re
import sqlite3
import time
import os
import basf2 as b2

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np


def parseNumRange(string):
    """
    Parse range of integers like xx-yy
    """
    m = re.match(r'(\d+)(?:-(\d+))?$', string)
    if not m:
        raise argparse.ArgumentTypeError("'" + string + "' is not a range of number. Expected forms like '0-5' or '2'.")
    start = m.group(1)
    end = m.group(2) or start
    return set(range(int(start, 10), int(end, 10) + 1))


def parseNumList(string):
    """
    Parse range of integers like xx-yy,zz
    """
    result = set()
    for rr in [x.strip() for x in string.split(',')]:
        result |= parseNumRange(rr)

    return list(result)


def argparser():
    """
    Parse options as command-line arguments.
    """

    description = "Script to get the online integrated luminosity for a range or runs."

    parser = argparse.ArgumentParser(description=description, usage=__doc__, add_help=True)

    parser.add_argument("--exp",
                        dest="exp",
                        action="store",
                        type=int,
                        required=True,
                        help="Experiment number")
    parser.add_argument("--runs",
                        dest="runs",
                        action="store",
                        type=parseNumList,
                        required=False,
                        default=None,
                        help="Process only the selected run range. Syntax is xx-yy,zz")
    parser.add_argument("--verbose",
                        dest="verb",
                        action="store_true",
                        default=False,
                        help="Print each run luminosity")
    parser.add_argument("--db",
                        dest="db",
                        action="store",
                        default="/gpfs/group/belle2/group/detector/ECL/ecl_lom.db",
                        help="EC: DataBase path")

    plot_actions = {
        "DATE" : "Histogram of integrated luminosity per date",
        "RUN"  : "Histogram of integrated luminosity per run",
        "TOT"  : "Graph of total integrated luminosity vs. date",
        }

    parser.add_argument("--plot",
                        dest="plot",
                        action="store",
                        choices=list(plot_actions.keys()),
                        default=None,
                        help="")

    return parser

class luminosity:
    """
    class to read lumi info from DB and serve in various way
    """

    def __init__(self, args):
        """
        initializiation 

        :param args: command-line args.
        """
        self.DB = args.db
        self.conn = self.create_connection()
        self.exp=args.exp
        self.runs=args.runs
        self.verb=args.verb

        if not self.conn:
            b2.b2fatal(f"could not establish connection to db: {db}")

        self.col_lumi = "lum_det_shift"

        self.df = self.getDataFrameFromDB()
    
        

    def create_connection(self):
        """
        Create a database connection to the SQLite database specified by the db_file.

        :param db_file: database file
        :return: Connection object or None
        """

        if not os.path.exists(self.DB):
            b2.B2FATAL(f"DB {self.DB} not found. The live luminosity is only available on KEKCC (sorry)")

        connection = None
        try:
            connection = sqlite3.connect(self.DB)
        except sqlite3.Error as e:
            print(e)

        return connection

    def getDataFrameFromDB(self):
        """
        crete a panda dataframe from DB
        """

        cmdexp = f"SELECT {self.col_lumi} as lumi, run, start_time as date, end_time FROM prev_bhacnt_det_run WHERE exp = :exp "
        if args.runs:
            cmdexp += f" AND run >= {min(self.runs)} AND run <= {max(self.runs)}"

        # Get the DB as a pandas.Dataframe.
        df = pd.read_sql_query(cmdexp, self.conn, params=(self.exp,))
        print(f"Read {len(df)} runs for experiment {self.exp}")

        # convert epoch to date
        df['date'] = pd.to_datetime(df['date'],unit='s')

        # cumulative integrated luminosity
        df['intLumi'] = df['lumi'].cumsum()

        return df

    def plotLumi(self, period=1):
        """
        Make monitoring plots of luminosity.

        :param period: 1 for day, 2 for week (start on monday)
        """

        # RUN max, min
        run_min = self.df["run"].min()
        run_max = self.df["run"].max()

        # Group runs by date, and store the int lumi per date as the max cumulative lumi.
        # This returns a pandas.Series object.
        srs_lumi_date = []
        if period==1: # per day
            srs_lumi_date = self.df.groupby(self.df["date"].dt.strftime('%Y/%m/%d'))["lumi"].sum()*1.E-6 # in /fb
            label="Day"
        if period==2: # per week
            # not working yet
            srs_lumi_date = self.df.groupby(self.df["date", pd.Grouper(key='Date', freq='W-MON')])["lumi"].sum()*1.E-6 # in /fb
            label="Week"

        figure, ax1 = plt.subplots()

        x = srs_lumi_date.index.values
        x[0] = x[1] # groupby insert first date as eopch 0
        y = srs_lumi_date.values

        # there must be a cleanerr way to do this
        yInt = np.append(np.array([0]), np.cumsum(srs_lumi_date.values)[:-1])
        
        ax1.bar(x, y, label=f"{label} per {label}", color="blue")

        ax1.set_xlabel(r"Date")
        ax1.set_ylabel(rf"Total integrated luminosity per {label} [$\mathrm{{fb}}^{{-1}}$]", color="blue")
        ax1.tick_params(axis='y', labelcolor="blue")

        ax1.tick_params(axis="x", labelrotation=45, labelsize="small")
        ax1.xaxis.set_major_locator(ticker.AutoLocator())
        ax1.xaxis.set_minor_locator(ticker.MultipleLocator(1))

        # plot integrate lumi
        ax2 = ax1.twinx()
        ax2.set_ylabel(r"Total integrated luminosity [$\mathrm{fb}^{-1}$]", color="red")
        ax2.tick_params(axis='y', labelcolor="red")
        full = ax2.plot(x, yInt, color="red", label="Total")
        ax2.xaxis.set_major_locator(ticker.AutoLocator())
        ax2.xaxis.set_minor_locator(ticker.MultipleLocator(1))

        h1, l1 = ax1.get_legend_handles_labels()
        h2, l2 = ax2.get_legend_handles_labels()
        ax2.legend(h1+h2, l1+l2,loc="best",title=r"Integrated luminosity [$\mathrm{fb}^{-1}$]")

        # Text box. Use axis coords.
        plt.text(0., 1.03, rf"Belle II online luminosity", transform=ax1.transAxes, fontsize=12)
        plt.text(.5, 1.03, rf"Exp: {self.exp} - Runs {run_min}-{run_max}", transform=ax1.transAxes, fontsize=12)
        plt.text(.02, 0.7, rf"Total $\int\ \mathcal{{L}}\ dt\  = {self.df['intLumi'].max()/1.e6:.2f}\ [\mathrm{{fb}}^{{-1}}]$", transform=ax1.transAxes, fontsize=14)

        plt.savefig(f"LumiPer{label}_Exp{self.exp}.pdf", bbox_inches="tight")
        plt.savefig(f"LumiPer{label}_Exp{self.exp}.png", bbox_inches="tight")

    def plotLumiPerRun(self):
        """
        Make lumi plot per run
        """
        pass

    def printLumi(self):
        """
        print luminosity for runs and total
        """
        # these are the runs to be selected
        if (self.runs):
            dfRuns=self.df[self.df['run'].isin(self.runs)]
            dfRuns['intLumi'] = dfRuns['lumi'].cumsum()
        else:
            dfRuns=self.df
        # create a reduced dataframe with only runs selected

        cols=['run','lumi','date','intLumi']
        if (self.verb):
            print('-' * 61)
            print(dfRuns[cols]
                .to_string(index=False,
                    formatters={"run" : "{:5d}".format,
                    "lumi" : "{:,.2f}".format,
                    "data" : "".format,
                    "intLumi" : "{:,.2f}".format,
                    }
                                ))
            print('-' * 61)
        L=dfRuns['lumi'].sum()
        print(f"TOTAL    : L = {L:8.2f} /nb = {L/1E3:8.2f} /pb = {L/1E6:8.3f} /fb = {L/1E9:8.4f} /ab")
        
        pass


if __name__ == '__main__':

    args = argparser().parse_args()
    
    lumi=luminosity(args)

    lumi.printLumi()

    if args.plot:
        if "DATE" in args.plot():
            lumi.plotLumi(1)
            #lumi.plotLumi(2)
        if "RUN" in args.plot():
            lumi.plotLumiPerRun(1)
