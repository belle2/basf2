#!/bin/env python3
# -*- mode: Python; coding: utf-8 -*-

"""
Script to get the integrated luminosity of a set of runs

Based on a bash script by Mikhail Remnev mikhail.remnev@desy.de
https://confluence.desy.de/display/BI/ECL+LM+Integrated+luminosity+in+Phase+3

Usage:
    b2info-luminosity-online --exp <E> --runs <Range> [--verbose] [--db db_path]

<E> experiment number (mandatory)
<Range> run range (mandatory)
    syntax is: xx-yy,zz
    all runs between xx and yy (included) and run zz. Can have multiple ranges xx-yy,zz-ww
--verbose print lumi for each run
--db path of database to use

"""

__author__ = "Stefano Lacaprara, Marco Milesi"
__email__ = "stefano.lacaprara@pd.infn.it, marco.milesi@unimelb.edu.au"


import argparse
import re
import sqlite3
import time
import os
import basf2 as b2

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker
import numpy as np


def parseNumRange(string):
    """
    Parse range of integers like xx-yy
    """
    m = re.match(r'(\d+)(?:-(\d+))?$', string)
    if not m:
        raise argparse.ArgumentTypeError("'" + string + "' is not a range of number. Expected forms like '0-5' or '2'.")
    start = m.group(1)
    end = m.group(2) or start
    return set(range(int(start, 10), int(end, 10) + 1))


def parseNumList(string):
    """
    Parse range of integers like xx-yy,zz
    """
    result = set()
    for rr in [x.strip() for x in string.split(',')]:
        result |= parseNumRange(rr)

    return list(result)


def argparser():
    """
    Parse options as command-line arguments.
    """

    description = "Script to get the online integrated luminosity for a range or runs."

    parser = argparse.ArgumentParser(description=description, usage=__doc__, add_help=True)

    parser.add_argument("--exp",
                        dest="exp",
                        action="store",
                        type=int,
                        required=True,
                        help="Experiment number")
    parser.add_argument("--runs",
                        dest="runs",
                        action="store",
                        type=parseNumList,
                        required=True,
                        default=None,
                        help="Process only the selected run range. Syntax is xx-yy,zz")
    parser.add_argument("--verbose",
                        dest="verb",
                        action="store_true",
                        default=False,
                        help="Print each run luminosity")
    parser.add_argument("--db",
                        dest="db",
                        action="store",
                        default="/gpfs/group/belle2/group/detector/ECL/ecl_lom.db",
                        help="EC: DataBase path")

    plot_actions = {
        "LUMI_PER_DATE" : "Histogram of integrated luminosity per date",
        "LUMI_PER_RUN"  : "Histogram of integrated luminosity per run",
        "TOT_LUMI_VS_DATE" : "Graph of total integrated luminosity vs. date",
        }

    parser.add_argument("--plot",
                        dest="plot",
                        action="store",
                        choices=list(plot_actions.keys()),
                        default=None,
                        help="")

    return parser


def create_connection(db_file):
    """
    Create a database connection to the SQLite database specified by the db_file.

    :param db_file: database file
    :return: Connection object or None
    """

    if not os.path.exists(db_file):
        b2.B2FATAL(f"DB {db_file} not found. The live luminosity is only available on KEKCC (sorry)")

    connection = None
    try:
        connection = sqlite3.connect(db_file)
    except sqlite3.Error as e:
        print(e)

    return connection


def printLumi(cursor, args):
    """
    Print the integrated lumi for the selected runs.

    :param cursor: SQLLite Cursor object.
    :param args: command-line args.
    """

    col_lumi = "lum_det_shift"

    cmd = f"SELECT SUM({col_lumi}) as lumi, start_time, end_time FROM prev_bhacnt_det_run WHERE exp = :exp and run = :run"
    if args.verb:
        print('-' * 61)
        print(f"Run No   : Delivererd Lumi  | Run start [JST]")
        print('-' * 61)
    L = 0
    for run in args.runs:
        cursor.execute(cmd, {"exp":args.exp, "run":run})
        row = cursor.fetchone()
        if row['lumi']:
            if args.verb:
                runDate = time.strftime("%a, %d %b %Y %H:%M:%S +0000", time.localtime(row['start_time']))
                print(f"Run {run:5d}: L = {row['lumi']:8.2f} /nb = {row['lumi']/1E3:8.2f} /pb = {row['lumi']/1E6:8.2f} /fb = {row['lumi']/1E9:8.2f} /ab | {runDate}")
            L += float(row['lumi'])

    if args.verb:
        print('-' * 61)

    print(f"TOTAL    : L = {L:8.2f} /nb = {L/1E3:8.2f} /pb = {L/1E6:8.3f} /fb = {L/1E9:8.4f} /ab")


def plotLumi(connection, args):
    """
    Make monitoring plots of luminosity.

    :param connection: SQLLite Connection object.
    :param args: command-line args.
    """

    col_lumi = "lum_det_shift"

    cmdexp = f"SELECT {col_lumi} as lumi, run, start_time as date, end_time FROM prev_bhacnt_det_run WHERE exp = :exp "
    if args.runs:
        cmdexp += f" AND run >= {min(args.runs)} AND run <= {max(args.runs)}"

    # Get the DB as a pandas.Dataframe.
    df = pd.read_sql_query(cmdexp, connection, params=(args.exp,))
    print(f"Read {len(df)} runs")

    # convert epoch to date
    df['date'] = pd.to_datetime(df['date'],unit='s')

    # cumulative integrated luminosity
    df['intLumi'] = df['lumi'].cumsum()

    # RUN max, min
    run_min = df["run"].min()
    run_max = df["run"].max()

    # Group runs by date, and store the int lumi per date as the max cumulative lumi.
    # This returns a pandas.Series object.
    srs_lumi_date = df.groupby(df["date"].dt.strftime('%d %m %Y'))["lumi"].sum()*1.E-6 # in /fb

    figure, axes = plt.subplots()

    x = srs_lumi_date.index.values
    y = srs_lumi_date.values

    labels = {
        "EXP" : rf"Experiment {int(args.exp)}",
        "RUNS" : rf"Runs: {run_min}-{run_max}",
        "TOT" : rf"Total $\int\ L\ dt\ (\mathrm{{ONLINE}}) = {df['intLumi'].max()/1.e6:.2f}\ [\mathrm{{fb}}^{{-1}}]$",
        }
    labelstr = "\n".join(labels.values())

    axes.bar(x, y, label=labelstr, color="black")

    axes.fill_between(x, y, color="yellow")#, alpha=0.3)

    axes.set_xlabel(r"Date")
    axes.set_ylabel(r"Total integrated luminosity per day [$\mathrm{fb}^{-1}$]")
    axes.tick_params(axis="x", labelrotation=45, labelsize="small")
    axes.legend(loc="best")
    axes.xaxis.set_major_locator(ticker.AutoLocator())
    axes.xaxis.set_minor_locator(ticker.MultipleLocator(1))

    # Text box. Use axis coords.
    plt.text(0.05, 0.7, r"$Belle\ II$", transform=axes.transAxes, fontsize=16)

    plt.savefig(f"{plotname}.pdf", bbox_inches="tight")


if __name__ == '__main__':

    args = argparser().parse_args()

    DB = args.db
    conn = create_connection(DB)
    if not conn:
        b2.B2FATAL(f"Could not establish connection to DB: {DB}")

    with conn:

        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        printLumi(cursor, args)

        if args.plot:
            plotLumi(conn, args)
