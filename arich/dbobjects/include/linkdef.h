#ifdef __CINT__

#pragma link off all globals;
#pragma link off all classes;
#pragma link off all functions;
#pragma link C++ nestedclasses;

#pragma link C++ class Belle2::ARICHAerogelInfo+; // checksum=0x7bac5382, version=4
#pragma link C++ class Belle2::ARICHAerogelRayleighScatteringFit+; // checksum=0xb47bd659, version=1
#pragma link C++ class Belle2::ARICHAerogelMap+; // checksum=0xcf3e4999, version=2
#pragma link C++ class Belle2::ARICHAsicChannelMask+; // checksum=0x47684faf, version=1
#pragma link C++ class Belle2::ARICHAsicInfo+; // checksum=0x3d2cef35, version=3
#pragma link C++ class Belle2::ARICHBadChannels+; // checksum=0xc4206ee5, version=1
#pragma link C++ class Belle2::ARICHB2LinkInfo+; // checksum=0x35f43664, version=1
#pragma link C++ class Belle2::ARICHCableInfo+; // checksum=0x6f04db63, version=1
#pragma link C++ class Belle2::ARICHComponentTest+; // checksum=0x5c4cc1fd, version=1
#pragma link C++ class Belle2::ARICHFEBoardInfo+; // checksum=0xfaa38872, version=2
#pragma link C++ class Belle2::ARICHFebTest+; // checksum=0xe7cfb50c, version=2
#pragma link C++ class Belle2::ARICHFirmware+; // checksum=0x7aedf478, version=1
#pragma link C++ class Belle2::ARICHHapdChipInfo+; // checksum=0xc2d875ab, version=3
#pragma link C++ class Belle2::ARICHHapdInfo+; // checksum=0x6dc06320, version=2
#pragma link C++ class Belle2::ARICHHapdMask+; // checksum=0xc0923be3, version=1
#pragma link C++ class Belle2::ARICHHapdQA+; // checksum=0x4ab0e744, version=2
#pragma link C++ class Belle2::ARICHHapdQE+; // checksum=0x73be9579, version=1
#pragma link C++ class Belle2::ARICHHighVoltageConfig+; // checksum=0xb7b0bd2, version=1
#pragma link C++ class Belle2::ARICHMergerInfo+; // checksum=0xe5ecab76, version=1
#pragma link C++ class Belle2::ARICHMergerMap+; // checksum=0x225d8b64, version=1
#pragma link C++ class Belle2::ARICHMirrorInfo+; // checksum=0x8339753e, version=1
#pragma link C++ class Belle2::ARICHMirrorMap+; // checksum=0xe9389b98, version=1
#pragma link C++ class Belle2::ARICHSensorModuleInfo+; // checksum=0xf6819991, version=2
#pragma link C++ class Belle2::ARICHSensorModuleMap+; // checksum=0x7f7ae362, version=2
#pragma link C++ class Belle2::ARICHGeoBase+; // checksum=0x21c6da01, version=2
#pragma link C++ class Belle2::ARICHGeoMasterVolume+; // checksum=0xd106fe48, version=2
#pragma link C++ class Belle2::ARICHGeoAerogelPlane+; // checksum=0xd45f1d13, version=3
#pragma link C++ class Belle2::ARICHGeoDetectorPlane+; // checksum=0xed2bcb49, version=1
#pragma link C++ class Belle2::ARICHGeoHAPD+; // checksum=0x11d6f4d9, version=1
#pragma link C++ class Belle2::ARICHGeoMerger+; // checksum=0xd86b111e, version=2
#pragma link C++ class Belle2::ARICHGeoCablesEnvelope+; // checksum=0x453c63ee, version=1
#pragma link C++ class Belle2::ARICHGeoCooling+; // checksum=0xc54c74ec, version=1
#pragma link C++ class Belle2::ARICHGeoFEBCooling+; // checksum=0xa03622e6, version=1
#pragma link C++ class Belle2::ARICHGeoMergerCooling+; // checksum=0x77af821e, version=1
#pragma link C++ class Belle2::tessellatedSolidStr+; // checksum=0xa5063eee, version=-1
#pragma link C++ class Belle2::ARICHGeoSupport+; // checksum=0xc4292f59, version=1
#pragma link C++ class Belle2::ARICHGeoMirrors+; // checksum=0xa7a75d54, version=2
#pragma link C++ class Belle2::ARICHGeometryConfig+; // checksum=0xf1561a50, version=5
#pragma link C++ class Belle2::ARICHModulesInfo+; // checksum=0xb4f2e8d1, version=1
#pragma link C++ class Belle2::ARICHChannelMapping+; // checksum=0xe87dff92, version=1
#pragma link C++ class Belle2::ARICHMergerMapping+; // checksum=0x6559795c, version=2
#pragma link C++ class Belle2::ARICHCopperMapping+; // checksum=0xcd9563a7, version=1
#pragma link C++ class Belle2::ARICHSimulationPar+; // checksum=0x66eb312a, version=2
#pragma link C++ class Belle2::ARICHReconstructionPar+; // checksum=0xb565bf14, version=2
#pragma link C++ class Belle2::ARICHChannelMask+; // checksum=0xf77f127, version=1
#pragma link C++ class Belle2::ARICHModuleTest+; // checksum=0x88218b49, version=2
#pragma link C++ class Belle2::ARICHMagnetTest+; // checksum=0x843ec14b, version=1
#pragma link C++ class Belle2::ARICHBiasCablesMapping+; // checksum=0x9e5f669f, version=1
#pragma link C++ class Belle2::ARICHBiasChannelsMapping+; // checksum=0x43a58c3b, version=1
#pragma link C++ class Belle2::ARICHBiasVoltages+; // checksum=0xad084f2a, version=1
#pragma link C++ class Belle2::ARICHBiasCrateCableMapping+; // checksum=0x9175abf6, version=1
#pragma link C++ class Belle2::ARICHHvChannelsMapping+; // checksum=0x567b3a0e, version=1
#pragma link C++ class Belle2::ARICHHvCablesMapping+; // checksum=0x5dccb59a, version=1
#pragma link C++ class Belle2::ARICHHvCrateCableMapping+; // checksum=0x9665991f, version=1
#pragma link C++ class Belle2::ARICHAeroTilesInfo+; // checksum=0xbbc51b99, version=2
#pragma link C++ class Belle2::ARICHGlobalAlignment+; // checksum=0x61104b94, version=2
#pragma link C++ class Belle2::ARICHPositionElement+; // checksum=0xec484344, version=1
#pragma link C++ class Belle2::ARICHGeoGlobalDisplacement+; // checksum=0xf36738c8, version=1
#pragma link C++ class Belle2::ARICHGeoMirrorDisplacement+; // checksum=0x2deaf4ca, version=1
#pragma link C++ class Belle2::ARICHMirrorAlignment+; // checksum=0xd4f6fc8d, version=1
#pragma link C++ class Belle2::ARICHAeroTilesAlignment+; // checksum=0xe98f9a64, version=1

#pragma read                                                                                                  \
  sourceClass="Belle2::ARICHGeoMirrors"                                                                       \
  source="std::vector<TVector3> m_normVector"                                                                 \
  version="[1]"                                                                                               \
  targetClass="Belle2::ARICHGeoMirrors"                                                                       \
  target="m_normVector"                                                                                       \
  include="TVector3.h"                                                                                        \
  code="{for (const auto& normVector : onfile.m_normVector)                                                   \
           m_normVector.emplace_back(ROOT::Math::XYZVector(normVector.X(), normVector.Y(), normVector.Z()));  \
        }"                                                                                                    \

#pragma read                                                                              \
  sourceClass="Belle2::ARICHGeoMirrors"                                                   \
  source="std::vector<TVector3> m_point"                                                  \
  version="[1]"                                                                           \
  targetClass="Belle2::ARICHGeoMirrors"                                                   \
  target="m_point"                                                                        \
  include="TVector3.h"                                                                    \
  code="{for (const auto& point : onfile.m_point)                                         \
           m_point.emplace_back(ROOT::Math::XYZVector(point.X(), point.Y(), point.Z()));  \
        }"                                                                                \

#pragma read                                    \
  sourceClass="Belle2::ARICHGeoMasterVolume"    \
  source="TRotation* m_rotation"                \
  version="[1]"                                 \
  targetClass="Belle2::ARICHGeoMasterVolume"    \
  target="m_rotation"                           \
  include="TRotation.h"                         \
  code="{                                       \
    m_rotation = new ROOT::Math::Rotation3D;    \
    m_rotation->SetComponents(                  \
      onfile.m_rotation->XX(),                  \
      onfile.m_rotation->XY(),                  \
      onfile.m_rotation->XZ(),                  \
      onfile.m_rotation->YX(),                  \
      onfile.m_rotation->YY(),                  \
      onfile.m_rotation->YZ(),                  \
      onfile.m_rotation->ZX(),                  \
      onfile.m_rotation->ZY(),                  \
      onfile.m_rotation->ZZ()                   \
    );                                          \
  }"                                            \

#pragma read                                        \
  sourceClass="Belle2::ARICHGeoMasterVolume"        \
  source="TRotation* m_rotationInverse"             \
  version="[1]"                                     \
  targetClass="Belle2::ARICHGeoMasterVolume"        \
  target="m_rotationInverse"                        \
  include="TRotation.h"                             \
  code="{                                           \
    m_rotationInverse = new ROOT::Math::Rotation3D; \
    m_rotationInverse->SetComponents(               \
      onfile.m_rotationInverse->XX(),               \
      onfile.m_rotationInverse->XY(),               \
      onfile.m_rotationInverse->XZ(),               \
      onfile.m_rotationInverse->YX(),               \
      onfile.m_rotationInverse->YY(),               \
      onfile.m_rotationInverse->YZ(),               \
      onfile.m_rotationInverse->ZX(),               \
      onfile.m_rotationInverse->ZY(),               \
      onfile.m_rotationInverse->ZZ()                \
    );                                              \
  }"                                                \

#pragma read                                    \
  sourceClass="Belle2::ARICHGeoMasterVolume"    \
  source="TVector3* m_translation"              \
  version="[1]"                                 \
  targetClass="Belle2::ARICHGeoMasterVolume"    \
  target="m_translation"                        \
  include="TVector3.h"                          \
  code="{                                       \
    m_translation = new ROOT::Math::XYZVector;  \
    m_translation->SetXYZ(                      \
      onfile.m_translation->X(),                \
      onfile.m_translation->Y(),                \
      onfile.m_translation->Z()                 \
    );                                          \
  }"                                            \

// #pragma read                                    \
//   sourceClass="Belle2::ARICHGlobalAlignment"    \
//   source="TRotation* m_rotation"                \
//   version="[1]"                                 \
//   targetClass="Belle2::ARICHGlobalAlignment"    \
//   target="m_rotation"                           \
//   include="TRotation.h"                         \
//   code="{                                       \
//     m_rotation = new ROOT::Math::Rotation3D;    \
//     m_rotation->SetComponents(                  \
//       onfile.m_rotation->XX(),                  \
//       onfile.m_rotation->XY(),                  \
//       onfile.m_rotation->XZ(),                  \
//       onfile.m_rotation->YX(),                  \
//       onfile.m_rotation->YY(),                  \
//       onfile.m_rotation->YZ(),                  \
//       onfile.m_rotation->ZX(),                  \
//       onfile.m_rotation->ZY(),                  \
//       onfile.m_rotation->ZZ()                   \
//     );                                          \
//   }"                                            \

// #pragma read                                        \
//   sourceClass="Belle2::ARICHGlobalAlignment"        \
//   source="TRotation* m_rotationInverse"             \
//   version="[1]"                                     \
//   targetClass="Belle2::ARICHGlobalAlignment"        \
//   target="m_rotationInverse"                        \
//   include="TRotation.h"                             \
//   code="{                                           \
//     m_rotationInverse = new ROOT::Math::Rotation3D; \
//     m_rotationInverse->SetComponents(               \
//       onfile.m_rotationInverse->XX(),               \
//       onfile.m_rotationInverse->XY(),               \
//       onfile.m_rotationInverse->XZ(),               \
//       onfile.m_rotationInverse->YX(),               \
//       onfile.m_rotationInverse->YY(),               \
//       onfile.m_rotationInverse->YZ(),               \
//       onfile.m_rotationInverse->ZX(),               \
//       onfile.m_rotationInverse->ZY(),               \
//       onfile.m_rotationInverse->ZZ()                \
//     );                                              \
//   }"                                                \

// #pragma read                                    \
//   sourceClass="Belle2::ARICHGlobalAlignment"    \
//   source="TVector3* m_translation"              \
//   version="[1]"                                 \
//   targetClass="Belle2::ARICHGlobalAlignment"    \
//   target="m_translation"                        \
//   include="TVector3.h"                          \
//   code="{                                       \
//     m_translation = new ROOT::Math::XYZVector;  \
//     m_translation->SetXYZ(                      \
//       onfile.m_translation->X(),                \
//       onfile.m_translation->Y(),                \
//       onfile.m_translation->Z()                 \
//     );                                          \
//   }"                                            \

#endif


