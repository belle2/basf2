#!/bin/bash

# Script for organizing many input root files into sub directories (softlinks) and then submitting batch jobs, one for each directory
#   Input directory contains all the files we want to run over.  This must be generated by hand by the user before runnning.
#   numRunsPerDir defines the number of runs we will put into a single directory and submit as a single batch job
#   files will be sorted into a directory named based on the date and time of this script running
#   Softlinks are followed in the originating directory and softlinks introduced in the sorting directories
#   Once the files are sorted the batch jobs are submitted.
#   A time delay is used to make sure we don't crash the batch submission machines
#
#   Usage:
#      Set the "Files" variabl to point to a collection of input root files
#      Execute command:
#         source submit_all_batch
#
#   No user parameters exist
#   run script from the scripts directory 



splitRunsPerDir=1
numRunsPerDir=15   # It looks like 15 runs under a reasonable amount of time and does not run the risk of hitting the maximum 4 hours time limit associated to the short queue (less than 1 hour)

# splitRunsPerDir is a boolean variable to let the user decide whether or not to allow a single run to be split into multiple directories / batch jobs
# USAGE:
#    splitRunsPerDir=0   # for finding tcrates
#    splitRunsPerDir=1   # for finding tcrystals



FILES=proc10/selectionOfRuns/*
# FILES=proc10/debuggingSubmitScriptRuns/*
# FILES=proc10/allRuns/*


i=0
j=-1
k=0
numDirs=0

# i counts the number of unique experiments+runs in a directory
# j counts the directories
# k counts the total number of files
# numDirs counts the total number of directories created for job submissions

prevExpNum=-2
prevRunNum=-2

#echo $FILES

timeNow=$(date +%Y_%m_%d_%Hhour_%Mmin_%Ssec)_tcollector
echo $timeNow
outputDirTimeNow=${timeNow}_outputs
log=filesSorting_$timeNow.txt
echo $log
mkdir $timeNow
mkdir -p $timeNow/$outputDirTimeNow
mkdir -p $timeNow/inputs
mkdir -p $timeNow/$outputDirTimeNow/logs
mkdir -p $timeNow/$outputDirTimeNow/results

for f in $FILES
do
   # example file name: cdst.physics.0008.01539.HLT5.hlt_bhabha.f00001.root
   fnameNoPath="$(basename -- $f)"
   #echo $fnameNoPath
   #INPUT='cdst.physics.0008.01539.HLT5.hlt_bhabha.f00001.root'
   expNum=$(echo $f| cut -d'.' -f 3)
   runNum=$(echo $f| cut -d'.' -f 4)
   #echo $expNum $runNum

   if [ "$expNum" != "$prevExpNum" ] || [ "$runNum" != "$prevRunNum" ] ; then
      i=0
      j=`expr $j + 1`
      dirNumZeroPadded=`printf "%05d\n" $j`

      #echo "Experiment number " $prevExpNum " -> " $expNum ", run number " $prevRunNum " -> " $runNum 
      prevExpNum=$expNum
      prevRunNum=$runNum

      cd $timeNow
      mkdir inputs/$dirNumZeroPadded
      echo "--------------------------------------" >> $outputDirTimeNow/$log
      echo $dirNumZeroPadded >> $outputDirTimeNow/$log
      cd ..
      numDirs=`expr $numDirs + 1`
   elif [ "1" == $splitRunsPerDir ] ; then
      if [ "$i" == "0" ] ; then
         j=`expr $j + 1`
         dirNumZeroPadded=`printf "%05d\n" $j`
         cd $timeNow
         mkdir inputs/$dirNumZeroPadded
         echo "--------------------------------------" >> $outputDirTimeNow/$log
         echo $dirNumZeroPadded >> $outputDirTimeNow/$log
         cd ..
         numDirs=`expr $numDirs + 1`
      fi
   fi




   echo $f $dirNumZeroPadded

   echo $f >> $timeNow/$outputDirTimeNow/$log

   #ln -s $f $dirNumZeroPadded/$k.root
   fullPathFile=$(readlink "$f")
   #ln -s $fullPathFile $dirNumZeroPadded/$k.root
   cd $timeNow/inputs/$dirNumZeroPadded
   #ls
   ln -s $fullPathFile .
   cd ../../..


   i=`expr $i + 1`
   k=`expr $k + 1`


   if [ "1" == $splitRunsPerDir ] ; then
      if [ "$i" == $numRunsPerDir ] ; then
         i=0
         echo "splitting run into multiple directories"
      fi
   #if [ "$i" == "2" ] ; then
#   if [ "$i" == $numRunsPerDir ] ; then
#      i=0
#      dirNumZeroPadded=`expr $dirNumZeroPadded + 1`
#   fi
   fi


done
echo "Number of files = "
echo $k
echo "=============================================" >> $timeNow/$outputDirTimeNow/$log
echo "Number of files =" >> $timeNow/$outputDirTimeNow/$log
echo $k >> $timeNow/$outputDirTimeNow/$log


dirCounter=0
while [ $dirCounter -lt $numDirs ]
do
   #echo $dirCounter

   dirNumZeroPadded=`printf "%05d\n" $dirCounter`
   echo $dirNumZeroPadded

   rm -rf batchSubmitCurrentDir
   ln -s  $timeNow/inputs/$dirNumZeroPadded    batchSubmitCurrentDir
   ls batchSubmitCurrentDir/


   # Short queue cuts out at 6 hours.  Otherwise use long queue
   bsub -q s       -o $timeNow/$outputDirTimeNow/logs/run_eclBhabhaT_collector_log_$dirNumZeroPadded.txt "basf2 run_eclBhabhaT_collector.py -i '$timeNow/inputs/$dirNumZeroPadded/*.root'   -o $timeNow/$outputDirTimeNow/results/eclBhabhaTCollector_$dirNumZeroPadded.root"     ##  short queue
   # bsub -q b2_prod -o $timeNow/$outputDirTimeNow/logs/run_eclBhabhaT_collector_log_$dirNumZeroPadded.txt "basf2 run_eclBhabhaT_collector.py -i '$timeNow/inputs/$dirNumZeroPadded/*.root'   -o $timeNow/$outputDirTimeNow/results/eclBhabhaTCollector_$dirNumZeroPadded.root"     ##  long queue
   # bsub -q l       -o $timeNow/$outputDirTimeNow/logs/run_eclBhabhaT_collector_log_$dirNumZeroPadded.txt "basf2 run_eclBhabhaT_collector.py -i '$timeNow/inputs/$dirNumZeroPadded/*.root'   -o $timeNow/$outputDirTimeNow/results/eclBhabhaTCollector_$dirNumZeroPadded.root"     ##  long queue
   # bsub -q a       -o $timeNow/$outputDirTimeNow/logs/run_eclBhabhaT_collector_log_$dirNumZeroPadded.txt "basf2 run_eclBhabhaT_collector.py -i '$timeNow/inputs/$dirNumZeroPadded/*.root'   -o $timeNow/$outputDirTimeNow/results/eclBhabhaTCollector_$dirNumZeroPadded.root"     ##  always quickly accepts 2 jobs queue



   delaySubmitCounter=$(($dirCounter%22))
   if [ "$delaySubmitCounter" == "0" ] ; then
      sleep 2
   fi

   dirCounter=`expr $dirCounter + 1`
done




