#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import sys
import os
import subprocess
import datetime
from getpass import getuser

# check for help option
if len(sys.argv) != 2 or sys.argv[1] in ['--help', '-h', '-?']:
    sys.stderr.write("""
Usage: `basename $0` modulename

This command creates a source code template for a module.

""")
    sys.exit(0)

module = sys.argv[1]


def flush(str):
    """
    Print the string and flush stdout
    """

    sys.stdout.write(str)
    sys.stdout.flush()

def default_member_name(class_name):
    """
    Return a default member name for a given class name

    Convert first letter of classname to lower case. If more than one capital
    letter in the beginning (probably detector name), convert all but the last
    capital letter in the beginning to lower case
    """
    default_name = list(class_name)
    for i, c in enumerate(default_name):
        if i == 0 or class_name[i:i+2].isupper():
            default_name[i] = c.lower()
        else:
            break
    return "".join(default_name)


# define relpath for python < 2.6
if not hasattr(os.path, 'relpath'):

    def relpath(path, start=os.path.curdir):
        """Return a relative version of a path"""

        if not path:
            raise ValueError('no path specified')

        start_list = os.path.abspath(start).split(os.path.sep)
        path_list = os.path.abspath(path).split(os.path.sep)

        # Work out how much of the filepath is shared by start and path.
        i = len(os.path.commonprefix([start_list, path_list]))

        rel_list = [os.path.pardir] * (len(start_list) - i) + path_list[i:]
        if not rel_list:
            return os.path.curdir
        return os.path.join(*rel_list)

    os.path.relpath = relpath


# set header and source file names
header = module + 'Module.h'
src = module + 'Module.cc'
if os.path.isdir('include') and os.path.isdir('src'):
    header = os.path.join('include', header)
    src = os.path.join('src', src)

# check whether the files already exist
if os.path.isfile(header) or os.path.isfile(src):
    sys.stderr.write('ERROR: The file %s or %s already exists.\n' % (header,
                     src))
    sys.exit(1)

# make sure we have an analysis or local release directory
local_dir = os.environ.get('BELLE2_ANALYSIS_DIR',
                           os.environ.get('BELLE2_LOCAL_DIR', ''))
if local_dir == '':
    sys.stderr.write('ERROR: No analysis or local release is set up.\n')
    sys.exit(1)

# get author name
flush('Your name [%s]: ' % getuser())
author = sys.stdin.readline().strip('\n')
if author == '':
    author = getuser()

# get module description
flush('Short module description: ')
short_desc = sys.stdin.readline().strip('\n')
flush('Long module description (finish with ctrl-D):\n')
long_desc = sys.stdin.readlines()

# get module parameters
params_header = ''
params_src = ''
param_types = {
    'i': 'int',
    'd': 'double',
    's': 'std::string',
    'b': 'bool',
    'vi': 'std::vector<int>',
    'vd': 'std::vector<double>',
    'vs': 'std::vector<std::string>',
    'vb': 'std::vector<bool>',
    }
flush("""Please enter the module parameters one by one.
Enter an empty name to finish the list of module parameters.
The following key words for parameter types can be used:
i for int, d for double, s for string, b for bool.
Add a v before the type letter for vectors.
All other strings will be taken directly as type names.
""")
while True:
    flush('  Name            : ')
    param_name = sys.stdin.readline().strip('\n')
    if param_name == '':
        break
    flush('    Type          : ')
    param_type = sys.stdin.readline().strip('\n')
    if param_type in list(param_types.keys()):
        param_type = param_types[param_type]
    flush('    Description   : ')
    param_desc = sys.stdin.readline().strip('\n')
    param_def = ''
    if param_type.find('<') < 0:
        flush('    Default [none]: ')
        param_def = sys.stdin.readline().strip('\n')
        if param_type == 'std::string':
            if not param_def.startswith('"'):
                param_def = '"' + param_def + '"'
            param_def = 'std::string(' + param_def + ')'
    params_header = params_header + '    %s m_%s;  /**< %s */\n' \
        % (param_type, param_name, param_desc)
    if param_def == '':
        params_src = params_src + '  addParam("%s", m_%s, "%s");\n' \
            % (param_name, param_name, param_desc)
    else:
        params_src = params_src + '  addParam("%s", m_%s, "%s", %s);\n' \
            % (param_name, param_name, param_desc, param_def)

# get module input and output
header_includes = []
src_includes = []
ctor_src = ''
init_header = ''
init_src = ''
flush('Please enter the required/optional input data types:\n')
while True:
    flush('  Input type             : ')
    io_class = sys.stdin.readline().strip('\n')
    if io_class == '':
        break
    flush('    Array (y/n) [y]      : ')
    io_type = 'Array'
    if sys.stdin.readline().strip('\n') == 'n':
        io_type = 'ObjPtr'
    flush('    Required (y/n) [y]   : ')
    io_required = 'required'
    if sys.stdin.readline().strip('\n') == 'n':
        io_required = 'optional'
    flush('    Branch name [default]: ')
    io_branch = sys.stdin.readline().strip('\n')
    io_default_name = default_member_name(io_class)
    flush('    Variable name [%s]: ' % io_default_name)
    io_name = sys.stdin.readline().strip('\n')
    if not io_name:
        io_name = io_default_name
    flush('    Description          : ')
    io_desc = sys.stdin.readline().strip('\n')
    init_header = init_header + '    Store%s<%s> m_%s; /**< %s */\n' \
        % (io_type, io_class, io_name, io_desc)
    header_includes.append('Store%s' % io_type)
    header_includes.append(io_class)
    if io_branch != '':
        ctor_src = ctor_src + ', m_%s("%s")' % (io_name, io_branch)
    io_required = io_required[0].upper() + io_required[1:]
    init_src = init_src + '  m_%s.is%s();\n' % (io_name, io_required)

flush('Please enter the output data types:\n')
while True:
    flush('  Output type            : ')
    io_class = sys.stdin.readline().strip('\n')
    if io_class == '':
        break
    flush('    Array (y/n) [y]      : ')
    io_type = 'Array'
    if sys.stdin.readline().strip('\n') == 'n':
        io_type = 'ObjPtr'
    flush('    Write out (y/n) [y]  : ')
    io_storeFlag = ''
    if sys.stdin.readline().strip('\n') == 'n':
        io_storeFlag = 'DataStore::c_DontWriteOut'
    flush('    Branch name [default]: ')
    io_branch = sys.stdin.readline().strip('\n')
    io_default_name = default_member_name(io_class)
    flush('    Variable name [%s]: ' % io_default_name)
    io_name = sys.stdin.readline().strip('\n')
    if not io_name:
        io_name = io_default_name
    flush('    Description          : ')
    io_desc = sys.stdin.readline().strip('\n')
    init_header = init_header + '    Store%s<%s> m_%s; /**< %s */\n' \
        % (io_type, io_class, io_name, io_desc)
    header_includes.append('Store%s' % io_type)
    header_includes.append(io_class)
    if io_branch != '':
        ctor_src = ctor_src + ', m_%s("%s")' % (io_name, io_branch)
    init_src = init_src + '  m_%s.registerInDataStore(%s);\n' % (io_name, io_storeFlag)

# get module methods
methods_header = ''
methods_src = ''
flush("""Please select the required module methods:
""")
for method in ['initialize', 'beginRun', 'event', 'endRun', 'terminate', 'destructor']:
    if method == 'initialize' and init_src != '':
        selected = True
        method_desc = 'Register input and output data'
    else:
        flush('  %-10s (y/n) [n]: ' % method)
        selected = sys.stdin.readline().strip('\n') == 'y'
        if selected:
            flush('    description       : ')
            method_desc = sys.stdin.readline().strip('\n')
    if selected:
        if method == 'destructor':
            methods_header = '''    /** %s */
    virtual ~%sModule() override;

''' \
                % (method_desc, module) + methods_header
            methods_src = '''%sModule::~%sModule()
{
}

''' % (module, module) \
                + methods_src
        else:
            methods_header = methods_header \
                + '''    /** %s */
    virtual void %s() override;

''' % (method_desc,
                    method)
            if method == 'initialize':
                methods_src = methods_src + '''void %sModule::%s()
{
%s}

''' \
                    % (module, method, init_src)
            else:
                methods_src = methods_src + '''void %sModule::%s()
{
}

''' \
                    % (module, method)

# determine include statements
header_includes = [f + '.h' for f in list(set(header_includes))]
src_includes = [f + '.h' for f in list(set(src_includes)
                - set(header_includes))]
includes_header = ''
includes_src = ''
release_dirs = [local_dir]
if 'BELLE2_RELEASE_DIR' in os.environ:
    release_dirs.append(os.environ['BELLE2_RELEASE_DIR'])

for release_dir in release_dirs:
    include_dir = os.path.join(release_dir, 'include')
    for (root, dirs, files) in os.walk(include_dir):
        if 'genfit' in root:
            continue
        for name in files:
            if name in header_includes:
                includes_header = includes_header + '#include <%s>\n' \
                    % os.path.relpath(os.path.join(root, name), include_dir)
                header_includes.remove(name)
            elif name in src_includes:
                includes_src = includes_src + '#include <%s>\n' \
                    % os.path.relpath(os.path.join(root, name), include_dir)
                src_includes.remove(name)

if len(header_includes + src_includes) > 0:
    sys.stderr.write('''
WARNING: The header files for the following classes were not found:
%s
'''
                     % ', '.join(header_includes + src_includes))

# write the header file
f = open(header, 'w')
f.write("""/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) %(year)d - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: %(author)-50s       *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#pragma once

#include <framework/core/Module.h>
%(includes)s

namespace Belle2 {
  /**
   * %(short_description)s
   *
   * %(long_description)s
   */
  class %(module)sModule : public Module {

  public:

    /**
     * Constructor: Sets the description, the properties and the parameters of the module.
     */
    %(module)sModule();

%(methods)s
  private:

%(members)s  };
}
""" % {
    'year': datetime.datetime.now().year,
    'author': author,
    'includes': includes_header,
    'short_description': short_desc,
    'long_description': '   * '.join(long_desc),
    'module': module,
    'methods': methods_header,
    'members': params_header + init_header,
})
f.close()

# write the source file
path = ''
f = open(src, 'w')
f.write("""/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) %(year)d - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: %(author)-50s       *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <%(module_header)s>

/* --------------- WARNING ---------------------------------------------- *
If you have more complex parameter types in your class then simple int,
double or std::vector of those you might need to uncomment the following
include directive to avoid an undefined reference on compilation.
 * ---------------------------------------------------------------------- */
// #include <framework/core/ModuleParam.templateDetails.h>

%(includes)s

using namespace Belle2;

//-----------------------------------------------------------------
//                 Register the Module
//-----------------------------------------------------------------
REG_MODULE(%(module)s)

//-----------------------------------------------------------------
//                 Implementation
//-----------------------------------------------------------------

%(module)sModule::%(module)sModule() : Module()%(constructor)s
{
  // Set module properties
  setDescription(R"DOC("%(short_description)s

%(long_description)s
  )DOC");

  // Parameter definitions
%(params)s
}

%(methods)s
""" % {
    'year': datetime.datetime.now().year,
    'author': author,
    'module_header': os.path.relpath(os.path.join(os.getcwd(), '%sModule.h' % module), local_dir),
    'includes': includes_src,
    'short_description': short_desc,
    'long_description': '\n'.join(e.strip() for e in long_desc),
    'module': module,
    'constructor': ctor_src,
    'methods': methods_src,
    'params': params_src,
})
f.close()

# add new files to git
subprocess.call(['git', 'add', header, src])
