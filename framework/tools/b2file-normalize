#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""Tool to reset the non-reproducible root file metadata: UUID and datimes.
It can also reset the initial file name stored in the file itself, but
(WARNING!) this can corrupt the root file.
"""

import argparse
import sys
import os
import tempfile
import shutil
from B2Tools.b2root import RawRootFile, byteorder
from basf2 import B2ERROR


def get_argument_parser():
    """
    Return an ArgumentParser with all defined arguments
    """

    # Specify the possible arguments
    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        usage="%(prog)s filename"
    )
    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument('--output', '-o', type=str, default=None,
                              help='Name of the output root file, default is basename_normalized.ext')
    output_group.add_argument('--in-place', '-i', default=False, action='store_true',
                              help='Overwrite the input file')
    parser.add_argument('--name', '-n', type=str, default=None,
                        help='The file name to be stored in the file, default is to not change it')
    parser.add_argument('--root-version', '-r', type=int, default=None,
                        help='The root version number to be set, default is to not change it')
    parser.add_argument('filename', help='Name of the input root file')
    return parser


if __name__ == "__main__":
    parser = get_argument_parser()
    args = parser.parse_args()

    # open input file
    rootfile = RawRootFile(args.filename)

    # adjust root version number
    if args.root_version:
        rootfile.version = args.root_version

    # create output file
    if args.output:
        newrootfile = open(args.output, 'wb')
    elif args.in_place:
        newrootfile = tempfile.TemporaryFile()
    else:
        basename, ext = os.path.splitext(args.filename)
        newrootfile = open(basename + '_normalized' + ext, 'wb')

    # write output file header
    newrootfile.write(rootfile.header)

    # file name in the metadata
    if args.name:
        newname = args.name.encode()
    else:
        newname = None

    # bookkeeping of offsets, positions, and keys
    offset = 0
    seekfree = rootfile.seekfree
    nbytesfree = rootfile.nbytesfree
    nbytesname = rootfile.nbytesname
    seekinfo = rootfile.seekinfo
    keylist = []
    keyskey = None
    infokey = None
    swap = False

    for key in rootfile:
        # reset datime and adjust position of key
        key.normalize(pos=newrootfile.tell())

        # Special treatment of key containing the TFile information
        if key.showname == b'TFile':

            # if a new name is given change the name and determine the offset caused by the change of name length
            namelen = len(key.name)
            if newname:
                key.name = key.filename = newname
            offset = len(key.name) - namelen

            # apply the offset to total (2x), object, and key length
            key.nbytes += 2*offset
            key.objlen += offset
            key.keylen += offset

            # recreate the header from updated data members
            key.recreate_header()

            # recreate the key data with new name and lengths
            buffer = len(key.name).to_bytes(1, byteorder) + key.name
            buffer += len(key.title).to_bytes(1, byteorder) + key.title
            buffer += key.version.to_bytes(2, byteorder)
            buffer += (0).to_bytes(8, byteorder)  # reset datimeC and datimeM
            buffer += (key.nbyteskeys + offset).to_bytes(4, byteorder)
            buffer += (key.nbytesname + 2*offset).to_bytes(4, byteorder)
            wordlen = 8 if key.version > 1000 else 4
            buffer += key.seekdir.to_bytes(wordlen, byteorder)
            buffer += key.seekparent.to_bytes(wordlen, byteorder)
            seekkeyspos = newrootfile.tell() + len(key.header) + len(buffer)
            buffer += (rootfile.seekkeys + 2*offset).to_bytes(wordlen, byteorder)
            buffer += (0).to_bytes(18, byteorder)  # reset UUID
            if key.version <= 1000:
                buffer += (0).to_bytes(12, byteorder)
            key.data = buffer

        else:
            # check whether we break pointers in TTrees
            if key.classname == b'TTree' and offset != 0:
                B2ERROR('Changing the name of root files containing a tree is not supported.')
                if not args.in_place:
                    os.remove(newrootfile.name)
                sys.exit(1)

            # update key data in KeysList: number of keys and key headers
            # and remember key position
            if key.showname == b'KeysList':
                seekkeys = newrootfile.tell()
                buffer = len(keylist).to_bytes(4, byteorder)
                for filekey in keylist:
                    buffer += filekey.header
                key.data = buffer
                keyskey = key
                swap = (infokey is None)

            # update free segments pointer and remember key position
            if key.showname == b'FreeSegments':
                seekfree = newrootfile.tell()
                pointer = int.from_bytes(key.data[2:6], byteorder) + 4*offset
                key.data = key.data[:2] + pointer.to_bytes(4, byteorder) + key.data[6:]

            # update name in KeysList and FreeSegments
            if key.showname in [b'KeysList', b'FreeSegments'] and newname:
                key.name = newname
                key.nbytes += offset
                key.keylen += offset
                key.recreate_header()

            # keep track of all keys for the KeysList
            elif key.showname not in [b'StreamerInfo', b'']:
                keylist.append(key)

            # remember streamer info key and position
            if key.showname == b'StreamerInfo':
                seekinfo = newrootfile.tell()
                infokey = key

        # write the updated key, making sure the KeysList come after the StreamerInfo
        if swap and key.showname == b'KeysList':
            pass
        elif swap:
            seekinfo = newrootfile.tell()
            infokey.normalize(pos=seekinfo)
            newrootfile.write(infokey.header)
            newrootfile.write(infokey.data)
            seekkeys = newrootfile.tell()
            keyskey.normalize(pos=seekkeys)
            newrootfile.write(keyskey.header)
            newrootfile.write(keyskey.data)
            swap = False
        else:
            newrootfile.write(key.header)
            newrootfile.write(key.data)

    # write the new file header
    rootfile.normalize(end=newrootfile.tell(), seekfree=seekfree, nbytesfree=nbytesfree+offset,
                       nbytesname=nbytesname+2*offset, seekinfo=seekinfo)
    newrootfile.seek(0)
    newrootfile.write(rootfile.header)

    # update pointer to keyslist
    newrootfile.seek(seekkeyspos)
    newrootfile.write(seekkeys.to_bytes(wordlen, byteorder))

    # replace in the input file if the in-place option is used
    if args.in_place:
        del rootfile
        newrootfile.seek(0)
        shutil.copyfileobj(newrootfile, open(args.filename, 'wb'))

    newrootfile.close()
