#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# gBasf2 - http://b2comp.kek.jp/~twiki/bin/view/Computing/GBasf2
# gBasf2datasetrep is the script that replicates a dateset(a generated by gbasf2output) from its source SE
# to a destination SE.
#
# Wenjing Wu (wuwj@ihep.ac.cn) - 2011-07
#

# we require Amga tools from Polish devs for metadata
from AmgaClient import AmgaClient
from DIRAC.Core.Base import Script
import os
import sys
import glob
import getopt
import commands
from gbasf2util import CLIParams
import datetime
if os.environ.has_key('BELLE2_RELEASE'):
    cliParams.setSwVer(os.environ['BELLE2_RELEASE'])
# Script.parseCommandLine(ignoreErrors=True)
import DIRAC
from DIRAC.Core.Security.Misc import *
from DIRAC.Core.Security import Properties
# from DIRAC.ResourceStatusSystem.Utilities.CS import *
from DIRAC.ConfigurationSystem.Client.Config import gConfig
from DIRAC.FrameworkSystem.Client.ProxyGeneration import generateProxy
from DIRAC.FrameworkSystem.Client.ProxyManagerClient import ProxyManagerClient
from DIRAC.DataManagementSystem.Client.ReplicaManager import ReplicaManager
from DIRAC.DataManagementSystem.DB.FileCatalogComponents import FileManagerBase
# used for commandline and steeringfile option parsing


def get_dst_ses(repman, src_se):
    dst_ses = []
    ses = gConfig.getSections('/Resources/StorageElements')['Value']
        # ses.remove('SandboxSE')#this is used for old version of Dirac
    ses.remove('CentralSE')
    ses.remove('ProductionSandboxSE')
    selist = repman._getSEProximity(ses)
        # print selist
    for se in selist['Value']:
        if se not in src_se:
            dst_ses.append(se)
    return dst_ses


def ds_current_user():
    User = ''
    # Script.parseCommandLine(ignoreErrors=True)
    proxyinfo = getProxyInfo()
    if not proxyinfo['OK']:
        print 'getting proxy error!'
        DIRAC.exit(1)
    else:
        User = proxyinfo['Value']['username']
    return User


def ds_rep(entries, dstse):
      # setup dirac - import here because it pwns everything
    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    if entries is not None:
        repman = ReplicaManager()

    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        print 'lfn:', lfn
        cr_result = repman.getCatalogReplicas(lfn)
        if not cr_result['OK']:
            print 'No replicas are found for lfn ', lfn
            DIRAC.exit(1)
        else:
            if cr_result['Value']['Successful'].has_key(lfn):
                Suc_SEs = cr_result['Value']['Successful'][lfn]
                if Suc_SEs is not None:
                    src_ses = Suc_SEs.keys()
                    dst_ses = get_dst_ses(repman, src_ses)
                    print 'src_ses is ', src_ses, '\ndst_ses is ', dst_ses
                    if len(dst_ses) == 0:
                        print '%s already has replicas on every available SE,skip it' \
                            % lfn
                    else:
                        if dstse == '':
                            myse = dst_ses[0]
                        else:
                            if not dstse in dst_ses:
                                myse = dst_ses[0]
                                print '<%s> already has a replica, select a different SE <%s> instead' \
                                    % (dstse, myse)
                            else:
                                myse = dstse
                        print 'replicating %s on <%s>' % (lfn, myse)
                        cr_result = repman.replicateAndRegister(lfn, myse)
                        if not cr_result['OK']:
                            print 'Failed to replicate %s on <%s>' % (lfn,
                                    myse)
                            DIRAC.exit(1)
                        else:
                            print 'Successfully replicate %s on <%s> ' % (lfn,
                                    myse)
    return 0


def ds_del(entries, aclient):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    if entries is not None:
        repman = ReplicaManager()
    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        print 'lfn:', lfn
        cr_result = repman.removeFile(lfn)
        print cr_result
        if not cr_result['OK']:
            print 'Failed to remove Replicas of %s' % lfn
        else:
            # DIRAC.exit(1)
            print 'Successfully remove Replica of %s' % lfn
            alfn = entries[file][0]
            result = aclient.rm(alfn)
            if result is False:
                print 'Failed to remove AMGA entry ', alfn
            else:
                # DIRAC.exit(1)
                print 'Successfully remove AMGA entry ', alfn
        print 'Successfully remove File from dataset %s' % alfn
        dir = os.path.dirname(alfn)
    result = aclient.removeDir(dir)
    if result is False:
        print 'Failed to remove AMGA Directorya %s' % dir
    else:
        # DIRAC.exit(1)
        print 'Successfully remove dataset %s' % dir


def ds_get(entries, localpath, ow):
    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    if entries is not None:
        repman = ReplicaManager()
    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        print 'lfn: %s' % lfn
        filename = os.path.basename(lfn)
        local_file = localpath + '/' + filename
        ret = False
        if os.path.exists(local_file):
            if ow == 'c':
                ret = ds_cmp_file_csum(lfn, local_file)
            elif ow == 's':
                ret = ds_cmp_file_size(lfn, local_file)
        if not ret:
            print 'ds_get=>lfn:', lfn
            cr_result = repman.getFile(lfn, localpath)
            if not cr_result['OK']:
                print 'Failed to downloand %s to local dir %s' % (lfn,
                        localpath)
            else:
                # DIRAC.exit(1)
                Suc_lfn = cr_result['Value']['Successful'].keys()[0]
                Suc_local = cr_result['Value']['Successful'][Suc_lfn]
                print 'Successfully download file %s to %s' % (Suc_lfn,
                        Suc_local)


def ds_del_file_replica(lfn, SE):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    repman = ReplicaManager()
    cr_result = repman.removeReplica(SE, lfn)
    if not cr_result['OK']:
        print 'Failed to delete replica of %s at <%s>' % (lfn, SE)
        DIRAC.exit(1)
    else:
        print 'Successfully delete a replica of %s from <%s>' % (lfn, SE)


def ds_sync(entries):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    src_ses = []
    if entries is not None:
        repman = ReplicaManager()

    max_no = 0
    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        cr_result = repman.getReplicas(lfn)
                # print cr_result
        if not cr_result['OK']:
            print 'failed to getReplicas ', cr_result
            DIRAC.exit(1)
        else:
            if cr_result['Value']['Successful'].has_key(lfn):
                Suc_SEs = cr_result['Value']['Successful'][lfn]
                if Suc_SEs is not None:
                    src_ses = Suc_SEs.keys()
                    no = len(src_ses)
                    if no > max_no:
                        max_no = no
    print 'max replica of dataset is %d' % max_no
    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        cr_result = repman.getReplicas(lfn)
                # print cr_result
        if not cr_result['OK']:
            print 'failed to getReplicas ', cr_result
            DIRAC.exit(1)
        else:
            if cr_result['Value']['Successful'].has_key(lfn):
                Suc_SEs = cr_result['Value']['Successful'][lfn]
                if Suc_SEs is not None:
                    src_ses = Suc_SEs.keys()
                    no = len(src_ses)
                    if no < max_no:
                        need_no = max_no - no
                        print lfn, ' needs %d more replicas' % need_no
                        dst_ses = get_dst_ses(repman, src_ses)
                        for i in range(0, need_no):
                            print 'add replica at %s' % dst_ses[i]
                            cr_result = repman.replicateAndRegister(lfn,
                                    dst_ses[i])
                            if not cr_result['OK']:
                                print 'Failed to replicate %s on %s' % (lfn,
                                        dst_ses[i])
                                DIRAC.exit(1)
                            else:
                                print 'Successfully Replicate %s on %s ' \
                                    % (lfn, dst_ses[i])
                    else:
                        print lfn, ' has enough replicas, skip it'

    return 0


def ds_get_se_list():

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()
    repman = ReplicaManager()
    dst_se = get_dst_ses(repman, [])
    return dst_se


def ds_generate(ds_path, dst_se):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()
    repman = ReplicaManager()
    aclient = AmgaClient()
    entries = {}
    if aclient.checkDirectory(ds_path):
        if dst_se == '':
            dst_se = get_dst_ses(repman, [])[0]
            print 'no destination SE specified, choose a random SE ', dst_se
        print 'uploading dataset to ', dst_se
        for outfile in glob.glob('*.root'):
            lfn = ds_path + '/' + outfile
            if aclient.checkEntry(lfn):
                print lfn, 'is already registered in this dataset, skip it ...'
                continue
            else:
                GET_META_CMD = 'dirac-dms-lfn-metadata ' + lfn
                (s, o) = commands.getstatusoutput(GET_META_CMD)
                cr_result = eval(o)
                if cr_result['Successful'].has_key(lfn.replace('belle2',
                        'belle')):
                    print lfn, \
                        ' already exists in LFC, skip uploading, but register to AMGA...'
                    entries[outfile] = (['lfn'], [lfn])
                else:
                    print 'trying to upload the register ', lfn
                    cr_result = repman.putAndRegister(lfn.replace('belle2',
                            'belle'), outfile, dst_se)
                    if not cr_result['OK']:
                        print 'Failed to upload the register file ', lfn
                        DIRAC.exit(1)
                    else:
                        cr_result = cr_result['Value']['Successful'
                                ][lfn.replace('belle2', 'belle')]
                        entries[outfile] = (['lfn'], [lfn])

        if len(aclient.getAttributes(ds_path)[0]) == 0:
            aclient.prepareUserDataset(ds_path)
        if not aclient.bulkInsert(ds_path, entries):
            print 'Failed to Insert metadata for ', outfile
            DIRAC.exit(1)
    else:
        print 'Error with metadata path', ds_path
        DIRAC.exit(1)
    print 'Successfully Register dataset ', ds_path
    return 0


def ds_list_replica(entries, ListReplica, ListSite):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    src_ses = []
    if entries is not None:
        repman = ReplicaManager()

    ds_sites = {}
    ds_fno = 0
    for file in entries.keys():
        lfn = entries[file][0].replace('belle2', 'belle')
        cr_result = repman.getReplicas(lfn)
        # print cr_result
        if not cr_result['OK']:
            print 'failed to getReplicas ', cr_result
            DIRAC.exit(1)
        else:
            ds_fno += 1
            if cr_result['Value']['Successful'].has_key(lfn):
                Suc_SEs = cr_result['Value']['Successful'][lfn]
                if Suc_SEs is not None:
                    surls = Suc_SEs.values()
                    src_ses = Suc_SEs.keys()
                if ListSite:
                    for se in src_ses:
                        if not ds_sites.has_key(se):
                            files = [lfn]
                        else:
                            files = ds_sites[se]
                            files.append(lfn)
                        ds_sites[se] = files
                else:

                    print lfn, ': %d replicas' % len(surls)
                    for surl in surls:
                        print '\t', surl
            else:
                print lfn, ': Replica Missing'
    if ListSite:
        for se in ds_sites.keys():
            files = ds_sites[se]
            fno = len(files)
            print se, ':  (%d/%d) files' % (fno, ds_fno)
            for file in files:
                print '\t', file
    return 0


def ds_get_file_SE(lfn):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    src_ses = []
    repman = ReplicaManager()
    cr_result = repman.getReplicas(lfn)
    if not cr_result['OK']:
        print 'failed to getReplicas ', cr_result
        DIRAC.exit(1)
    else:
        if cr_result['Value']['Successful'].has_key(lfn):
            Suc_SEs = cr_result['Value']['Successful'][lfn]
            if Suc_SEs is not None:
                src_ses = Suc_SEs.keys()
    return src_ses


def ds_cmp_file_csum(lfn, local_file):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    GET_META_CMD = 'dirac-dms-lfn-metadata ' + lfn
    (s, o) = commands.getstatusoutput(GET_META_CMD)
    if s == 0:
        cr_result = eval(o)
        if cr_result['Successful'].has_key(lfn):
            csum_type = cr_result['Successful'][lfn]['CheckSumType']
            csum_value = cr_result['Successful'][lfn]['Checksum']
            if csum_type == 'AD':
                ad_value = ds_get_adler32(local_file)
                print 'checksum for %s is %s, checksum for %s is %s ' \
                    % (local_file, ad_value, lfn, csum_value),
                if ad_value == csum_value:
                    print 'checksum matches! Skip it '
                    return True
                else:

                    print 'checksum does not match!!! Re-download it... '
                    return False
        else:
            print 'No metadata found for ', lfn
            return False


def ds_get_adler32(file):
    import zlib
    READ_SIZE = 1000
    fd = open(file, 'r')
    fcont = fd.read(READ_SIZE)
    csum = 1
    while fcont:
        csum = zlib.adler32(fcont, csum)
        fcont = fd.read(READ_SIZE)
    csum = hex(csum).strip('0x')
    # print "csum is ",csum
    return csum


def ds_cmp_file_size(lfn, local_file):

    from DIRAC.Interfaces.API import Dirac
    dirac = Dirac.Dirac()
    Script.enableCS()

    GET_META_CMD = 'dirac-dms-lfn-metadata ' + lfn
    (s, o) = commands.getstatusoutput(GET_META_CMD)
    if s == 0:
        cr_result = eval(o)
        # print cr_result
        if cr_result['Successful'].has_key(lfn):
            lfn_size = int(cr_result['Successful'][lfn]['Size'])
            local_size = int(os.path.getsize(local_file))
            print 'size  for %s is %d, size for %s is %d ' % (local_file,
                    local_size, lfn, lfn_size),
            if lfn_size == local_size:
                print 'file size match! Skip it'
                return True
            else:
                print 'file size does not match!!! Re-download it... '
                return False
        else:
            print 'No metadata found for ', lfn
            return False


def main():

    (dspath, dstse) = get_ds_path()
    aclient = AmgaClient()
    entries = aclient.getAttributesValues(dspath, ['lfn'])
    src_ses = ds_list_replica(entries)
    ds_get(entries, '/tmp/')
    ds_rep(entries, dstse)
    src_ses = ds_list_replica(entries)
    print 'delete replica from ', src_ses[0]
    ds_del_replica(entries, src_ses[0])
    ds_del(entries, aclient)


    # ds_list_replica(entries)

if __name__ == '__main__':
    main()
