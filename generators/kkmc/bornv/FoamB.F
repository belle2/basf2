*///////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                       //
*//             Foam Version 2.02                                                         //
*//             November 2000                                                             //
*//                                                                                       //
*//  N-dimensional general purpose Monte Carlo sampler                                    //
*//  with the self-adapting simplical and hyper-cubical grid                              //
*//                                                                                       //
*//             Author:   Stanislaw JADACH                                                //
*//             Address:  INP Cracow, DESY-Zeuthen                                        //
*//             Email:    S.Jadach@cern.ch, S.Jadach@ifj.edu.pl                           //
*//             HomePage: http://home.cern.ch/jadach/                                     //
*//                                                                                       //
*//  First version 1.00 written by S.J. in May 1999 during visit in DESY                  //
*//        version 2.00 written by S.J. in Aug 2000 during visit in DESY-Zeuthen          //
*///////////////////////////////////////////////////////////////////////////////////////////


*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//          Pseudoclass Foam                                                                          //
*//                                                                                                    //
*//                                                                                                    //
*//                      Initialization of the grid                                                    //
*//  FoamB_PreInitialize                 : Pre-initialization, set all default values (constructor?)   //
*//  FoamB_Initialize(FunW)              : Initialization of the grid etc.                             //
*//  FoamB_InitVertices                  : Initializes first vertices of the basic cube                //
*//  FoamB_InitCells                     : Initializes first n-factorial cells inside original cube    //
*//  FoamB_DefCell                       : Create new (daughter) cell and append at end of the buffer  //
*//  FoamB_Explore(iCell,funW)           : Short MC sampling in iCell, determine <wt>, wtMax etc.      //
*//  FoamB_RanDiscr(Driv,nTot,Power,iRand) : Random choice of cell division direction                  //
*//  FoamB_MakeAlpha(Alpha)              : auxiliary procedure for FoamB_Explore                       //
*//  FoamB_MakeLambda(Lambda)            : auxiliary procedure for FoamB_Explore                       //
*//  FoamB_Determinant(R,Det)            : determinant of matrix R                                     //
*//  FoamB_Det2Lapl(R,i1,i2)             : Laplace formula for 1-dim. determinant                      //
*//  FoamB_Det3Lapl(R,i1,i2,i3)          : Laplace formula for 2-dim. determinant                      //
*//  FoamB_Det4Lapl(R,i1,i2,i3,i4)       : Laplace formula for 3-dim. determinant                      //
*//  FoamB_Det5Lapl(R,i1,i2,i3,i4,i5)    : Laplace formula for 4-dim. determinant                      //
*//  FoamB_Grow(funW)              : grow cells until buffer is full                                   //
*//  FoamB_PeekMax(iCell)          : choose randomly one cell, used also in MC generation              //
*//  FoamB_PeekRand1(iCell)        : Generates randomly one (active) cell pointer iCell                //
*//  FoamB_Divide(iCell,funW,RC)   :Divide iCell into two daughters; iCell retained, taged as inactive //
*//  FoamB_ActUpda                 : Creates list of active cells (pointers)                           //
*//                     Generation                                                                     //
*//  FoamB_MakeEvent(Density)      : Generates point/vector Xrand with the weight MCwt                 //
*//  FoamB_CellGener(Density)      : Cooses randomly one of active cells                               //
*//  FoamB_GetMCvector(MCvector)   : Provides point/vector MCvector generated by  MakeEvent            //
*//  FoamB_GetMCwt(MCwt)           : Provides MCwt, MC weight calculated by MakeEvent                  //
*//  FoamB_MCgenerate(funW,X,MCwt) : Alternative entry, Generates point X with the weight MCwt         //
*//                     Finalization                                                                   //
*//  FoamB_Finalize(MCresult,MCerror)    : Calculates integral and its error after (only from) MC run  //
*//                     Other Getters and Setters                                                      //
*//  MCellA_GetTotPrim(TotPrim)    :Provides Primary integral used in MC generation                    //
*//  FoamB_SetnDim(nDim)           :Sets no. of dimensions simplices   (to be called before Initialize)//
*//  FoamB_SetkDim(kDim)           :Sets no. of dimensions hypercubics (to be called before Initialize)//
*//  FoamB_GetnDim(nDim)           :Provides nDim, miscelaneous, for tests                             //
*//  FoamB_SetnBuf(nBuf)           :Sets nBuf, working area in buffer                                  //
*//  FoamB_SetnBin(nBin)           :Sets nBin, no of bins in histo in exploration <nBinMax=256         //
*//  FoamB_SetOut(Out)             :Sets output unit number                                            //
*//  FoamB_SetChat(Chat)           :Sets chat level; Chat=0,1,2 chat level in output, Chat=1 normal    //
*//  FoamB_SetnSampl(nSampl)       :Sets nSampl; No of MC sampling before dividing cell                //
*//  FoamB_SetOptDrive(OptDrive)   :Sets OptDrive; type of Drive =0,1,2 for True,Sigma,WtMax           //
*//  FoamB_SetOptPeek              :Sets type of method in cell division                               //
*//  FoamB_SetOptEdge(OptEdge)     :Sets OptEdge; decides whether vertices are included in the sampling//
*//  FoamB_SetOptRanIni(OptRanIni) :Sets OptRanIni=0,1, for rand. numb. initialization inside/outside  //
*//  FoamB_SetOptRanLux(OptRanLux) :Sets OptRanLux=-1,0,1,2,3 raand.numb.gen. level                    //
*//  FoamB_GetnCalls(nCalls)       :Get total no of function calls                                     //
*//                    Debugging and miscelaneous                                                      //
*//  FoamB_Check(mout,level)       :Checks all pointers (after comression) debuging!                   //
*//  FoamB_BufPrint(mout)          :Prints all cells, debugging                                        //
*//  FoamB_BufActPrint(mout)       :Prints all active cells, debugging                                 //
*//  FoamB_VertPrint(mout)         :Prints all vertices,  debugging                                    //
*//  FoamB_PltBegin                :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltVert(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltCell(mout)           :Ploting 2-dim. cells and vertices                                  //
*//  FoamB_PltEnd                  :Ploting 2-dim. cells and vertices                                  //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                                    //
*//  Input parameters:                                                                                 //
*//    nDim     number of dimensions for simplices, for the moment nDim=1-5 in this version,           //
*//             n>5 requires re-writing FoamB_Determinant,                                             //
*//    kDim     number of dimensions for hypercubics                                                   //
*//    Dimen    total number of dimensions = nDim +kDim                                                //
*//             for n=1 alternatively Foam1A may be used, could be factor 2 faster!                    //
*//    nBuf     Actual dynamic lenth of the buffer m_nBuf<m_nBufMax. For strongly peaked distribution  //
*//             nBuf should be as large as possible, this will increase CPU time in initialization     //
*//             MC generation is weakly affected by increasing nBuf                                    //
*//    nSampl   No of sampling when dividing cell, nSampl=10-100 is OK, further increase improves      //
*//             costs CPU time and apparently does not increase grid efficiency too much.              //
*//             This should be checked however for every new distribution.                             //
*//    OptDrive Type of Drive =0,1,2 for TrueInt,Sigma,WtMax,  Drive=WtMax is the best if we aim       //
*//             at rejection leading to wt=1 events. If not then Drive=Sigma iswiser choice leading    //
*//             to save of CPU time.  Simplistic Drive=Sigma is correct but not recommeneded (ineffic.)//
*//    OptEdge  decides whether vertices are included in the sampling. Default  OptEdge=1 causes that  //
*//             vertices at the edge of simplex cells are included always in MC exploration            //
*//             of the cell. In the case of density distrib. with weak integrable singularities        //
*//             at the edges it may be not possible and OptEdge=0 may help.                            //
*//    OptOrd decides whether the integration domain in simplical subspace is unit cube or simplex.    //
*//             It is active only for  nDim=2,3,4. For OptOrd=0 (default) the initial domain is unit   //
*//             hypercubic split into nDim! simplices in the initialization phase.                     //
*//             If m_OptOrd=1 then initial domain is simplex and the integration variables providede   //
*//             by FoamB_GetMCvector(V) are ordered: V(1)<V(2)<...<V(nDim)<1.                          //
*//             Hyp-cubical variables  0<V(nDim+1), V(nDim+2),...,V(nDim+kDim)<1 are never ordered.    //
*//    EvPerBin Limit on effective number of eevents per bin in exploration phase. This option saves   //
*//             considerably CPU time.      =0 option is desabled, recommended value is >20.           //
*//    Out      Miscelaneous. Output unit number.                                                      //
*//    Chat     Miscelaneous. Chat=0,1,2 chat level in output, Chat=1 normal level.                    //
*//                                                                                                    //
*//                                                                                                    //
*////////////////////////////////////////////////////////////////////////////////////////////////////////
*//  Terminology:                                                                                      //
*//    "Active cells" are these which did not divide and are eligible for division                     //
*//  Remarks:                                                                                          //
*//    List of active cells is not realy necessary, but let us keep it for possible                    //
*//    future developements or tests.                                                                  //
*////////////////////////////////////////////////////////////////////////////////////////////////////////


      SUBROUTINE FoamB_PreInitialize     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Presets certain defaults for switches and other and regualtory parameters.     //
*//   They Can be reset with setters                                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER i,j
*
      INTEGER   m_Magic        ! Magic cookie, to avoid multiple initialization
      DATA      m_Magic /378231178/
      SAVE      m_Magic
*     -------------------------------------------------
      IF(m_Magic .EQ. 378231178 ) THEN
         m_MagicInit = m_Magic
         m_Magic     = 0
      ENDIF
      IF(m_MagicInit .NE. 378231178 ) RETURN
      WRITE(m_out,*) '===============FoamB_PreInitialize=============='
      m_MagicInit= 0
      m_nDim     = 0                 ! dimension siplices
      m_kDim     = 0                 ! dimension hypercubics
      m_Dimen    = m_nDim+m_kDim     ! dimension total
      m_nBuf     = 1000              ! Actual dynamic lenth of the buffer m_nBuf<m_nBufMax
      m_nBin     = 8                 ! No of bins in cell exploration/division  <nBinMax  
      m_nSampl   = 200               ! No of sampling when dividing cell
      m_OptDrive = 2                 ! type of Drive =0,1,2 for TrueVol,Sigma,WtMax
      m_OptEdge  = 0                 ! decides whether vertices are included in the sampling
      m_OptPeek  = 0                 ! type of Peek =0,1 for maximum, random
      m_Out      = 6                 ! Output unit
      m_Chat     = 1                 ! Chat=0,1,2 chat level in output, Chat=1 normal level
      m_OptOrd   = 0                 ! Entire integr domain is hyp-cubic if =0 and simplex if =1
      m_EvPerBin = 25                ! Upper limit on eevents/bin in exploration, =0 disabled 
      m_OptRanIni= 1                 ! Rand.num. generator initialized (=1) inside PianA
      m_OptRanLux= 3                 ! Rand.num. generator level (-1 for PseuMar)
*
      m_LastCe   = 0                 ! length of dynamical buffor for cells
      m_LastVe   = 0                 ! length of dynamical buffor for vertices
* Clean up list of simplical vertices
      DO i=1,m_vMax
         DO j=1,m_nDim
            m_VerX(i,j) = 0d0        ! vertices
         ENDDO
      ENDDO
* Clean up hypercubic parameters
      DO i=1,m_nBufMax
         DO j=1,m_KdiMax
            m_CeVer1(i,j)=0d0        ! hcubic position
            m_CeVer2(i,j)=0d0        ! hcubic size
         ENDDO
      ENDDO
*
      m_nCalls   = 0                 ! No of function calls
*
      END

      SUBROUTINE FoamB_Flush        !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Use this before re-initialization of the Foam                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      m_MagicInit = 378231178   ! Reset Magic cookie, alowing initialization
      WRITE(m_out,*) '===============FoamB_Flush=============='
      CALL FoamB_PreInitialize
      END

      SUBROUTINE FoamB_Initialize(FunW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Basic initialization, create "foam of cells"                                   //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,j,k,iCell,kCell
      DOUBLE PRECISION   TotPrim
*---------------------------------------------
      CALL FoamB_PreInitialize
* User may prefers to initialize r.n.gen. by himsef, the initialization below can be inhibited 
      IF( m_OptRanIni.EQ. 1 ) THEN
         IF(m_OptRanLux.EQ.-1) THEN
            CALL PseuMar_Initialize(54217137, 0, 0) ! Initialization of random number generator
         ELSEIF(m_OptRanLux.GE.0 .AND. m_OptRanLux.LE.4 ) THEN
            CALL RLUXGO( m_OptRanLux, 54217137,0,0) ! Initialization of random number generator
         ELSE
            WRITE(*,    *) ' ### STOP in FoamB_Initialize, wrong OptRanLux =',m_OptRanLux !
            WRITE(m_Out,*) ' ### STOP in FoamB_Initialize, wrong OptRanLux =',m_OptRanLux !
         ENDIF
      ENDIF
      IF( (m_nBuf .GT. m_nBufMax) .OR. (m_nBuf .LE. 0) ) THEN
         WRITE(*,    *) ' ### STOP in FoamB_Initialize, wrong m_nBuf =',m_nBuf !
         WRITE(m_Out,*) ' ### STOP in FoamB_Initialize, wrong m_nBuf =',m_nBuf !
         STOP
      ENDIF
      IF( (m_nBin .GT. m_nBinMax) .OR. (m_nBin .LE. 0) ) THEN
         WRITE(*,    *) ' ### STOP in PianA_Initialize, wrong m_nBin =',m_nBin !
         WRITE(m_Out,*) ' ### STOP in PianA_Initialize, wrong m_nBin =',m_nBin !
         STOP
      ENDIF
      IF( m_Dimen .LE. 0 ) THEN
         WRITE(*,    *) ' ### STOP in FoamB_Initialize, wrong m_Dimen =',m_Dimen !
         WRITE(m_Out,*) ' ### STOP in FoamB_Initialize, wrong m_Dimen =',m_Dimen !
         STOP
      ENDIF
* First  cells are the (nDim)! simplices from division of the basic unit cube
      CALL FoamB_InitVertices
      CALL FoamB_InitCells(funW)

***** CALL FoamB_VertPrint(6)   ! debug
***** CALL FoamB_BufPrint(6)    ! debug

      CALL  FoamB_Grow(funW)
* Update list of active cells, only for internal tests
      CALL FoamB_ActUpda
      CALL FoamB_Check(6,0)     ! Check if the liked list is OK
* --------------------------------------------------------------------------------------------
      IF( m_Chat.GE.1) THEN
         WRITE(m_Out,'( 3(a,i4),2(a,g15.8) )') 
     $      'Foam_Initialize:  No. Cells=',m_LastCe,'  Active=',m_LastAc, '  No. Vertices=' ,m_LastVe, !
     $      '  True Integ.=',m_CeIntg(1),'  Driver Integ.=',m_CeDriv(1)  !
      ENDIF
      IF( m_Chat.EQ.2) THEN
         CALL FoamB_BufPrint(    m_Out)
         CALL FoamB_BufActPrint( m_Out)
         CALL FoamB_VertPrint(   m_Out)
      ENDIF
* Initializations for M.C. generation
      m_Drive  = m_CeDriv(1)  ! M.C. generation Drive value of integral
      m_SumWt  = 0d0          ! M.C. generation sum of Wt
      m_SumWt2 = 0d0          ! M.C. generation sum of Wt**2
      m_NevGen  = 0d0         ! M.C. generation sum of 1d0
      m_WtMax  = -1d99        ! M.C. generation maximum wt
      m_WtMin  =  1d99        ! M.C. generation minimum wt
      m_VolTot = m_CeIntg(1)  ! Estimate of integral tot. without error
      m_MCresult = m_VolTot   ! M.C. generation Final value of ITEGRAL, temporary asignment
      m_MCerror  = m_VolTot   ! M.C. generation Final walue of ERROR  , temporary asignment
*
*((((((((((((################################################################################
*((((((((((((################################################################################
c      CALL FoamB_VertPrint(  6)
c      CALL FoamB_BufPrint(   6)
c      CALL FoamB_BufActPrint(6)
c      CALL FoamB_Check(      6,0)
c      WRITE(*,*) ' ########### STOP ########### developement not finished @@@@' !
c      STOP
*))))))))))))################################################################################
*))))))))))))################################################################################
*
* Cumulative Primary for MC generation, see FoamB_CellGener
      CALL FoamB_ActUpda
      TotPrim = 0d0
      m_CePrCu(0)= 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         TotPrim = TotPrim +m_CePrim( iCell )
         m_CePrCu(kCell)=TotPrim
      ENDDO
* ----------------------------------------------------
      IF( m_Chat.GE.1) WRITE(m_Out,'( 2(a,g15.8) )')
     $     'Foam_Initialize:  TotPrimary =',TotPrim,'   True/Primary =', m_CeIntg(1)/TotPrim
      END                       ! FoamB_Initialize

      SUBROUTINE FoamB_InitVertices    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   In siplical subspace initialize 2^nDim vertices at corners of basic hyper-cube //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER       iVe,i,j,l,digit( m_NdiMax)
*
      IF( m_OptOrd .EQ.0) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*// Here we have all vertices of the initial unit hypercube
*// like (0000),(1000),(0100),(1100),(0010)...(1111)
         m_LastVe = 2**m_nDim
         DO i=1,m_nDim
            digit(i)=0
         ENDDO
         DO iVe=1,m_LastVe
*****    WRITE(*,'(a,i5,a,10i5)') 'iVe=', iVe, '  digit=',(digit(j),j=1,m_nDim)
            DO i=1,m_nDim
               m_VerX(iVe,i) = digit(i) ! Simplical vertex positions
            ENDDO
            digit(1)=digit(1)+1         ! Basic increment
            DO i=1,m_nDim-1
               IF(digit(i).EQ.2) THEN   ! Overflow goes to higher digits
                  digit(i)=0
                  digit(i+1)=digit(i+1)+1
               ENDIF
            ENDDO
         ENDDO
      ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*// Here we have only vertices of the SINGLE  INITIAL SIMPLEX 
*// like (0000),(1000),(1110),(1111)
         m_LastVe = m_nDim+1
         DO iVe=1,m_LastVe
            DO i=1,m_nDim
               m_VerX(iVe,i) =0
               IF(i.LT.iVe) m_VerX(iVe,i) =1  ! Simplical vertex positions
            ENDDO
*****       WRITE(*,'(a,i5,a,10f5.0)') 'iVe=', iVe, '  m_VerX=',(m_VerX(iVe,i),i=1,m_nDim)!
         ENDDO
      ENDIF
      END                       !! FoamB_InitVertices

      SUBROUTINE FoamB_InitCells(funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Initialize first n-factorial cells inside original cube                        //
*//   MC exploration done for all newly defined cells                                //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            perm(m_NdiMax),mask,iCeNew,iCell
      INTEGER            iCe,i,j,k,iVe,Vert(m_NdiMax+1),digit(m_NdiMax),factorial,NoMC !
      DOUBLE PRECISION   HcPosi(m_KdiMax),   HcSize(m_KdiMax)
*     -----------------------------------------------------------------------------
      DO j=1,m_kDim
         HcPosi(j)=0d0
         HcSize(j)=1d0
      ENDDO
      DO iVe=1,m_nDim+1
         Vert(iVe) =0
      ENDDO
      IF( m_nDim .EQ. 0 ) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//      Only hypercubics, no simplices                                              //
*//////////////////////////////////////////////////////////////////////////////////////
*        ROOT cell ACTIVE, no daughters
         NoMC= m_nSampl
*        -------------------- Stat,Pare, Dau1, Dau2, MCsampl,VertList, Position,Size,   iCeNew)
         CALL FoamB_DefCell(     1,  -1,   -1,   -1,    NoMC,   Vert, HcPosi,  HcSize, iCeNew) !
         CALL FoamB_Explore(iCeNew,funW) ! Initial MC sampling
      ELSEIF( m_nDim .EQ. 1 ) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//      Simplical algorithm in one dimension                                        //
*//////////////////////////////////////////////////////////////////////////////////////
         Vert(1) =1
         Vert(2) =2
*        ROOT cell ACTIVE, no daughters
*        -------------------- Stat,Pare, Dau1, Dau2,  MCsampl,VertList, Position,Size,   iCeNew
         CALL FoamB_DefCell(     1,  -1,   -1,   -1, m_nSampl,    Vert, HcPosi,  HcSize, iCeNew) !
         CALL FoamB_Explore(iCeNew,funW) ! Initial MC sampling
      ELSE
         IF( m_OptOrd .EQ.0) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//      (nDim)! Simplices in more two and more dimensions                           //
*//////////////////////////////////////////////////////////////////////////////////////
            factorial=1
            DO k = 1,m_nDim
               factorial = factorial*k
            ENDDO
*           ROOT cell INACTIVE, (nDim)! daugter cells defined below
*           ----------------- Stat,Pare, Dau1,        Dau2,  MCsampl, VertList, Position,Size,   iCeNew)
            CALL FoamB_DefCell( -1,  -1,    2, factorial+1, m_nSampl,     Vert, HcPosi,  HcSize, iCeNew) !
* ================================================================
* START OF LOOP OVER permutations of (1,2,3,...,m_nDim)
            iCe=0
            DO i=1,m_nDim
               perm(i)=m_nDim
            ENDDO
 300        CONTINUE
            perm(1)=perm(1)-1
            DO k = 1,m_nDim-1
               IF(perm(k).EQ.0) THEN
                  perm(k)=m_nDim
                  perm(k+1)=perm(k+1)-1
               ENDIF
            ENDDO
            Mask=1
            DO i=1,m_nDim
               DO j=i+1,m_nDim
                  IF( perm(i).EQ.perm(j) ) Mask=0
               ENDDO
            ENDDO
            IF(Mask.EQ.1) THEN
*           At this point NEW PERMUTATION is found !!!
               iCe=iCe+1
               DO iVe=1,m_nDim+1
*              This digit represents single BASIC SIMPLEX, other obtained by permuting dimensions
                  DO k=1,m_nDim
                     digit(k)=0
                     IF(k.LT.iVe) digit(k)=1
                  ENDDO
*                 Translation from "binary" digit to serial pointer of a given vertex
                  j=0
                  DO k=1,m_nDim
                     j=j+  digit(perm(k)) *2**(k-1)
                  ENDDO
                  Vert(iVe)=j+1
               ENDDO
*****    WRITE(*,*) '########>>>>>>> iCe =',iCe, 'permut= ',(perm(i),i=1,m_nDim)
*****    WRITE(*,*) '########>>>>>>> Vert= ',(vert(i),i=1,m_nDim+1)
*              Define ACTIVE simplical cell
*              ----------------- Stat,Pare,Dau1,Dau2,  MCsampl,VertList, Position,Size,   iCeNew
               CALL FoamB_DefCell(  1,   1,  -1,  -1, m_nSampl,    Vert, HcPosi,  HcSize, iCeNew) !
*              ---------------------------------------------------------------------
               IF( iCe.EQ.factorial) GOTO 100 ! Last permutation found
            ENDIF
            GOTO 300            ! END OF LOOP over permutations
* ================================================================
 100        CONTINUE
            DO iCell = 2,m_LastCe
               CALL FoamB_Explore(iCell,funW) ! Initial MC sampling, necessarily in a separate loop
            ENDDO
         ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*//      Single initial simplex in two or more dimension (ordered integr. variables) //
*//////////////////////////////////////////////////////////////////////////////////////
            DO k = 1,m_nDim+1
               Vert(k) =k
            ENDDO
*           ROOT cell ACTIVE, no daughters
*           -------------------- Stat,Pare, Dau1, Dau2,  MCsampl, VertList, Position,Size,    iCeNew)
            CALL FoamB_DefCell(     1,  -1,   -1,   -1, m_nSampl,     Vert, HcPosi,  HcSize,  iCeNew) !
            CALL FoamB_Explore(iCeNew,funW) ! Initial MC sampling
         ENDIF  ! m_OptOrd
      ENDIF  ! m_nDim
      END                       !!!FoamB_InitCells

      SUBROUTINE FoamB_DefCell(Stat,Pare,Dau1,Dau2,NoMC,Vertex,HcPosi,HcSize,iCeNew)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create new (daughter) cell and append it at the very end of the buffer         //
*//   iCeNew is pointer of the new cell                                              //
*//   Note clever trick: volume of this daughter is assigned initialy half volume    //
*//   of the parent, if parent exists.                                               //
*//   In Explore this value is used to update all parents such that                  //
*//   in the entrire tree parents have volume being sum of all daughter volumes.     //
*//   This summation discipline is useful for MC generation of an active cell by     //
*//   going randomly from top to bottom of the tree.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            Stat,Pare,Dau1,Dau2,iCeNew,k,NoMC
      INTEGER            Vertex(m_NdiMax+1)
      DOUBLE PRECISION   HcPosi(m_KdiMax), HcSize(m_KdiMax)
*     ------------------------------------------------------------------
      IF( m_LastCe .EQ. m_nBuf) THEN
         WRITE(*,*) ' STOP in FoamB_DefCell: something wrong with m_nBuf=',m_nBuf !
         STOP
      ENDIF
      m_LastCe = m_LastCe+1
      iCeNew   = m_LastCe
      m_CeStat(iCeNew)= Stat                    ! status code, =0 inactive, =1 active
      m_CePare(iCeNew)= Pare                    ! parent cell pointer
      m_CeDau1(iCeNew)= Dau1                    ! daughter1 cell pointer
      m_CeDau2(iCeNew)= Dau2                    ! daughter2 cell pointer
      m_CeSamp(iCeNew)= NoMC                    ! No of MC events in exploration
      m_CeBest(iCeNew)= -1                      ! pointer for planning division of the cell
      m_CeXave(iCeNew)= 0.5d0                   ! factor for division
*  simplical subspace: vertex list
      DO k=1,m_NdiMax+1
         m_CeVert(iCeNew,k)= Vertex(k)
      ENDDO
*  hypercubical subspace: position and size
      DO k=1,m_kDim
         m_CeVer1(iCeNew,k) = HcPosi(k)
         m_CeVer2(iCeNew,k) = HcSize(k)
      ENDDO
*
      IF(Pare.NE.-1) THEN
         m_CeIntg(iCeNew)= m_CeIntg(Pare)/2d0   ! integr. half of parent
         m_CeDriv(iCeNew)= m_CeDriv(Pare)/2d0   ! integr. half of parent
      ELSE
         m_CeIntg(iCeNew)= 0d0
         m_CeDriv(iCeNew)= 0d0
      ENDIF
      m_CeVolu(iCeNew)= 0d0                     ! cartesian Volume   
      END                       ! FoamB_DefCell


      SUBROUTINE FoamB_Explore(iCell,funW)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Explore newly defined cell with help of special short MC sampling              //
*//   As a result, estimetes of true and Drive volume will be defined                //
*//   Average and dispersion of the weight distribution will be found along each     //
*//   edge and the best edge (minimum dispersion) is memorized for future use.       //
*//   Axerage x for eventual future cell division is also defined.                   //
*//   Recorded are aso minimum and maximu weight etc.                                //
*//   The volume estimate in all (inactive) parent cells is updated                  //
*//   Note that links to parents and initial volume = 1/2 parent has to be           //
*//   already defined prior to calling this routine.                                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell
* Simplical subspace
      DOUBLE PRECISION   Vec(m_NdiMax+1,m_NdiMax)
      DOUBLE PRECISION   Xre(m_NdiMax,  m_NdiMax), Yre(m_NdiMax,  m_NdiMax) !
      DOUBLE PRECISION   Lambda(m_NdiMax),VolPart(m_NdiMax+1)
* Hyper-Cubic subspace
      DOUBLE PRECISION   Alpha( m_KdiMax)
      INTEGER            digit( m_KdiMax)
* Total space
      DOUBLE PRECISION   Vrand( m_DimMax)
* Edge sampling working space, matrices
      DOUBLE PRECISION   Xdivi(m_NdiviMax)
      DOUBLE PRECISION   Histo(m_NdiviMax,m_nBinMax),Xsu1(m_NdiviMax),Xsu2(m_NdiviMax) !
*--------
      INTEGER            loop,i,j,k,parent,iv,jv,kv,nEdges,kBest,iBin,nDivi,NevEff !
      DOUBLE PRECISION   x,x1,x2,Wt,Vsum,xBest,yBest
      DOUBLE PRECISION   Det,VolOld, DriOld, XrSum,Factorial
      DOUBLE PRECISION   Dx,DxHc,DxSp,DxPartial,NoMC
      DOUBLE PRECISION   funW
      EXTERNAL           funW
*-----------------------------------------------------------------------
* memorize old values, will be needed for correcting parent cells
      VolOld = m_CeIntg(iCell)
      DriOld = m_CeDriv(iCell)
*
      Factorial=1
      DO i=1,m_nDim
         Factorial=Factorial*i
      ENDDO
      DxSp=1d0          ! Cartesian volume of the simplex
      DxHc=1d0          ! Cartesian volume of the hypercube
*
      IF( m_nDim.GT.0) THEN
         DO iv=1,m_nDim+1
            DO j=1,m_nDim
               Vec(iv,j) = m_VerX( m_CeVert(iCell,iv) ,j) ! decode vertex vectors
            ENDDO
         ENDDO
         DO iv=1,m_nDim
            DO j=1,m_nDim
               Xre(iv,j) = Vec(iv,j)-Vec(m_nDim+1,j) ! relative to last vertex
            ENDDO
         ENDDO
         CALL FoamB_Determinant(Xre,Det)
         IF(Det.EQ.0d0) WRITE(*,*) '!!!!! WARNING: Determinant=',Det
         DxSp = DxSp*ABS(Det)/Factorial       ! Simplical Cartesian volume of the Cell
      ENDIF
      IF( m_kDim.GT.0) THEN
         DO i=1,m_kDim
            DxHc = DxHc*m_CeVer2(iCell,i) ! Product of sizes in hypercubical subspace
         ENDDO
      ENDIF
      Dx=DxSp*DxHc              ! Total cartesian volume
      m_CeVolu(iCell)  = Dx
c[[[[[[[[[[[[[[[
c      DO iv=1,m_nDim
c          WRITE(*,'(a,9f10.5)') '### Xre=',(Xre(iv,j),j=1,m_nDim)
c      ENDDO
c      WRITE(*,'(a,f12.6)') 'FoamB_Explore: Cartesian volume Dx =',Dx
c]]]]]]]]]]]]]]]

*/////////////////////////////////////////////////////
*//    Exploratory MC sampling to probe the cell    //
*/////////////////////////////////////////////////////
      m_CeSum(iCell,1) =  0
      m_CeSum(iCell,2) =  0
      m_CeSum(iCell,3) =  0
      m_CeSum(iCell,4) =  1d90  ! wtmin
      m_CeSum(iCell,5) = -1d90  ! wtmax
      DO k=1,m_NdiviMax
         Xsu1(k)=0d0
         Xsu2(k)=0d0
         DO iBin=1,m_nBin
            Histo(k,iBin)=0d0
         ENDDO
      ENDDO
*///////////////////////////////////////////////////////////////////////////////////
*     Additional scan over vertices in order to improve max/min weights
*     Note that this option adds 2**m_kDim of the function calls, limited to 1000!
      IF( m_OptEdge .EQ. 1 ) THEN
         DO k=1,m_kDim
            digit(k)=0          ! initialize first partitions
         ENDDO
         DO loop=1,1000         ! start of loop over partitions
            DO iv=1,m_nDim+1
               DO j=1,m_nDim
                  Vrand(j) = m_VerX( m_CeVert(iCell,iv) ,j) ! simplical subspace
               ENDDO
               DO j=1,m_kDim
                  Vrand(m_nDim+j) = m_CeVer1(iCell,j) + digit(j)*m_CeVer2(iCell,j) ! h-cubical subspace
               ENDDO
               Wt =funW(Vrand)*Dx ! weight average normalised to integral over the cell
               m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
               m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
            ENDDO
            digit(1)=digit(1)+1
            DO k=1,m_kDim-1
               IF(digit(k).EQ.2) THEN
                  digit(k)=0
                  digit(k+1)=digit(k+1)+1
               ENDIF
            ENDDO
            IF( m_kDim .EQ.0 )      GOTO 122
            IF( digit(m_kDim).EQ.2) GOTO 122
         ENDDO                  ! end of loop over partitions
 122     CONTINUE
      ENDIF
*///////////////////////////////////////////////////////////////////////////////////
*     generate randomly/uniformly vector Vrand inside this simplex&hypercube
      DO i=1,m_CeSamp(iCell)
         CALL FoamB_MakeLambda(Lambda)
         CALL FoamB_MakeAlpha( Alpha)
         DO j=1,m_nDim
            Vrand(j) = Vec(m_nDim+1,j)
            DO iv=1,m_nDim
               Vrand(j) = Vrand(j) +Lambda(iv)*Xre(iv,j) ! simplical subspace
            ENDDO
         ENDDO
         DO j=1,m_kDim
            Vrand(m_nDim+j) = m_CeVer1(iCell,j) +Alpha(j)*m_CeVer2(iCell,j) ! hypcubic subspace
         ENDDO
****     WRITE(*,'(a,6f12.6)') ' Lambda    =',(Lambda(k),k=1,m_nDim)
****     WRITE(*,'(a,6f12.6)') ' Alpha     =',(Alpha(k), k=1,m_kDim)
****     WRITE(*,'(a,6f12.6)') ' Vrand     =',(Vrand(k), k=1,m_Dimen)
*///////////////////////////////////////////////////////////////////////////////////
* Projecting on all simplex edges, preparatory step, partial volumes etc.
         IF( m_nDim .GT. 0 ) THEN
            Vsum=0d0
            DO jv=1,m_nDim+1    ! vertex jv will be replaced with Vrand
               kv=0             ! kv numbers all verices axcept jv
               DO iv=1,m_nDim+1
                  IF(iv.NE.jv) THEN
                     kv=kv+1
                     DO j=1,m_nDim
                        Yre(kv,j) = Vec(iv,j)-Vrand(j) ! All vertices except jv relative to Vrand
                     ENDDO
                  ENDIF
               ENDDO
               CALL FoamB_Determinant(Yre,DxPartial)
               VolPart(jv) = ABS(DxPartial)/Factorial
               Vsum=Vsum + VolPart(jv)
            ENDDO
            IF( ABS(Vsum-DxSp)/DxSp .GT. 1d-5) GOTO 950 ! X-check
         ENDIF
*------------------------------------------------------------------------------------
* IMPORTANT! Two Loops below determine the indexing of edges (simplex and hypercube)
*------------------------------------------------------------------------------------
         nEdges=0
         DO jv=1,m_nDim+1
            DO iv=jv+1,m_nDim+1
               nEdges=nEdges+1
               Xdivi(nEdges) = VolPart(jv) / ( VolPart(jv)+VolPart(iv) )
            ENDDO
         ENDDO
         DO j=1,m_kDim
            nEdges=nEdges+1
            Xdivi(nEdges) = Alpha(j)
         ENDDO
*///////////////////////////////////////////////////////////////////////////////////
         Wt =funW(Vrand)*Dx  ! principal weight normalised to integral over the cell
*------------------------------------------------------------------------------------
         m_nCalls = m_nCalls+1
         m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt         ! sum of weights
         m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt      ! sum of weights squared
         m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0        ! sum of 1
         m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt)    ! minium weight
         m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt)    ! maximu weight
* Search for the best edge candidate for future cell division, prepare MC material
         Ndivi  = (m_nDim+1)*m_nDim/2 +m_kDim
         IF(nEdges.NE.nDivi) GOTO 970
         DO k=1,nDivi
            Xsu1(k)=Xsu1(k) +Xdivi(k)*Wt                 ! averages for all Xdivi
            Xsu2(k)=Xsu2(k) +Xdivi(k)**2*Wt
            iBin = INT(Xdivi(k)*m_nBin)+1d0
            iBin = MIN(MAX(iBin,0),m_nBin)
            Histo(k,iBin) = Histo(k,iBin)+Wt             ! fill histo for each edge
c[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
c            IF(iCell.EQ.4) THEN
c               CALL GLK_Fil1(1200+k, Xdivi(k),Wt)
c            ENDIF
c]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
         ENDDO
         IF( m_EvPerBin.GT.0 ) THEN
            NevEff = m_CeSum(iCell,1)**2/m_CeSum(iCell,2)
            IF( NevEff .GE. m_nBin*m_EvPerBin) GOTO 222 !
         ENDIF
      ENDDO
 222  CONTINUE
*///////////////////////////////////////////////////////
*//   End of Special Short MC sampling to probe cell  //
*///////////////////////////////////////////////////////


*//////////////////////////////////////////////////////////////////////////////////////
*//  Determine the best edge candidate for future cell division, 
*//  using MC  material in Histo,Xsu1,Xsu2
*//  kBest,xBest,yBest are the output results
      CALL FoamB_Carver(iCell,Histo,Xsu1,Xsu2,kBest,xBest,yBest)
*//////////////////////////////////////////////////////////////////////////////////////
      NoMC =m_CeSum(iCell,3)
      IF( m_CeSum(iCell,1) .LT.0d0) GOTO 920
      m_CeXave(iCell)  = xBest                      ! best lambda for future division
      m_CeBest(iCell)  = kBest                      ! best edge for future division
      m_CeIntg(iCell)  = m_CeSum(iCell,1)/NoMC      ! estimator of the true integral
*!!!!!!!!!  DrivE is for the Foam build-up (not for MC generation)    !!!!!!!!!!
*!!!!!!!!!  PRIMARY is for MC generation (not for the Foam build-up ) !!!!!!!!!!
      IF(     m_OptDrive.EQ.0 ) THEN
         m_CePrim(iCell) = m_CeIntg(iCell)                   ! True integral, MC generation
         m_CeDriv(iCell) = m_CeIntg(iCell)                   ! True integral, Foam build-up
      ELSEIF( m_OptDrive.EQ.1 ) THEN
         m_CePrim(iCell) = DSQRT(m_CeSum(iCell,2)/NoMC)      ! Sqrt( <w>**2 + sigma**2 )= Sqrt(<w**2>)
         m_CeDriv(iCell) = DSQRT(m_CeSum(iCell,2)/NoMC -m_CeIntg(iCell)**2) ! sigma =Sqrt(<w**2>-<w>**2)
      ELSEIF( m_OptDrive.EQ.2 ) THEN
         m_CePrim(iCell) = m_CeSum(iCell,5)                  ! wtmax    , MC generation
         m_CeDriv(iCell) = m_CeSum(iCell,5) -m_CeIntg(iCell) ! wtmax-<w>, Foam build-up
      ELSE
         WRITE(m_out,*) ' ++++ STOP in FoamB_Explore, wrong m_OptDrive =',m_OptDrive !
         WRITE(    *,*) ' ++++ STOP in FoamB_Explore, wrong m_OptDrive =',m_OptDrive !
         STOP
      ENDIF
* correct volume and Drive in all parent cells to the top of the tree
      parent = m_CePare(iCell)
      DO i = 1,m_nBuf
         IF( parent .EQ. -1 ) GOTO 100 ! Exit if no parent exists
         m_CeIntg(parent)  = m_CeIntg(parent)  +( m_CeIntg(iCell)  -VolOld) !
         m_CeDriv(parent)  = m_CeDriv(parent)  +( m_CeDriv(iCell)  -DriOld) !
         parent=m_CePare(parent)
      ENDDO
 100  CONTINUE
      RETURN
 920  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with integrand ' !
      STOP
 950  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with volume calculation ' !
      WRITE(*,*) ' Vsum,DxSp= ',Vsum,DxSp
      STOP
 960  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with best pair pointer =',kBest !
      STOP
 970  WRITE(*,*) ' ### STOP in FoamB_Explore: something wrong with Ndivi =',nDivi !
      STOP
      END                       ! FoamB_Explore



      SUBROUTINE FoamB_Carver(iCell,Histo,Xsu1,Xsu2,kBest,xBest,yBest)  !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*// Determine the best edge candidate for future cell division, using MC  material   //
*// kBest is the best edge found, xBest and yBest are the best values of lambda      //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell,kBest
      DOUBLE PRECISION   xBest,yBest,zBest
      DOUBLE PRECISION   Histo(m_NdiviMax,m_nBinMax), Xsu1(m_NdiviMax), Xsu2(m_NdiviMax) !
      DOUBLE PRECISION   Bins(m_nBinMax)
      INTEGER            i,j,k, iBin, nDivi
      INTEGER            iUp,iLow, jUp,jLow, kDivi, jv,iv, jDivi
      DOUBLE PRECISION   SumWt,BinMax,This, Carve, yLevel
      DOUBLE PRECISION   CarvOne,CarvTwo,CarvMax
*
      kBest =1
      xBest =0.5d0
      yBest =1d0
      SumWt  = m_CeSum(iCell,1)
      IF( SumWt .NE. 0d0) THEN
         CarvMax = -1d150
         nDivi  = (m_nDim+1)*m_nDim/2 +m_kDim
         DO kDivi=1,nDivi
            BinMax  = -1d150
            DO iBin=1,m_nBin    ! Unload histo and Maximum bin
               Bins(iBin) = Histo(kDivi,iBin)
               BinMax = MAX( BinMax, Bins(iBin)) ! Maximum content/bin
            ENDDO
            CarvTwo = 0d0
            DO iBin=1,m_nBin
               Bins(iBin) = Bins(iBin)/BinMax ! Normalize to the highest bin
               CarvTwo = CarvTwo + (1d0-Bins(iBin))/m_nBin ! Total carve
            ENDDO
* Find maximum 'rectangular carve' in betwen the two bins (jLow,...,jUp)
            jLow =1
            jUp  =m_nBin
            CarvOne = -1d150
            yLevel  = -1d150
            DO iBin=1,m_nBin
               This = Bins(iBin)
               iLow = iBin
               DO j=iBin,1,-1   ! walk to the left and find first bin > current
                  IF(This .LT. Bins(j) ) GOTO 100
                  iLow = j
               ENDDO
 100           CONTINUE
               iUp  = iBin
               DO j=iBin,m_nBin ! walk to the right and find first bin > current
                  IF(This .LT. Bins(j) ) GOTO 200
                  iUp  = j
               ENDDO
 200           CONTINUE
               Carve = (iUp-iLow+1)*(1d0-This)/m_nBin
               IF( Carve .GT. CarvOne) THEN
                  CarvOne = Carve
                  jLow = iLow
                  jUp  = iUp
                  yLevel = This
               ENDIF
            ENDDO               ! end-loop over histogram bins 
*************************************************************
**               IF( CarvOne .GT. CarvMax) THEN
**                  CarvMax   = CarvOne
*************************************************************
            IF( CarvTwo .GT. CarvMax) THEN
               CarvMax   = CarvTwo
               kBest = kDivi    ! Best edge
               xBest = (jLow-1d0)/m_nBin
               yBest = (jUp*1d0)/m_nBin
               IF(jLow .EQ. 1 )     xBest = yBest
               IF(jUp  .EQ. m_nBin) yBest = xBest
* division ratio in units of 1/m_nBin, testing
               jDivi = jLow-1
               IF(jLow .EQ. 1 )     jDivi=jUp
**************************************************************
* The improvement below does not seem to matter at all
*                  IF( 0.5d0*(xBest+yBest) .LT. 0.5d0) THEN
*                     zBest =xBest
*                     xBest =yBest
*                     yBest =zBest
*                  ENDIF
**************************************************************
            ENDIF
*[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[[[[[[[
*               WRITE(*,'(a,4i5,f10.5)') '==iCell,kDivi,jLow,jUp,CarvMax= ',iCell,kDivi,jLow,jUp,CarvOne !!
*               IF(iCell.EQ.2 ) THEN
*                  CALL GLK_Pak(  1200+kDivi,Bins)
*                  DO iBin = 1,m_nBin
*                     Bins(iBin) = 1d0
*                  ENDDO
*                  DO iBin=jLow,jUp
*                     Bins(iBin) = yLevel
*                  ENDDO
*                  CALL GLK_Pak(  1400+kDivi,Bins)
*               ENDIF
c]]]]]]]]]]]]debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]]]]]]]]
         ENDDO                  ! end-loop over nDivi
      ENDIF
*[[[[[[[[[[[[ debug [[[[[[[[[[[[ debug [[[[[[[[[[[[
*      WRITE(*,'(a,i5)')        ' FoamB_Carver , iCell = ', iCell
*      WRITE(*,'(a,i5,3f10.5)') ' kBest,xBest,yBest= ', kBest, xBest,yBest!!
*]]]]]]]]]]]] debug ]]]]]]]]]]]] debug ]]]]]]]]]]]]
      END                       ! FoamB_Carver


      SUBROUTINE FoamB_RanDiscr(Driv,nTot,Power,iRand)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   PRESENTLY UNUSED !!!                                                           //
*//   Generates iRand in (1,nTot) acconding to discrete un-normalized probab. Driv   //
*//   Power is normaly =1, can be useful for special purposes                        //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      DOUBLE PRECISION   Driv(*),Power
      INTEGER            nTot,iRand
      INTEGER            i
      DOUBLE PRECISION   random,sum,Total
      REAL               Qrand(10)        ! from PseuMar
*
      Total   = 0d0
      DO i= 1,nTot
         Total = Total +Driv( i)**Power
      ENDDO
      IF(Total .EQ. 0d0) GOTO 990
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,1)
      ELSE
         CALL RanLux(Qrand,1)
      ENDIF
      random = Qrand(1)
      iRand  = -1
      sum   = 0d0
      DO i= 1,nTot
         iRand  = i
         sum = sum +Driv( i)**Power
         IF( random .LT. sum/Total ) GOTO 100
      ENDDO
      IF(iRand .EQ. -1) GOTO 990
 100  CONTINUE
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamB_RanDiscr, something went wrong !!!!'
      STOP
      END


      SUBROUTINE FoamB_MakeAlpha(Alpha)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Alpha, each component in (0,1) range                        //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   Alpha(m_KdiMax), y
      REAL               Qrand( m_KdiMax)        ! from PseuMar
      INTEGER            i,k
*     --------------------------------------------------------
      IF( m_kDim.LT.0 .OR. m_kDim.GT.m_KdiMax) THEN
         WRITE(*,*) 'STOP in FoamB_MakeAlpha: m_kDim=',m_kDim
         STOP
      ENDIF
      IF(m_kDim.LE.0) RETURN
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,m_kDim)
      ELSE
         CALL RanLux(Qrand,m_kDim)
      ENDIF
      DO k =1,m_kDim
         Alpha(k)=Qrand(k)
      ENDDO
      END

      SUBROUTINE FoamB_MakeLambda(Lambda)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////////
*//                                                                                      //
*//   Provides random vector Lambda such that Sum Lamba(i) = 1, with uniform probab.     //
*//   This  vector is used to populate uniformly the interior of a simplex.              //
*//   The method is: generate point inside cube, order components (maping into simplex)  //
*//   and take differences of Lambda(i+1) - Lambda(i)                                    //
*//                                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            i,k
      DOUBLE PRECISION   Lambda(m_NdiMax), y
      REAL               Qrand( m_NdiMax)        ! from PseuMar
      REAL               x
*     --------------------------------------------------------
      IF(m_nDim.LE.0) RETURN
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,m_nDim)
      ELSE
         CALL RanLux(Qrand,m_nDim)
      ENDIF
* ordering vector components (maping into simplex)
      DO i =m_nDim,1,-1
         DO k =2,i
            IF( Qrand(k).LT.Qrand(k-1)) THEN
               x            = Qrand(k)
               Qrand(k)    = Qrand(k-1)
               Qrand(k-1)  = x
            ENDIF
         ENDDO
      ENDDO
* Sum of lambdas should equal one
      Lambda(1)=Qrand(1)
      DO k =2,m_nDim
         Lambda(k)=Qrand(k)-Qrand(k-1)
      ENDDO
      END                       ! MakeLambda


      SUBROUTINE FoamB_Determinant(R,Det)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Calculates determinant of matrix R                                             //
*//   Use of Laplace formula should be perhaps replaced with something faster        //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      DOUBLE PRECISION   FoamB_Det2Lapl, FoamB_Det3Lapl,FoamB_Det4Lapl,FoamB_Det5Lapl !
*     -------------------------------------------------
      IF(        m_nDim .EQ. 1) THEN
         Det= R(1,1)
      ELSEIF(    m_nDim .EQ. 2) THEN
         Det= FoamB_Det2Lapl(R, 1,2)
      ELSEIF(    m_nDim .EQ. 3) THEN
         Det= FoamB_Det3Lapl(R, 1,2,3)
      ELSEIF(    m_nDim .EQ. 4) THEN
         Det= FoamB_Det4Lapl(R, 1,2,3,4)
      ELSEIF(    m_nDim .EQ. 5) THEN
         Det= FoamB_Det5Lapl(R, 1,2,3,4,5)
      ELSE
         WRITE(*,*) '####FoamB_Determinant: STOP, m_nDim =',m_nDim
         STOP
      ENDIF
      END                       ! FoamB_Determinant

      DOUBLE PRECISION FUNCTION FoamB_Det2Lapl(R,i1,i2)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det
      INTEGER  i1,i2
*     ------------------------------------------------------------
      FoamB_Det2Lapl= R(1,i1)*R(2,i2) - R(1,i2)*R(2,i1)
      END


      DOUBLE PRECISION FUNCTION FoamB_Det3Lapl(R,i1,i2,i3)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamB_Det2Lapl
      INTEGER  i1,i2,i3
*     ------------------------------------------------------------
      FoamB_Det3Lapl=+R(3,i1) *FoamB_Det2Lapl(R,i2,i3)
     $               -R(3,i2) *FoamB_Det2Lapl(R,i1,i3)
     $               +R(3,i3) *FoamB_Det2Lapl(R,i1,i2)
      END

      DOUBLE PRECISION FUNCTION FoamB_Det4Lapl(R,i1,i2,i3,i4)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax),Det,FoamB_Det3Lapl
      INTEGER  i1,i2,i3,i4
*     ------------------------------------------------------------
      FoamB_Det4Lapl=-R(4,i1) *FoamB_Det3Lapl(R,i2,i3,i4)
     $               +R(4,i2) *FoamB_Det3Lapl(R,i1,i3,i4)
     $               -R(4,i3) *FoamB_Det3Lapl(R,i1,i2,i4)
     $               +R(4,i4) *FoamB_Det3Lapl(R,i1,i2,i3)
      END

      DOUBLE PRECISION FUNCTION FoamB_Det5Lapl(R,i1,i2,i3,i4,i5)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//   Determinat Laplace method                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   R(m_NdiMax,m_NdiMax), Det, FoamB_Det4Lapl
      INTEGER  i1,i2,i3,i4,i5
*     ------------------------------------------------------------
      FoamB_Det5Lapl=+R(5,i1) *FoamB_Det4Lapl(R,i2,i3,i4,i5)
     $               -R(5,i2) *FoamB_Det4Lapl(R,i1,i3,i4,i5)
     $               +R(5,i3) *FoamB_Det4Lapl(R,i1,i2,i4,i5)
     $               -R(5,i4) *FoamB_Det4Lapl(R,i1,i2,i3,i5)
     $               +R(5,i5) *FoamB_Det4Lapl(R,i1,i2,i3,i4)
      END


      SUBROUTINE FoamB_Grow(funW)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Grow new cells by division                                                     //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            i,RC,iCell
*---------------------------------------------
* Final division
      DO i=1,100000
         IF(  m_OptPeek .EQ. 0 ) THEN
            CALL FoamB_PeekMax(  iCell)       ! choose cell with maximum Drive
         ELSE
            CALL FoamB_PeekRand1(iCell)       ! randomly choose one cell
         ENDIF
         CALL FoamB_Divide( iCell,funW,RC)    ! and divide it into two
c[[[[
c         CALL FoamB_BufPrint(    m_Out)
c         CALL FoamB_VertPrint(  6)
c]]]]
         IF(RC.EQ.-1) GOTO 300
      ENDDO
 300  CONTINUE
      WRITE(16,*) '######################### FoamB_Grow #####################'
*****[[[[[[ debug
***** CALL FoamB_BufPrint(    6)
***** CALL FoamB_BufActPrint( 6)
***** CALL FoamB_VertPrint(   6)
*****]]]]]]
      CALL FoamB_Check(6,0)
      END                       ! FoamB_Grow

      SUBROUTINE FoamB_PeekMax(iCell)    !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers) using DrivE                             //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER   iCell
      INTEGER   i
      DOUBLE PRECISION  DrivMax, Driv
*     ---------------------------------------------------
      iCell = 0
      DrivMax = -1d150
      DO i = 1,m_LastCe
         IF( m_CeStat(i).EQ.1 ) THEN
            Driv=  ABS(m_CeDriv(i))
            IF(Driv .GT. DrivMax) THEN
               DrivMax = Driv
               iCell = i
            ENDIF
         ENDIF
      ENDDO
****  WRITE(*,*) '###>>> FoamB_PeekMax: iCell=',iCell
      IF(iCell.EQ.0) THEN
         WRITE(*,*) '### STOP in FoamB_PeekMax: not found iCell=', iCell
         STOP
      ENDIF
      END                       ! FoamB_PeekMax


      SUBROUTINE FoamB_PeekRand1(iCell)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly TREE-WISE the pointer iCell of an active cell             //
*//                        Using DrivE                                               //
*// We walk randomly from top of tree downwards until we find active cell m_CeStat=1 //
*// At each step one of daugters cells is choosen randomly according                 //
*// to their volume estimates.                                                       //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,p1,volu1,volu2,volu,TotDri,sum
      REAL               Qrand(10)        ! from PseuMar
*     ----------------------------------------------------------------
* first cell is special because it has nDim-factorial daughters, istead of just 2
      iCell=1
      IF(m_CeStat(iCell).EQ.1) RETURN ! In case of cubics firs cell may be active
      kCell = 1
      Dau1  = m_CeDau1(kCell)
      Dau2  = m_CeDau2(kCell)
      TotDri   = 0d0
      DO iCell= Dau1,Dau2
         TotDri = TotDri+m_CeDriv( iCell )
      ENDDO
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,1)
      ELSE
         CALL RanLux(Qrand,1)
      ENDIF
      random = Qrand(1)
      iDau  = -1
      sum   = 0d0
      DO iCell= Dau1,Dau2
         iDau  = iCell
         sum = sum+m_CeDriv( iCell )
         IF( random .LT. sum/TotDri ) GOTO 100
      ENDDO
      IF(iDau.EQ.-1) GOTO 990
 100  kCell=iDau
****[[[[[[[[[[[[[[[[
****  WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_PeekRand1: top daughter =',kCell
****]]]]]]]]]]]]]]]]
      IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
* now the other standard cells with 2 daughters
      DO i=1,10000000
         IF( m_CeStat( kCell ) .EQ. 1 ) GOTO 300
         volu1= m_CeDriv( m_CeDau1(kCell) )
         volu2= m_CeDriv( m_CeDau2(kCell) )
         p1 = volu1/(volu1+volu2)
         IF(m_OptRanLux.EQ.-1) THEN
            CALL PseuMar_MakeVec(Qrand,1)
         ELSE
            CALL RanLux(Qrand,1)
         ENDIF
         random = Qrand(1)
         IF( random .LT. p1 ) THEN
            kCell = m_CeDau1(kCell)
         ELSE
            kCell = m_CeDau2(kCell)
         ENDIF
****[[[[[[[[[[[[[[[[[[[[
****  WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_PeekRand1: normal daughter =',kCell
****]]]]]]]]]]]]]]]]]]]]]
      ENDDO
      GOTO 990
 300  CONTINUE
      iCell=kCell
****[[[[[[[[[[[[[[[[[[[[
****  WRITE(*,*) '%%%%%%%%%%%%%%%%%%%%%% FoamB_PeekRand1: choosen cell =',kCell
****]]]]]]]]]]]]]]]]]]]]]
      RETURN
 990  WRITE(*,*) ' ### STOP in FoamB_PeekRand1, something went wrong !!!!'
      STOP
      END                       !!! FoamB_PeekRand1


      SUBROUTINE FoamB_Divide(iCell,funW,RC)     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Divide cell iCell into two daughter cells                                      //
*//   The iCell is retained and taged as inactive, daughter cells are appended       //
*//   at the end of the buffer.                                                      //
*//   New vertex is added to list of vertice.                                        //
*//   List of active cells is updated, iCell remooved, two daughters added           //
*//   and their properties set with help of MC sampling (FoamB_Explore)              //
*//   Return Code RC=-1 of buffer limit is reached,  m_LastCe=m_nBuf                 //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell,RC
      INTEGER            Dau1, Dau2, kVer1(m_NdiMax+1), kVer2(m_NdiMax+1),p1,p2 !
      DOUBLE PRECISION   HcPosi1(m_KdiMax),   HcSize1(m_KdiMax)
      DOUBLE PRECISION   HcPosi2(m_KdiMax),   HcSize2(m_KdiMax)
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            Old1,Old2,j,k,jv,iv,nEdges,kBest,kDivi,NoMC
      DOUBLE PRECISION   Xave
      INTEGER            nDivi,nDivi0
*--------------------------------------------------------------------------------------
      RC = 0
      IF( m_LastCe+2 .GT. m_nBuf) GOTO 990 !! abort if no space in buffer
* reset cell as inactive
      m_CeStat(iCell) = 0
*------------------------------------------------------------------------------------
* Define lists of vertices for daughters, initially inherited...
      IF(m_nDim .GT. 0) THEN
         DO jv=1,m_nDim+1
            kVer1(jv) = m_CeVert(iCell,jv)
            kVer2(jv) = m_CeVert(iCell,jv)
         ENDDO
      ENDIF
* Position and size initially also inherited
      DO j=1,m_kDim
         HcPosi1(j)=m_CeVer1(iCell,j)
         HcSize1(j)=m_CeVer2(iCell,j)
         HcPosi2(j)=m_CeVer1(iCell,j)
         HcSize2(j)=m_CeVer2(iCell,j)
      ENDDO
*--------------------------------------------------------------------------------------
      nDivi  = (m_nDim+1)*m_nDim/2 +m_kDim
      nDivi0 = (m_nDim+1)*m_nDim/2
      kBest  = m_CeBest(iCell)
      IF( kBest.LE.nDivi0) THEN
*//////////////////////////////////////////////////////////////////////////////////////
*//   The best division in simplical subspace
*//////////////////////////////////////////////////////////////////////////////////////
         m_LastVe=m_LastVe+1    ! add new vertex to the list
         IF(m_LastVe.GT.m_vMax) GOTO 980
         Xave  = m_CeXave(iCell)
         nEdges=0
         DO jv=1,m_nDim+1
            DO iv=jv+1,m_nDim+1
               nEdges=nEdges+1
               IF( nEdges.EQ.kBest) THEN
                  p1 =  m_CeVert(iCell,jv)
                  p2 =  m_CeVert(iCell,iv)
                  DO j=1,m_nDim
                     m_VerX(m_LastVe,j) = Xave*m_VerX(p1,j) + (1d0-Xave)*m_VerX(p2,j) ! New Vertex
                  ENDDO
                  Old1=jv
                  Old2=iv
                  GOTO 100
               ENDIF
            ENDDO
         ENDDO
 100     CONTINUE
         kVer1(Old1)=m_LastVe   ! one old vertex replaced by new one
         kVer2(Old2)=m_LastVe   ! one old vertex replaced by new one
      ELSE
*//////////////////////////////////////////////////////////////////////////////////////
*//   The best division in hypercubical subspace
*//   Position and size inherited except one direction k=kDivi
*//////////////////////////////////////////////////////////////////////////////////////
         Xave  = m_CeXave(iCell)
         kDivi = kBest-nDivi0
         HcPosi1(kDivi)=      m_CeVer1(iCell,kDivi)        ! (1) Position unchanged
         HcSize1(kDivi)= Xave*m_CeVer2(iCell,kDivi)        ! (1) Size reduced by Xave
         HcPosi2(kDivi)= HcPosi1(kDivi) +HcSize1(kDivi)    ! (2) Position shifted
         HcSize2(kDivi)= (1d0-Xave)*m_CeVer2(iCell,kDivi)  ! (2) Size reduced by (1-Xave)
      ENDIF
* define two daughter cells (active)
      NoMC= m_nSampl
* ------------------------ Stat, Pare, Dau1,Dau2, MCsampl, VertList, Position,Size,  iCeNew
      CALL FoamB_DefCell(  1, iCell,  -1,  -1,    NoMC,   kVer1,  HcPosi1, HcSize1, Dau1) !
      CALL FoamB_DefCell(  1, iCell,  -1,  -1,    NoMC,   kVer2,  HcPosi2, HcSize2, Dau2) !
      m_CeDau1(iCell) = Dau1
      m_CeDau2(iCell) = Dau2
      CALL FoamB_Explore(Dau1,funW)
      CALL FoamB_Explore(Dau2,funW)
* Update list of active cells, only for internal tests
      CALL FoamB_ActUpda
      RETURN
 990  RC=-1                     !!buffer limit is reached,  m_LastCe=m_nBuf
      RETURN
 980  WRITE(*,*) ' ### STOP in FoamB_Divide: too short list of vertices '
      STOP
      END                       ! FoamB_Divide



      SUBROUTINE FoamB_ActUpda     !# Initialization
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Create list of active cells (pointers)                                         //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER   iCell,Dau1,Dau2
      INTEGER   i
*     ---------------------------------------------------
      m_LastAc=0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            m_LastAc=m_LastAc+1
            IF(m_LastAc .EQ. m_cMax) GOTO 950
            m_ActC(m_LastAc) = iCell
         ENDIF
      ENDDO
      RETURN
 900  WRITE(*,*) '### STOP in FoamB_ActUpda: not found iCell=', iCell
      STOP
 950  WRITE(*,*) '### STOP in FoamB_ActUpda: list of active cells too short'
      STOP
      END                       ! FoamB_ActUpda


      SUBROUTINE FoamB_CellGener(iCell)     !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//       Peek up randomly pointer iCell of an active cell according to PRIMARY      //
*//       Straightforward way, using list of active pointes made by ActUpda          //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell
      INTEGER            kCell,i,Dau1,Dau2,iDau
      DOUBLE PRECISION   random,x1,TotPrim
      INTEGER            klower,kuper,krange,kurrent,DipSwitch
      REAL               Qrand(10)        ! from PseuMar
      INTEGER   iCont
      DATA      iCont/0/
      iCont = iCont+1
*     ----------------------------------------------------------------
      IF(m_OptRanLux.EQ.-1) THEN
         CALL PseuMar_MakeVec(Qrand,1)
      ELSE
         CALL RanLux(Qrand,1)
      ENDIF
      random = Qrand(1)
*     ---------------------------------------------------
      TotPrim = m_CePrCu(m_LastAc)
      x1 = TotPrim *random
      DipSwitch=0               ! =0 is faater
      IF( DipSwitch.EQ.1) THEN
*-------- primitive method --------
         DO kCell = 1,m_LastAc
            iCell = m_ActC(kCell)
            IF( m_CePrCu(kCell) .GE. x1 ) GOTO 800
         ENDDO
         WRITE(*,*) '### STOP1 in FoamB_CellGener: something wrong' !
         STOP
 800     CONTINUE
      ELSEIF( DipSwitch.EQ.0) THEN
*-------- a bit more sophisticated/faster method ------
         klower   = 0
         kuper    = m_LastAc
         DO i=1,m_LastAc
            krange   = (kuper-klower+1)/2
            kurrent  = klower +krange
            IF( x1 .LE. m_CePrCu(kurrent) ) THEN
               kuper = kurrent
            ELSE
               klower = kurrent
            ENDIF
            IF(kuper-klower.LE.1) GOTO 850
         ENDDO
         WRITE(*,*) ' STOP in FoamB_CellGener'
         STOP
 850     CONTINUE
         iCell = m_ActC(kuper)
         kCell = kuper
      ELSE
         iCell = m_ActC(1)      ! nonsense for tests
      ENDIF
***** IF(iCont.LE.10) WRITE(*,*) 'LastAc,kCell,iCell = ',m_LastAc,kCell,iCell !! debug
      END                       ! FoamB_CellGener


      SUBROUTINE FoamB_MakeEvent(funW)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Generates point/vector Xrand with the weight MCwt                              //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            iCell,i,j,iv
      DOUBLE PRECISION   Wt,x1,x2,Dx,MCwt
      DOUBLE PRECISION   Alpha( m_KdiMax) ! Hyper-Cubic subspace
      DOUBLE PRECISION   Lambda(m_NdiMax) ! Simplical subspace
*     -----------------------------------------------------------------
*     choose randomly one cell
      CALL FoamB_CellGener( iCell)
*     generate randomly/uniformly vector Vrand inside this simplex
      CALL FoamB_MakeAlpha( Alpha)
      CALL FoamB_MakeLambda(Lambda)
      DO j=1,m_nDim
         m_MCvector(j) = m_VerX( m_CeVert(iCell,m_nDim+1) ,j)
         DO iv=1,m_nDim
            m_MCvector(j) = m_MCvector(j) 
     $           +Lambda(iv)*( m_VerX( m_CeVert(iCell,iv) ,j) -m_VerX( m_CeVert(iCell,m_nDim+1) ,j) ) !
         ENDDO
      ENDDO
      DO j=1,m_kDim
         m_MCvector(m_nDim+j) = m_CeVer1(iCell,j) +Alpha(j)*m_CeVer2(iCell,j) ! hypcubic subspace
      ENDDO
      Dx = m_CeVolu(iCell)      ! Cartesian volume of the Cell
*[[[[[[[[[[[[
***** CALL FoamB_TestNewConcept(iCell)
*]]]]]]]]]]]]
* weight average normalised to PRIMARY integral over the cell
      MCwt =funW(m_MCvector)*Dx/m_CePrim(iCell) ! PRIMARY controls normalization
      m_nCalls =  m_nCalls+1
      m_MCwt   =  MCwt
* accumulation of statistics for the main MC weight
      m_SumWt  =  m_SumWt  +MCwt         ! sum of Wt
      m_SumWt2 =  m_SumWt2 +MCWt*MCwt    ! sum of Wt**2
      m_NevGen =  m_NevGen +1d0          ! sum of 1d0
      m_WtMax  =  MAX(m_WtMax,MCwt)      ! maximum wt
      m_WtMin  =  MIN(m_WtMin,MCwt)      ! minimum wt
* update also weight sums in the cell,
* note weights here are normalized absolutely, eg. to the value of the integral
      Wt = MCwt*m_CePrim(iCell)
      m_CeSum(iCell,1) = m_CeSum(iCell,1)+ Wt      ! sum of weights
      m_CeSum(iCell,2) = m_CeSum(iCell,2)+ Wt*Wt   ! sum of weights squared
      m_CeSum(iCell,3) = m_CeSum(iCell,3)+ 1d0     ! sum of 1
      m_CeSum(iCell,4) = MIN( m_CeSum(iCell,4),Wt) ! minium weight
      m_CeSum(iCell,5) = MAX( m_CeSum(iCell,5),Wt) ! maximu weight
      END                       ! FoamB_MakeEvent

      SUBROUTINE FoamB_GetMCvector(MCvector)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION  MCvector(*)
      INTEGER           k
*-----------------------
      DO k=1,m_Dimen
         MCvector(k)    = m_MCvector(k)
      ENDDO
      END

      SUBROUTINE FoamB_GetMCwt(MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION  MCwt
*-----------------------
      MCwt    = m_MCwt
      END

      SUBROUTINE FoamB_MCgenerate(funW,MCvector,MCwt)    !# Generation
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Obsolete                                                                       //
*//   Generates point/vector MCvector with the weight MCwt                           //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION   MCvector(*),MCwt
      DOUBLE PRECISION   funW
      EXTERNAL           funW
      INTEGER            j
*     ---------------------------------------------------------------
      CALL FoamB_MakeEvent(funW)
      MCwt = m_MCwt
      DO j=1,m_Dimen
         MCvector(j) =m_MCvector(j)
      ENDDO
      END                       !!FoamB_MCgenerate


      SUBROUTINE FoamB_Finalize(MCresult,MCerror)    !# Finalization
*//////////////////////////////////////////////////////////////////////////////
*//                                                                          //
*//   After MC run is completed it calculates integral and its error         //
*//   Also prints some information/statistics on the MC run                  //
*//   Remember that PRIMARY controls normalization of the integration        //
*//////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
*
      DOUBLE PRECISION     MCresult,MCerror,MCerelat
      DOUBLE PRECISION     Vtot,Verr,VerRela,TotPrim
      INTEGER              kCell,iCell
*-----------------------------------------------------------------------------
      MCresult =0d0
      MCerelat =1d0
      TotPrim = 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         TotPrim = TotPrim +m_CePrim( iCell )
      ENDDO
      IF(m_NevGen .GT. 0) THEN
         MCresult = TotPrim *m_SumWt/m_NevGen
         IF(m_SumWt.NE.0d0)  MCerelat  = m_SumWt2/m_SumWt**2 -1d0/m_NevGen !
         IF(MCerelat.GT.0d0) MCerelat =  SQRT( ABS(MCerelat) ) !
         IF(MCerelat.LT.0d0) MCerelat = -SQRT( ABS(MCerelat) ) !
      ENDIF
      MCerror = MCresult*MCerelat
* some test printouts
      WRITE(m_Out,'(3a)') '||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||' !
      WRITE(m_Out,'(3a)') '||||||||||||||||||||||||||||||', ' FoamB_Finalize ', !
     $                    '||||||||||||||||||||||||||||||'
      WRITE(m_Out,'(a,2g18.9,f11.7)')               'MCresult, MCerror, Errela= ',MCresult,MCerror,MCerelat !
      WRITE(m_Out,'(a,2f11.5)')                     'Minimum maximum weight   = ',m_WtMin,m_WtMax !
      IF(m_NevGen .GT. 0) WRITE(m_Out,'(a,2f11.5)') 'Average wt SumWt/NevGen  = ',m_SumWt/m_NevGen !
      WRITE(m_Out,'(a,i15)')                        'Total of function calls  = ',m_nCalls !
      WRITE(m_Out,'(a,2i15)')                       'Number of cells&vertices = ',m_LastCe,m_LastVe !
      WRITE(m_Out,'(a,f12.1,2g18.9)')               'NevGen,SumWt,m_SumWt2    = ',m_NevGen,m_SumWt,m_SumWt2 !
      END       ! FoamB_Finalize



      SUBROUTINE FoamB_GetTotPrim(TotPrim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//   Total integral from cell statistics, including initialization + MC generation  //
*//   It can be invoked just after initialization or after MC generation             //
*//   Note that this estimate is distorted slightly if vertices are included in      //
*//   the exploration of the cells.                                                  //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      INCLUDE 'FoamB.fi'
      DOUBLE PRECISION  TotPrim,Sum
      INTEGER   kCell,  iCell      
      Sum = 0d0
      DO kCell = 1,m_LastAc
         iCell  = m_ActC(kCell)
         Sum = Sum +m_CePrim( iCell )
      ENDDO
      TotPrim=Sum
      END


      SUBROUTINE FoamB_SetnDim(nDim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nDim
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nDim = nDim
      m_Dimen=m_nDim+m_kDim
      END                       !!! FoamB_SetnDim

      SUBROUTINE FoamB_SetkDim(kDim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      kDim
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_kDim = kDim
      m_Dimen=m_nDim+m_kDim
      END                       !!! FoamB_SetnDim

      SUBROUTINE FoamB_GetnDim(nDim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nDim
*     -------------------------------------------------
      nDim = m_nDim
      END                       !!! FoamB_SetnDim

      SUBROUTINE FoamB_GetkDim(kDim)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      kDim
*     -------------------------------------------------
      kDim = m_kDim
      END                       !!! FoamB_SetkDim

      SUBROUTINE FoamB_GetnCalls(nCalls)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nCalls
*     -------------------------------------------------
      nCalls = m_nCalls
      END                       !!! FoamB_SetnCalls

      SUBROUTINE FoamB_SetnBuf(nBuf)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nBuf
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nBuf = nBuf
      END                       !!! FoamB_SetnBuf

      SUBROUTINE FoamB_SetnBin(nBin)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nBin
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nBin = nBin
      END                       !!! FoamB_SetnBin

      SUBROUTINE FoamB_SetOut(Out)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      Out
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Out = Out
      END                       !!! FoamB_SetOut

      SUBROUTINE FoamB_SetChat(Chat)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      Chat
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_Chat = Chat
      END                       !!! FoamB_SetChat

      SUBROUTINE FoamB_SetnSampl(nSampl)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      nSampl
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_nSampl = nSampl
      END                       !!! FoamB_SetnSampl

      SUBROUTINE FoamB_SetOptDrive(OptDrive)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptDrive
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptDrive = OptDrive
      END                       !!! FoamB_SetOptDrive

      SUBROUTINE FoamB_SetEvPerBin(EvPerBin)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      EvPerBin
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_EvPerBin = EvPerBin
      END                       !!! FoamB_SetEvPerBin

      SUBROUTINE FoamB_SetOptPeek(OptPeek)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptPeek
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptPeek = OptPeek
      END                       !!! FoamB_SetOptPeek

      SUBROUTINE FoamB_SetOptEdge(OptEdge)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptEdge
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptEdge = OptEdge
      END                       !!! FoamB_SetOptEdge

      SUBROUTINE FoamB_SetOptOrd(OptOrd)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptOrd
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptOrd = OptOrd
      END                       !!! FoamB_SetOptOrd


      SUBROUTINE FoamB_SetOptRanIni(OptRanIni)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptRanIni
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptRanIni = OptRanIni
      END                       !!! FoamB_SetOptRanIni

      SUBROUTINE FoamB_SetOptRanLux(OptRanLux)     !# Getters and Setters
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER      OptRanLux
*     -------------------------------------------------
      CALL FoamB_PreInitialize
      m_OptRanLux = OptRanLux
      END                       !!! FoamB_SetOptRanLux

      SUBROUTINE FoamB_Check(mout,level)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//  Checks all pointers, It is is a usefull autodiagnostic.                         //
*//                                                                                  //
*//  level=0, no printout, failures causes STOP                                      //
*//  level=1, printout, failures lead to WARNINGS only                               //
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER       mout,level
      INTEGER       nFailures, iCell, Dau1,Dau2, Pare, NoRefs(m_vMax), iVe,n !
      INTEGER       NoEmpty, iError
*     ---------------------------------------------------------
      nFailures=0
      iError   =0
      IF(level.EQ.1) WRITE(mout,*)
     $'//////////////////////////////////////// FoamB_Checks /////////////////////////////////////////////' !
      DO iCell = 1,m_LastCe
         Dau1 = m_CeDau1(iCell)
         Dau2 = m_CeDau2(iCell)
         Pare = m_CePare(iCell)
* checking on parents
         IF(iCell.GT.1) THEN
            IF(Pare.GT.m_LastCe) THEN
               iError   =1
               nFailures = nFailures+1
               IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Parent out of range = ',Pare !
            ENDIF
         ENDIF
         IF(iCell.GT.1) THEN
            IF(  (Pare.NE.1) .AND. (m_CeDau1(Pare).NE.iCell) .AND. (m_CeDau2(Pare).NE.iCell)  ) THEN !
               iError   =2
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Parent not pointing to this daughter Pare= ',Pare !
            ENDIF
         ENDIF
* checking on daughters
         IF( Dau1 .GT. m_LastCe ) THEN
            iError   =3
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter out of range Dau1= ',Dau1 !
         ENDIF
         IF( Dau2 .GT.m_LastCe ) THEN
            iError   =4
            nFailures = nFailures+1
            IF(level.EQ.1) WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter out of range Dau2= ',Dau2 !
         ENDIF
         IF( Dau1.GE.1 .AND. Dau1.LE. m_LastCe) THEN
            IF( m_CePare(Dau1).NE.iCell ) THEN
               iError   =5
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' First  Daugter not pointing to parent Dau1= ',Dau1 !
            ENDIF
         ENDIF
         IF( Dau2.GE.1 .AND. Dau2.LE. m_LastCe) THEN
            IF( m_CePare(Dau2).NE.iCell ) THEN
               iError   =6
               nFailures = nFailures+1
               IF(level.EQ.1) 
     $              WRITE(mout,*) '##### iCell= ',iCell,' Second Daugter not pointing to parent Dau2= ',Dau2 !
            ENDIF
         ENDIF 
      ENDDO
* check on vertices
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO n=1,m_nDim+1
               IF( iVe .EQ. m_CeVert(iCell,n) ) NoRefs(iVe) =1
            ENDDO
         ENDDO
      ENDDO
      DO iVe = 1, m_LastVe
         IF(NoRefs(iVe).EQ.0 .AND.  level.EQ.1) WRITE(mout,*) '***** Vertex no. ',iVe, '  NOT referenced!' !
      ENDDO
* Check for empty cells
      NoEmpty = 0d0
      DO iCell = 1,m_LastCe
         IF( m_CeStat(iCell).EQ.1 ) THEN
            IF( m_CeDriv(iCell) .EQ. 0d0) NoEmpty = NoEmpty +1
         ENDIF
      ENDDO
      IF( NoEmpty.GT.0) THEN
         WRITE(mout,*) '++++++++++ FoamB_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty !
         WRITE(   *,*) '++++++++++ FoamB_Check: !!! WARNING!!!! Empty Cells found NoEmpty= ',NoEmpty !
      ENDIF
* summary
      IF(level.EQ.1) WRITE(mout,*) '++++++++++ FoamB_Check has found total ', nFailures, ' failures ' !
      IF(level.EQ.1) WRITE(mout,*)
     $'///////////////////////////////////////////////////////////////////////////////////////////////////' !
      IF(level.EQ.0 .AND. nFailures.GT.0 ) THEN
         WRITE(mout,*) '++++++++++ STOP in FoamB_Check, found total ', nFailures, ' failures ' !
         WRITE(mout,*) '++++++++++ iErro= ',iError
         STOP
      ENDIF
      END                       ! FoamB_Check



      SUBROUTINE FoamB_BufPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all cells                                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell,mout,active,j
*     ----------------------------------------------------------------
      active  =0
      WRITE(mout,'(3a)') '==============================================', ' ALL-CELLS ',
     $                   '=============================================='
      WRITE(mout,'(3a)') 
     $     ' iCell  Stat  Pare  Dau1  Dau2 kBest       Xave     Volume      Drive  TrueInteg  Ver1  Ver2  ...'
      DO iCell = 1, m_LastCe
         WRITE(mout,'(6i6,4f11.5,20i6)')
     $        iCell, m_CeStat(iCell),  m_CePare(iCell), m_CeDau1(iCell), m_CeDau2(iCell), !
     $        m_CeBest(iCell),                          ! pointer to best division
     $        m_CeXave(iCell),                          ! factor for Best division 
     $        m_CeVolu(iCell),                          ! Cartesian Volume
     $        m_CeDriv(iCell),                          ! Drive 
     $        m_CeIntg(iCell),                          ! TrueInteg
     $        (m_CeVert(iCell,j), j=1,m_nDim+1)         ! vertices
         IF(m_kDim .GT. 0 ) THEN
            WRITE(mout,'(a,(50g11.6))')
     $           '       HypCubs Posit&Size: ',
     $           (m_CeVer1(iCell,j), j=1,m_kDim), ! position
     $           (m_CeVer2(iCell,j), j=1,m_kDim)  ! size
         ENDIF
         IF(m_CeStat(iCell).EQ.1) active  = active +1
      ENDDO
      WRITE(mout,*) ' All cells: ',m_LastCe, ' Active: ', active
      END                       !! FoamB_BufPrint



      SUBROUTINE FoamB_BufActPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Active cells only                                                              //
*//   Side=1 indicates that this cell is "side leaf" sticking out of main branch     //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell,mout,active,Side,Pare,j
      DOUBLE PRECISION   DriRat,IntgSum,DrivSum,Fact,WtMin,WtMax
      DOUBLE PRECISION   AveWt, Sigma, Nentry
*     ----------------------------------------------------------------
      WRITE(mout,'(3a)') '==================================================', ' ACTIVE CELLS ',
     $                   '=================================================='
      IntgSum =0d0
      DrivSum =0d0
      WtMin   =  1d60
      WtMax   = -1d60
      active  =0
      WRITE(mout,'(2a)') ' iCell Stat Pare Dau1 Dau2',
     $   '     WtMin      WtMax        <w>  sigma/<w>     Volume      Drive    TrueInt   Ver1  Ver2 ...' !
      DO iCell = 1, m_LastCe
         IF(m_CeStat(iCell).EQ.1) THEN
            Nentry = m_CeSum(iCell,3)
            AveWt  = m_CeSum(iCell,1)/m_CeSum(iCell,3)
            Sigma  = DSQRT(  ABS(m_CeSum(iCell,2)/Nentry - AveWt**2))
            IF(AveWt.NE.0d0) WtMin = Min( WtMin, m_CeSum(iCell,4)/AveWt)
            IF(AveWt.NE.0d0) WtMax = Max( WtMax, m_CeSum(iCell,5)/AveWt)
            IF(AveWt.NE.0d0) Sigma = Sigma/AveWt
            WRITE(mout,'(5i5, 7f11.5 ,10i5)') 
     $           iCell, m_CeStat(iCell),  m_CePare(iCell),  m_CeDau1(iCell), m_CeDau2(iCell), !
     $           m_CeSum(iCell,4),       ! minWt/AveWt
     $           m_CeSum(iCell,5),       ! maxWt/AveWt
     $           m_CeIntg(iCell) /(m_CeDriv(iCell)+1d-100), ! average weight
     $           Sigma/(AveWt+1d-100),   ! sigma/AveWt
     $           m_CeVolu(iCell),        ! Cartesian volume
     $           m_CeDriv(iCell),        ! Driver Integral
     $           m_CeIntg(iCell),        ! True   Integral
     $           (m_CeVert(iCell,j), j=1,m_nDim+1) ! vertices
            IF(m_kDim .GT. 0 ) THEN
               WRITE(mout,'(a,(50g11.6))')
     $              '      HypCubs Posit&Size: ',
     $              (m_CeVer1(iCell,j), j=1,m_kDim), ! position
     $              (m_CeVer2(iCell,j), j=1,m_kDim)  ! size
            ENDIF
            IntgSum = IntgSum +m_CeIntg(iCell)
            DrivSum = DrivSum +m_CeDriv(iCell)
            active  = active +1
         ENDIF
      ENDDO
      WRITE(mout,'(a,i6,a,2i6)') 'All cells: ',m_LastCe, '      Active: ', active, m_LastAc !
      WRITE(mout,'(a,2f12.5)')   'Minimum and Maximum Weight/<Wt>       = ',WtMin,WtMax !
      WRITE(mout,'(a,2g20.13)')  'Total True Integral in active cells   = ', IntgSum, m_CeIntg(1) !
      WRITE(mout,'(a,2g20.13)')  'Total Driver Integral in active cells = ', DrivSum, m_CeDriv(1) !
      WRITE(mout,'(a,f12.5)')    'True/Drive = ', IntgSum/DrivSum
      END                       !! FoamB_BufActPrint


      SUBROUTINE FoamB_VertPrint(mout)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   all vertices                                                                   //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            mout, iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*     ----------------------------------------------------------------
      DO iVe = 1, m_LastVe
         NoRefs(iVe)=0
      ENDDO
      DO iVe = 1, m_LastVe
         DO iCell = 1, m_LastCe
            DO k=1,m_nDim+1
               IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1 !
               IF(m_CeStat(iCell) .EQ. 1) THEN
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1 !
               ENDIF
            ENDDO
         ENDDO
      ENDDO
      WRITE(mout,*) '=====================ALL VERTICES===================================' !
      WRITE(mout,*) ' iVert   NoRefs  NoRefsAc       Vertex     Componets    ' !
      DO iVe = 1, m_LastVe
         WRITE(mout,'(i6,2i10,5f17.10)') iVe,NoRefs(iVe),NoRefsAc(iVe), (m_VerX(iVe,j),j=1,m_nDim) !
      ENDDO
      END                       !! VertPrint



      SUBROUTINE FoamB_PltBegin(ltx)     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Initialization, write header of TeX file                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER   ltx
*---------------------------------------------------
      m_ltx  = ABS(ltx)
      IF(ltx .GT. 0 ) THEN
         WRITE(m_ltx,'(2A)') '\\newpage'
      ELSE
*------------------------------!
*           Header
*------------------------------!
         WRITE(m_ltx,'(A)') '\\documentclass[12pt]{article}'
         WRITE(m_ltx,'(A)') '\\usepackage{color}' !<-for colors!!!
         WRITE(m_ltx,'(A)') '\\usepackage{epic}' !<-for extended ploting
         WRITE(m_ltx,'(A)') '\\textwidth  = 16cm'
         WRITE(m_ltx,'(A)') '\\textheight = 18cm'
         WRITE(m_ltx,'(A)') '\\pagestyle{empty}'
         WRITE(m_ltx,'(A)') '\\begin{document}'
         WRITE(m_ltx,'(A)') '  '
         WRITE(m_ltx,'(A)') '%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%' !
         WRITE(m_ltx,'(A)') '\\begin{figure}[!ht]'
         WRITE(m_ltx,'(A)') '\\centering'
*------------------------------!
* Frames and labels
*------------------------------!
         WRITE(m_ltx,'(A)') '% =========== big frame, title etc. ======='
         WRITE(m_ltx,'(A)') '\\setlength{\\unitlength}{0.1mm}'
         WRITE(m_ltx,'(A)') '\\begin{picture}(1600,1600)'
         WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox(1600,1600){ }}'
      ENDIF
      END

      SUBROUTINE FoamB_PltVert     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all vertices                                                              //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell, iVe, NoRefs(m_vMax), NoRefsAc(m_vMax), k,j
*------------------------------------------------------------------------------
*     Mark plots for plots
      CHARACTER*62 star,diamond,circle,ring,times,disc,plus,box,dot
      PARAMETER (diamond ='\\makebox(0,0){\\Large $\\diamond$}')
      PARAMETER (star    ='\\makebox(0,0){\\Large $\\star$}')
      PARAMETER (circle  ='\\circle{30}')
      PARAMETER (ring    ='\\circle{20}')
      PARAMETER (times   ='\\makebox(0,0){\\Large $\\times$}')
      PARAMETER (disc    ='\\circle*{20}')
      PARAMETER (plus    ='\\makebox(0,0){\\Large $+$}')
      PARAMETER (box     ='\\makebox(0,0){\\Large $\\Box$}') !!! does not work???
      PARAMETER (dot     ='\\circle*{10}')
*------------------------------------------------------------------------------
      CHARACTER*62  chmark
      INTEGER       kx,ky
*---------------------------------------------------------------------------------------------
      IF(m_nDim.EQ.2) THEN
* Count references of vertices
         DO iVe = 1, m_LastVe
            NoRefs(iVe)=0
         ENDDO
         DO iVe = 1, m_LastVe
            DO iCell = 1, m_LastCe
               DO k=1,m_nDim+1
                  IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefs(iVe) =NoRefs(iVe) +1 !
                  IF(m_CeStat(iCell) .EQ. 1) THEN
                     IF( iVe .EQ. m_CeVert(iCell,k) ) NoRefsAc(iVe) =NoRefsAc(iVe) +1 !
                  ENDIF
               ENDDO
            ENDDO
         ENDDO
*---------------------------------------------------------------------------------------------
* Begin frame
         WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
         WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
         WRITE(m_ltx,'(A)') '\\put(0,0){\\framebox( 1600,1600){ }}' !
* Plotting symbol
         IF(m_LastVe.LE.250) THEN
            WRITE(m_ltx,'(10A)') '\\newcommand{\\VD}[2]{\\put(#1,#2){',disc,'}}' !
            WRITE(m_ltx,'(10A)') '\\newcommand{\\VS}[2]{\\put(#1,#2){',star,'}}' !
         ELSE
            WRITE(m_ltx,'(10A)') '\\newcommand{\\VD}[2]{\\put(#1,#2){',dot,'}}' !
            WRITE(m_ltx,'(10A)') '\\newcommand{\\VS}[2]{\\put(#1,#2){',dot,'}}' !
         ENDIF
         WRITE(m_ltx,'(10A)') 
     $        '\\newcommand{\\VN}[3]{\\put(#1,#2){\\makebox(0,0)[b]{\\hbox{\\color{red}\\scriptsize #3}}}}' !
         DO iVe = 1, m_LastVe
            kx = m_VerX(iVe,1)*1600
            ky = m_VerX(iVe,2)*1600
*****         WRITE(*,*) NoRefs(iVe),NoRefsAc(iVe)
            IF( NoRefsAc(iVe).LE.2 ) THEN
               WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VD{',kx,'}{',ky,'}'
            ELSE
               WRITE(m_ltx,'(A,I5,A,I5,A)') '\\VS{',kx,'}{',ky,'}'
            ENDIF            
            IF(m_LastVe.LE.250) WRITE(   m_ltx,'(A,I5,A,I5,A,I5,A)') '\\VN{',kx-8,'}{',ky+12,'}{',iVe,'}' !
         ENDDO
* Close frame
         WRITE(m_ltx,'(A)') '\\end{picture}}'
         WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
      ENDIF
*---------------------------------------------------------------------------------------------
      END                       !! VertPrint


      SUBROUTINE FoamB_PltCell     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Plot all simplectic cells                                                      //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
      INTEGER            iCell,active,j
      INTEGER            iV1,iV2,iV3
      INTEGER            kx1,ky1,kx2,ky2,kx3,ky3,kx,ky,lx,ly
*---------------------------------------------------------------------------------------------
*                        Rectangular 2-dim FOAM
*---------------------------------------------------------------------------------------------
      IF(m_kDim.EQ.2) THEN
         WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
         WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
         DO iCell = 2, m_LastCe
            IF(m_CeStat(iCell).EQ.1) THEN ! Only active cells
               kx = m_CeVer1(iCell,1)*1600
               ky = m_CeVer1(iCell,2)*1600
               lx = m_CeVer2(iCell,1)*1600
               ly = m_CeVer2(iCell,2)*1600
               kx1 = kx+lx/2
               ky1 = ky+ly/2
*     cell rectangle
               WRITE(m_ltx,'(A,I5,A,I5,A,I5,A,I5,A)') 
     $              '\\put(',kx,',',ky,'){\\color{black}\\framebox(',lx,',',ly,'){ }}' !
***               WRITE(m_ltx,'(A,I5,A,I5,A,I5,A,I5,A)') 
***     $              '\\put(',kx,',',ky,'){\\color{black}\\dashbox{7}(',lx,',',ly,'){ }}' !
*     cell number
               IF(m_LastCe.LE.250) WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $            '\\put(',kx1,',',ky1,'){\\makebox(0,0)[b]{\\hbox{\\small\\color{magenta}\\scriptsize ',iCell,' }}}' !
            ENDIF
         ENDDO
* Close frame
         WRITE(m_ltx,'(A)') '\\end{picture}}'
         WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
      ENDIF
*---------------------------------------------------------------------------------------------
*                        Triangulare 2-dim FOAM
*---------------------------------------------------------------------------------------------
      IF(m_nDim.EQ.2) THEN
         WRITE(m_ltx,'(A)') '% =========== Vertices Vertices ==========='
         WRITE(m_ltx,'(A)') '\\put(0,0){\\begin{picture}( 1600,1600)' !
         DO iCell = 2, m_LastCe
            iV1=m_CeVert(iCell,1)
            iV2=m_CeVert(iCell,2)
            iV3=m_CeVert(iCell,3)
            kx1 = m_VerX(iV1,1)*1600
            ky1 = m_VerX(iV1,2)*1600
            kx2 = m_VerX(iV2,1)*1600
            ky2 = m_VerX(iV2,2)*1600
            kx3 = m_VerX(iV3,1)*1600
            ky3 = m_VerX(iV3,2)*1600
            kx= (kx1+kx2+kx3)/3
            ky= (ky1+ky2+ky3)/3
            IF(m_CeStat(iCell).EQ.1) THEN
***         WRITE(*,*) iCell,iV1,iV2,iV3
               WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx1,',',ky1,')(',kx2,',',ky2,')' !
               WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx2,',',ky2,')(',kx3,',',ky3,')' !
               WRITE(m_ltx,'(A,I4,A,I4,A,I4,A,I4,A)') '\\drawline(',kx3,',',ky3,')(',kx1,',',ky1,')' !
               IF(m_LastCe.LE.250) WRITE(m_ltx,'(A,I4,A,I4,A,I4,A)') 
     $              '\\put(',kx,',',ky,'){\\makebox(0,0)[b]{\\hbox{\\color{magenta}\\scriptsize ',iCell,' }}}' !
            ENDIF
         ENDDO
* Close frame
         WRITE(m_ltx,'(A)') '\\end{picture}}'
         WRITE(m_ltx,'(A)') '% ============== End Vertices ==========='
      ENDIF
      END                       !! FoamB_BufPrint

      SUBROUTINE FoamB_PltMisc     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   Miscelaneous                                                                   //
*//   Plot of frame for 2-dim void testing function                                  //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
*
      WRITE(m_ltx,'(A)') '\\put(80,80){\\color{blue}\\dashbox{7}( 1440,1440){ }}' ! 5% edge band
      END                       !! FoamB_PltMisc

      SUBROUTINE FoamB_PltEnd     !# Miscelaneous and debug
*//////////////////////////////////////////////////////////////////////////////////////
*//   DEBUG                                                                          //
*//   Close Tex file with plot                                                       //
*//////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT NONE
      INCLUDE 'FoamB.fi'
*
      WRITE(m_ltx,'(A)') '\\end{picture}'
      WRITE(m_ltx,'(A)') '\\end{figure}'
      WRITE(m_ltx,'(A)') '\\end{document}'
      CLOSE(m_ltx)
      END

*//////////////////////////////////////////////////////////////////////////////////////
*//                                                                                  //
*//////////////////////////////////////////////////////////////////////////////////////
