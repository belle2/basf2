C
C     KK interface
C
CCCCCC
      subroutine KK_init (DatX_d,DatX_u,DatX_p,IRAND1)
      implicit         none
      character*132 DatX_d, DatX_u, DatX_p

      integer imax
      parameter (imax = 10000)
      double precision xpar(imax)

      integer iflong, IRAND1

      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau
      double precision dum(4)

C   Input environment
      Print *,'KK DATAX_0 : '//DatX_d
      Print *,'KK DATAX_1 : '//DatX_u
      Print *,'KK DATAX_P : '//DatX_p

      open(1,FILE=DatX_u)

C   Input beam momentum for boost
C      read(1,*) Pb1(1), Pb1(2), Pb1(3), Pb1(4)
C      read(1,*) Pb2(1), Pb2(2), Pb2(3), Pb2(4)
C###### Dummy
      read(1,*) dum(1), dum(2), dum(3), dum(4)
      read(1,*) dum(1), dum(2), dum(3), dum(4)
      Print *,'KK P(e+)= ',Pb1
      Print *,'KK P(e-)= ',Pb2

C   Input c*tau
      read(1,*) ctau
      Print *,'KK ctau= ',ctau

C   Input flag for long lived particle (1:no decay, 0:decay)
      read(1,*) iflong
      Print *,'KK decay switch for long lived particle =',iflong

      close(1)  ! end of input-file open

C   Random seed init for init
      Print *,'KK init random seed for init by ',IRAND1
      CALL PseuMar_Initialize(IRAND1,0,0)
      call kkmc_rand_init(IRAND1+1)

C   KK initialize
      CALL KK2f_ReaDataX(DatX_d, 1,imax,xpar)
      CALL KK2f_ReaDataX(DatX_u, 0,imax,xpar)
      xpar(1)=sqrt((Pb1(4)+Pb2(4))**2-(Pb1(1)+Pb2(1))**2
     &            -(Pb1(2)+Pb2(2))**2-(Pb1(3)+Pb2(3))**2)
      Print *,'KK CMS energy changes to ',xpar(1),' (GeV)'
      CALL KK2f_Initialize(xpar)                  ! initialize generator

C   Pythia initialize
c      call KK_Pythia_output_table  ! output default table (for tempolary use)
c     switch for long lived particle
      if(iflong.eq.1) then
         call PYGIVE('MSTJ(22)=2!No decay for long lived particle')
      endif
c     input particle data file for pythia
      open(1,FILE=DatX_p,ERR=101)
      call PYUPDA(3,1)
      close(1)
      goto 100
 101  Print *,'KK  No input for Pythia'
 100  continue

      call KK_Boost_flush

      end

CCCCCC
      subroutine KK_init_seed
      implicit         none

      integer IRAND1, IRAND2
      real dum(1)
      
C   Get random number seed
      call RANECQ(IRAND1,IRAND2, 1, 'R')
      Print *,'KK random seed: ', IRAND1, IRAND2
C   Initialize random number
      CALL PseuMar_Initialize(IRAND1,0,0)
C      CALL RMARIN(IRAND2,0,0)
      call kkmc_rand_init(IRAND1+1)

      call RANECU(dum,1,1)    ! dummy to increment the seed

      end

CCCCCC
      subroutine KK_term(xSecPb,xErrPb)
      implicit         none

      double precision xSecPb, xErrPb

      CALL KK2f_Finalize
      CALL KK2f_GetXsecMC(xSecPb, xErrPb)         ! get MC x-section

      end

CCCCCC
      subroutine KK_event ( status )
      implicit         none
      integer*4 status
c
c  HepEvt
      INCLUDE 'KK2f/HepEvt.h'
C      integer nmxhep   ! maximum number of particles
C      parameter (nmxhep=4000)
C      double precision phep, vhep
C      integer nevhep, nhep, isthep, idhep, jmohep, jdahep
C      common /HepEvt/
C     &     nevhep,           ! serial number
C     &     nhep,             ! number of particles
C     &     isthep(nmxhep),   ! status code
C     &     idhep(nmxhep),    ! particle ident KF
C     &     jmohep(2,nmxhep), ! parent particles
C     &     jdahep(2,nmxhep), ! children particles
C     &     phep(5,nmxhep),   ! four-momentum, mass [GeV]
C     &     vhep(4,nmxhep)    ! vertex [mm]
C      save /hepevt/
c
     
c
      double precision p(4)
      integer i

      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau

C   Select decay channel
      call KK_select_decay_channel(-15)  !tau+
      call KK_select_decay_channel(15)   !tau-
C   Make single event by KK2f
      CALL KK2f_Make
C   Do subsequent decays by Pythia
      call PYEXEC
      call PYHEPC(1)       ! Pythia -> Hepevt
      
c  test print
C      CALL PYgive('MSTU(11)=16')
C      CALL PYlist(1)
C      CALL PYgive('MSTU(11)=6')
C      CALL PYlist(1)
c
c      Print *,'KK  nhep= ',nhep

C   boost from CM of beam to lab frame of Belle
      do i=1,nhep
         p(1)=phep(1,i)
         p(2)=phep(2,i)
         p(3)=phep(3,i)
         p(4)=phep(4,i)
         call KK_Boost_CM2lab(p)
         phep(1,i)=p(1)
         phep(2,i)=p(2)
         phep(3,i)=p(3)
         phep(4,i)=p(4)
      enddo

C   Shift vertex point due to tau life time
      call KK_ShiftTauDecayVtx

C   HepEvt to panther
      CALL KK_HEPEVT_BBS    

      end

CCCCCC
      subroutine KK_Boost_flush
      implicit none

C  input: Pb1(4), Pb2(4)
C  output: BoostV(3), cosA, sinA

      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau
      double precision Pb4, PbKK(4), dtemp

C   Make boost vector and rotation angle
      Pb4=Pb1(4)+Pb2(4)
      BoostV(1)=(Pb1(1)+Pb2(1))/Pb4
      BoostV(2)=(Pb1(2)+Pb2(2))/Pb4
      BoostV(3)=(Pb1(3)+Pb2(3))/Pb4

C      Alpha=0
      cosA=1.
      sinA=0.
      PbKK(1)=Pb2(1)
      PbKK(2)=Pb2(2)
      PbKK(3)=Pb2(3)
      PbKK(4)=Pb2(4)
C    lab to CM
      BoostV(1)=-BoostV(1)
      BoostV(2)=-BoostV(2)
      BoostV(3)=-BoostV(3)
      call KK_Boost_CM2lab(PbKK)
      BoostV(1)=-BoostV(1)
      BoostV(2)=-BoostV(2)
      BoostV(3)=-BoostV(3)
C      Print *,'KK P(e-,CM)= ',PbKK
C      Alpha=datan2(PbKK(1),PbKK(3))
      dtemp=sqrt(PbKK(1)*PbKK(1)+PbKK(3)*PbKK(3))
      cosA=PbKK(3)/dtemp
      sinA=PbKK(1)/dtemp
C      Print *,'Alpha= ',Alpha
Cc    check
C      PbKK(1)=0
C      PbKK(2)=0
C      PbKK(3)=-5.29
C      PbKK(4)=5.29
C      Print *,'KK P(e+,CM)= ',PbKK
C      call KK_Boost_CM2lab(PbKK)
C      Print *,'KK P(e+)= ',PbKK
C      PbKK(1)=0
C      PbKK(2)=0
C      PbKK(3)=5.29
C      PbKK(4)=5.29
C      Print *,'KK P(e-,CM)= ',PbKK
C      call KK_Boost_CM2lab(PbKK)
C      Print *,'KK P(e-)= ',PbKK

      end

CCCCCC
      subroutine KK_Boost_CM2lab ( p )
      implicit none
      double precision p(4)

      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau

      double precision b2, gamma, gamma2, bp, tpz, dca, dsa


C  rotate
      tpz=p(3)
C      dca = dcos(Alpha)
C      dsa = dsin(Alpha)
C      p(3) = tpz*dca - p(1)*dsa
C      p(1) = tpz*dsa + p(1)*dca
      p(3) = tpz*cosA - p(1)*sinA
      p(1) = tpz*sinA + p(1)*cosA

C  boost
      b2 = BoostV(1)*BoostV(1)+BoostV(2)*BoostV(2)+BoostV(3)*BoostV(3)
      gamma = 1.0 / dsqrt(1.0 - b2)
      bp = BoostV(1)*p(1)+BoostV(2)*p(2)+BoostV(3)*p(3)
      gamma2 = (gamma - 1.0)/b2

      p(1)=p(1)+ gamma2*bp*BoostV(1) + gamma*BoostV(1)*p(4)
      p(2)=p(2)+ gamma2*bp*BoostV(2) + gamma*BoostV(2)*p(4)
      p(3)=p(3)+ gamma2*bp*BoostV(3) + gamma*BoostV(3)*p(4)
      p(4)=gamma*(p(4)+bp)

      end

CCCCCC
      subroutine KK_HEPEVT_BBS
      implicit none
c
c  HepEvt
      INCLUDE 'KK2f/HepEvt.h'
#include "panther/panther.inc"
#include HEPEVT_INC
c
c BBS table
c
c
c Var
c
      Integer * 4      I, J
      BBSOffset        I4, I8
c
c Main
c
c --- clear the table
      Call BsDelEnt( Gen_HEPEVT, BBS_ID_ALL )

c --- loop over the particle
      Do I = 1, NHEP
c    --- a new table
        Call BsNewEnt(Gen_HEPEVT, I4, I8)

c    --- status, particle code, mother
        Gen_HEPEVT_isthep(I4)  = ISTHEP(I)
        Gen_HEPEVT_idhep(I4)   = IDHEP(I)
        Gen_HEPEVT_mother(I4)  = JMOHEP(1,I)

c    --- mother and daughter
        Do J = 1, 2
          Gen_HEPEVT_mo(I4, J) = JMOHEP(J, I)
          Gen_HEPEVT_da(I4, J) = JDAHEP(J, I)
        Enddo

        if(JDAHEP(1,I).eq.0) then
           Gen_HEPEVT_da(I4, 2) = -1
        endif

c    --- four momentum and mass
        Do J = 1, 5
          Gen_HEPEVT_P(I4, J) = PHEP(J, I)
        Enddo

c    --- decay vertex and flight length
        Do J = 1, 4
          Gen_HEPEVT_V(I4, J) = VHEP(J, I)
        Enddo
      Enddo
      Return
      End

CCCCCC
      subroutine KK_GetBeam ( PXH, PYH, PZH, EH, PXL, PYL, PZL, EL )
      implicit none
      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau

      REAL PXH, PYH, PZH, EH, PXL, PYL, PZL, EL

      PXH = Pb2(1)
      PYH = Pb2(2)
      PZH = Pb2(3)
      EH  = Pb2(4)
      PXL = Pb1(1)
      PYL = Pb1(2)
      PZL = Pb1(3)
      EL  = Pb1(4)

      Return
      End

CCCCCC
      subroutine KK_PutBeam ( PXH, PYH, PZH, EH, PXL, PYL, PZL, EL )
      implicit none
      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau

      REAL PXH, PYH, PZH, EH, PXL, PYL, PZL, EL

      Pb2(1) = PXH
      Pb2(2) = PYH
      Pb2(3) = PZH
      Pb2(4) = EH
      Pb1(1) = PXL
      Pb1(2) = PYL
      Pb1(3) = PZL
      Pb1(4) = EL

      Return
      End

CCCCCC
      subroutine KK_ShiftTauDecayVtx
      implicit none

      integer itau,i,j
      double precision p, betagamma, flen, rvec(1), vtx(4)

      double precision Pb1, Pb2, BoostV, cosA, sinA, ctau
      common /KK_cntl/ Pb1(4), Pb2(4), BoostV(3), cosA, sinA, ctau
c  HepEvt
      INCLUDE 'KK2f/HepEvt.h'
      
      do itau=1,2
         do i=1,nhep
            if(idhep(i).eq.(itau*30-45)) then
               p = dsqrt(phep(4,i)*phep(4,i)-phep(5,i)*phep(5,i))
               betagamma = p/phep(5,i)
               call KK_RandExp(rvec,1)
               flen = betagamma*ctau*rvec(1)
               do j=1,4
                  vtx(j) = flen*phep(j,i)/p
               enddo
               call KK_Shift_Daughters_Vtx(i,vtx)
            endif
         enddo
      enddo

      return
      end

CCCCCC
      subroutine KK_Shift_Daughters_Vtx (id, vtx)
      implicit none
      integer id
      double precision vtx(4)
c  HepEvt
      INCLUDE 'KK2f/HepEvt.h'

      integer i(nmxhep)
      
      if((jdahep(1,id).eq.0).or.(jdahep(2,id).eq.0)) return
      
      i(id)=jdahep(1,id)                   ! do i=jdahep(1,id),jdahep(2,id)
 100  continue                             ! for recursive treatment
      call KK_Shift_Vtx(i(id),vtx)
      call KK_Shift_Daughters_Vtx2(i(id),vtx)
      i(id)=i(id)+1
      if(i(id).le.jdahep(2,id)) goto 100

      return
      end
CCCCCC
      subroutine KK_Shift_Daughters_Vtx2(id, vtx)
      implicit none
      integer id
      double precision vtx(4)

      call KK_Shift_Daughters_Vtx(id,vtx)

      return
      end

CCCCCC
      subroutine KK_Shift_Vtx (id, vtx)
      implicit none
      integer id,i
      double precision vtx(4)
c  HepEvt
      INCLUDE 'KK2f/HepEvt.h'

      do i=1,4
         VHEP(i,id) = VHEP(i,id)+vtx(i)
      enddo

      return
      end

CCCCCC
      subroutine KK_RandExp (rvec, len)
      implicit none
      double precision rvec
      integer len
      dimension rvec(*)
      
      real dum(1)
      integer i

      do i=1,len
 100     call RANECU(dum,1,1)
         if(dum(1).eq.0) goto 100
         rvec(i)=-dlog(dble(dum(1)))
      enddo

      return
      end

CCCCCC
      subroutine KK_Pythia_output_table
      implicit none

c     output default pythia parameter table
      open(1,FILE="pythia_table_default.dat")
      call PYGIVE('MSTU(11)=1')
      call PYLOGO
      call PYGIVE('MSTU(11)=6')
      write(1,*)
     &'                              Particle/parton data table'
      write(1,*)
     &'       KC  particle          antiparticle    chg col'//
     &' anti   mass       width       w-cut     lifetime decay'
      write(1,*)
     &'        on/off  ME     Br.rat.      decay products'
      write(1,*)'------------ Above should be deleted. --------------'
      call PYUPDA(1,1)
      close(1)

      return
      end

CCCCCC
      subroutine KK_select_decay_channel (id)
      implicit none
c     id = 15 for tau- , -15 for tau+
      integer id

c     tauola
      integer JAK1,JAK2,JAKP,JAKM,KTOM
      COMMON / JAKI / JAK1,JAK2,JAKP,JAKM,KTOM

c     pythia
      integer MDCY,MDME,KFDP
      double precision BRAT
      COMMON/PYDAT3/MDCY(500,3),MDME(8000,2),BRAT(8000),KFDP(8000,5)
      integer PYCOMP               ! function

      integer KC,KFA,KFS,KFSP,KFSN
      integer NOPE,IDL,IDC
      double precision BRSU,RBR

      real dum(1)
      integer JAK

      KFA=IABS(id)
      if(KFA.ne.15) then
         return
      endif
      KFS=-ISIGN(1,id)  !!! pythia ID is different from PDG
      KC=PYCOMP(KFA)

c     select decay channel using pythia decay table and method

C...Check existence of decay channels. Particle/antiparticle rules.
      IF(MDCY(KC,2).LE.0.OR.MDCY(KC,3).LE.0) THEN
        CALL PYERRM(9,'(PYDECY:) no decay channel defined')
        RETURN
      ENDIF
      IF(KFS.GT.0) THEN
        KFSP=1
        KFSN=0
      ELSE
        KFSP=0
        KFSN=1
      ENDIF
 
C...Sum branching ratios of allowed decay channels.
  220 NOPE=0
      BRSU=0D0
      DO 230 IDL=MDCY(KC,2),MDCY(KC,2)+MDCY(KC,3)-1
        IF(MDME(IDL,1).NE.1.AND.KFSP*MDME(IDL,1).NE.2.AND.
     &  KFSN*MDME(IDL,1).NE.3) GOTO 230
        IF(MDME(IDL,2).GT.100.and.MDME(IDL,2).LT.2100) GOTO 230
        NOPE=NOPE+1
        BRSU=BRSU+BRAT(IDL)
  230 CONTINUE
      IF(NOPE.EQ.0) THEN
        CALL PYERRM(2,'(PYDECY:) all decay channels closed by user')
        RETURN
      ENDIF
 
C...Select decay channel among allowed ones.
  240 call RANECU(dum,1,1)
      RBR=BRSU*dum(1)
      IDL=MDCY(KC,2)-1
  250 IDL=IDL+1
      IF(MDME(IDL,1).NE.1.AND.KFSP*MDME(IDL,1).NE.2.AND.
     &KFSN*MDME(IDL,1).NE.3) THEN
        IF(IDL.LT.MDCY(KC,2)+MDCY(KC,3)-1) GOTO 250
      ELSEIF(MDME(IDL,2).GT.100.and.MDME(IDL,2).LT.2100) THEN
        IF(IDL.LT.MDCY(KC,2)+MDCY(KC,3)-1) GOTO 250
      ELSE
        IDC=IDL
        RBR=RBR-BRAT(IDL)
        IF(IDL.LT.MDCY(KC,2)+MDCY(KC,3)-1.AND.RBR.GT.0D0) GOTO 250
      ENDIF

c     IDC is selected decay channel.
      
      JAK = -1
      if(MDME(IDC,2).GT.2100.and.MDME(IDC,2).LE.2199) then
c     use TAUOLA
         JAK = MDME(IDC,2)-2100
c      else
c     use PYTHIA  JAK=-1
      endif

c     store for TAUOLA
      if(id.eq.15) then
         JAK2 = JAK
      else
         JAK1 = JAK
      endif

      return
      end
