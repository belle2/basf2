#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import config
import subprocess


# determine whether we have an analysis or a local release
analysis = 'BELLE2_ANALYSIS_DIR' in os.environ

# build options
AddOption('--color', dest='color', nargs=1, default='off', action='store',
          help='Enable color output. Possible values are: off, light, dark')
AddOption('--verbose', dest='verbose', action='store_true', default=False, help='Enable verbose output')
if not analysis:
    AddOption('--local', dest='local', action='store_true', default=False,
              help='Enable faster build of local code. No code in the central release should depend on the local code!')
AddOption('--no-symlink', dest='no-symlink', action='store_true', default=False, help='Use copies instead of symbolic links')
AddOption('--extra-libpath', dest='extralibpath', action='store', help='Additional library path')
AddOption('--extra-ccflags', dest='extraccflags', action='store', help='Additional compiler flags')
AddOption('--ignore-externals-version', dest='check_externals', action='store_false', default=True,
          help="if given the externals version will not checked for consistency between .externals and the environment")

SetOption('warn', 'no-fortran-cxx-mix')
try:
    import multiprocessing
    SetOption('num_jobs', multiprocessing.cpu_count())
except:
    pass

setup_message = '-> Execute "setuprel" in your local release directory.'
if analysis:
    setup_message = '-> Execute "setupana" in your local analysis directory.'

# get the sub directory name for architecture and build option dependent files
if 'BELLE2_SUBDIR' not in os.environ:
    print 'Belle II software environment is not set up.'
    print setup_message
    Exit(1)
subdir = os.environ['BELLE2_SUBDIR']

# check for the externals
if 'BELLE2_EXTERNALS_DIR' not in os.environ:
    print 'externals are not set up.'
    print setup_message
    Exit(1)
extsubdir = os.environ.get('BELLE2_EXTERNALS_SUBDIR', subdir)

# check for root
if 'ROOTSYS' not in os.environ:
    print 'root is not set up.'
    print setup_message
    Exit(1)

if GetOption("check_externals"):
    if "BELLE2_EXTERNALS_VERSION" in os.environ and os.path.exists(".externals"):
        ext_version = open(".externals").read().strip()
        if ext_version != os.environ["BELLE2_EXTERNALS_VERSION"]:
            print "externals version (%s) differs from the one defined in .externals (%s)" \
                % (os.environ["BELLE2_EXTERNALS_VERSION"], ext_version)
            print "Please run setuprel again."
            Exit(1)

# create construction environment
global_env = Environment(
    ENV=os.environ,
    tools=['default', 'root_dict', 'sym_link', 'process_dir', 'reg_map', 'output', 'autoclean_dir'],
    BUILDERS={},
    BUILDDIR=os.path.join('#build', subdir),
    INCDIR='#include',
    LIBDIR=os.path.join('#lib', subdir),
    BINDIR=os.path.join('#bin', subdir),
    MODDIR=os.path.join('#modules', subdir),
    DATADIR='#data',
    EXTDIR=os.environ['BELLE2_EXTERNALS_DIR'],
    EXTINCDIR=os.path.join('$EXTDIR', 'include'),
    EXTLIBDIR=os.path.join('$EXTDIR', 'lib', extsubdir),
    EXTBINDIR=os.path.join('$EXTDIR', 'bin', extsubdir),
    LINK='g++',
    SHLINK='g++',
    CCFLAGS=['-Wall', '-isystem$EXTINCDIR'],
    CXXFLAGS=['-std=c++11'],
    CPPDEFINES={'_PACKAGE_': '\\"$PACKAGE\\"'},
    CPPPATH=['include'],
    LIBPATH=['$LIBDIR', '$EXTLIBDIR', os.path.join(os.environ['ROOTSYS'], 'lib')],
    DATAOBJECT_LIBS=[],
    TOOLS_LIBS={},
    TOOLS_LIBPATH={},
    TEST_LIBS=[],
    TEST_FILES=[]
)

# recalculate MD5 sums only if the time stamp differs
global_env.Decider('MD5-timestamp')

# cache implicit dependencies (#includes)
SetOption('implicit_cache', 1)

# include extra library paths and compiler flags
if GetOption('extralibpath'):
    global_env.Append(LIBPATH=GetOption('extralibpath').split(':'))
if GetOption('extraccflags'):
    global_env.Append(CCFLAGS=GetOption('extraccflags').split())

# check for debug flag
option = os.environ['BELLE2_OPTION']
if option == 'debug':
    global_env.Append(CCFLAGS=['-Wextra', '-Wstack-usage=200000', '-g'])
    global_env.Append(FORTRANFLAGS='-g')
elif option == 'opt':
    global_env.Append(CCFLAGS=['-Wextra', '-Wstack-usage=200000', '-O3'])
    global_env.Append(FORTRANFLAGS='-O3')
elif option == 'intel':
    intel_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'icpc')):
            intel_dir = dir
            break
    if not intel_dir:
        print 'Intel compiler not found.'
        Exit(1)
    (base_dir, bin, arch) = intel_dir.rsplit(os.sep, 2)
    global_env.PrependENVPath('INCLUDE', os.path.join(base_dir, 'include'))
    global_env.PrependENVPath('LIB', os.path.join(base_dir, 'lib', arch))
    global_env.PrependENVPath('PATH', intel_dir)
    global_env.PrependENVPath('LD_LIBRARY_PATH', os.path.join(base_dir, 'lib', arch))
    global_env['CC'] = 'icc'
    global_env['CXX'] = 'icpc'
    global_env['FC'] = 'ifort'
    global_env['AR'] = 'xiar'
    global_env['LD'] = 'xild'
    global_env['LINK'] = 'icpc'
    global_env['SHLINK'] = 'icpc'
    global_env.Append(CCFLAGS=['-wd383,981,1419'])
elif option == 'clang':
    clang_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'clang')):
            clang_dir = dir
            break
    if not clang_dir:
        print 'clang compiler not found.'
        Exit(1)
    # clang has trouble with c-files under SL5 due to a problem with the glibc.
    # https://llvm.org/bugs/show_bug.cgi?id=5960
    # So we compile c files with gcc and only c++ with clang for now
    # global_env['CC'] = 'clang'
    global_env['CXX'] = 'clang++'
    global_env.Append(CCFLAGS=['-O2'])
    # make sure clang uses the correct paths to the gcc std c++ and not the
    # system ones. First we disable the default c++ include path
    global_env.Append(CXXFLAGS=["-nostdinc++"])
    # now let's look what gcc uses as includes. Let's call the g++ to give us
    # the search path
    gcc_search_path = subprocess.check_output(["g++", "-v", "-x", "c++", "--syntax-only", "/dev/null"], stderr=subprocess.STDOUT)
    is_search_path = False
    for line in gcc_search_path.splitlines():
        if line.startswith("End of search list"):
            break
        # ok, here we process all lines in the g++ default include path. If they
        # have c++ in the name we take them
        if is_search_path and line.find("c++") >= 0:
            global_env.Append(CXXFLAGS=["-isystem%s" % line.strip()])
        # search path starts after this line
        if line.startswith("#include <...> search starts here:"):
            is_search_path = True
else:
    print 'Aborted because of unknown build option:', option
    Exit(1)


# allow overriding some things from command line (e.g. to enable scan-build)
override_from_environment = ['CC', 'CXX', 'LD']
for v in override_from_environment:
    if v in os.environ:
        print "Note: Overriding variable %s ('%s') from environment ($%s='%s')." % (v, global_env[v], v, os.environ[v])
        global_env[v] = os.environ[v]

# central release
repository = None
if analysis:
    global_env.Append(CCFLAGS=['-I' + os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'include')])
    global_env.Append(LIBPATH=[os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)])
else:
    # use central release as repository if it is set up
    if 'BELLE2_RELEASE_DIR' in os.environ:
        repository = os.environ['BELLE2_RELEASE_DIR']
        global_env.Repository(repository)

# set variant directory for object files
VariantDir(global_env['BUILDDIR'], '.', duplicate=0)


# check for required packages and configure the environment
if (not global_env.GetOption('clean')) and (not global_env.GetOption('help')):
    if not config.configure(global_env):
        Exit(1)

# cling remembers include paths to be able to find them at run-time, so only use -I here
# remove all compiler-specfic warnings, which are not understood by rootcling
global_env['CLINGFLAGS'] = [s.replace('-isystem', '-I') for s in global_env['CCFLAGS']
                            if not (s.startswith("-Wstack-usage") or s.startswith('-wd'))]

special_targets = ['tests', 'test_all', 'include', 'lib', 'bin', 'modules', 'data', 'scripts']
explicit_package_targets = [p.rstrip('/') for p in COMMAND_LINE_TARGETS if p.rstrip('/') not in special_targets and
                            '/' not in p.rstrip('/') and os.path.isdir(p)]

# process the analysis directory
if analysis:
    global_env['PACKAGE'] = os.path.basename(os.environ['BELLE2_ANALYSIS_DIR'])
    global_env.ProcessDirectory('.', True, None)

# process the package directories
else:
    # loop over directory entries and select package directories
    exclude_dirs = ['build', 'include', 'lib', 'bin', 'modules', 'data']
    local_packages = []
    for entry in os.listdir(os.getcwd()):
        if entry.find('.') > -1 or os.path.isfile(entry) or entry in exclude_dirs:
            continue
        if explicit_package_targets and entry not in explicit_package_targets:
            continue

        # we are in a package directory
        global_env['PACKAGE'] = entry
        local_packages.append(entry)

        global_env.ProcessDirectory(entry, False, None)

    # loop over directory entries in central release
    if repository and not GetOption('local'):
        for entry in os.listdir(repository):
            if entry.find('.') > -1 or os.path.isfile(os.path.join(repository, entry)) or entry in exclude_dirs + local_packages:
                continue

            if explicit_package_targets and entry not in explicit_package_targets:
                continue

            # we are in a package directory
            global_env['PACKAGE'] = entry

            global_env.ProcessDirectory(entry, False, repository)


# build global dataobjects library
empty_file = Command(os.path.join(global_env['BUILDDIR'], 'empty.cc'), '', Touch('$TARGET'))
release_libs = []
if analysis:
    for entry in os.listdir(os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)):
        if entry.endswith('_dataobjects' + global_env.subst('$SHLIBSUFFIX')):
            release_libs.append(entry[len(global_env.subst('$SHLIBPREFIX')): -len(global_env.subst('$SHLIBSUFFIX'))])

lib = global_env.SharedLibrary(os.path.join(global_env['LIBDIR'], 'dataobjects'), empty_file,
                               LIBS=global_env['DATAOBJECT_LIBS'] + ['framework'] + release_libs,
                               LINKFLAGS='-Wl,--no-as-needed')
global_env.Alias('lib', lib)

# build global test executable
if len(global_env['TEST_FILES']) > 0:
    test = global_env.Program(os.path.join(global_env['BINDIR'], 'test_all'),
                              global_env['TEST_FILES'], LIBS=global_env['TEST_LIBS'])
    global_env.Alias('test_all', test)
    global_env.Alias('tests', test)

# auto clean include and modules dir
#
# If one renames header files, scons will install the new header but leave the
# old one since it no longer knows about it This can lead to problems because
# if one forgets to fix all includes of that file it will still build/run fine
# on that system but break on other systems. To get rid of this problem, we
# search the include folder and delete all files which would not be
# built/installed by scons

if explicit_package_targets:
    print "Performing a quick build for given packages. Note that any removed targets " \
        "(e.g. modules, include files) will remain until you run a full build without any explicit target packages."
else:
    global_env.RemoveNonTargets(global_env["INCDIR"])
    global_env.RemoveNonTargets(global_env["MODDIR"])
    global_env.RemoveNonTargets(global_env["LIBDIR"])
    global_env.RemoveNonTargets(global_env["BINDIR"])
    global_env.RemoveNonTargets(global_env["DATADIR"])


from SCons.Script.Main import OptionsParser
Help(OptionsParser.format_help() + """
Targets:
  <default> (=no target)        Build everything.
  lib                           Build only libraries.
  bin                           Build only executables.
  modules                       Build only modules.
  tests                         Build only tests.
  test_all                      Build only the overall test executable.
  data                          Build only data files
                                  (copy them to the data directory).
  include                       Build only header files
                                  (copy them to the include directory).
  scripts                       Build only scripts
                                  (copy them to the lib directory).
  <package>                     Build only the code in the given package.
  <package>.<target>            Build only the target in the given package,
                                  where the target can be lib, bin, etc.
  <package>/<dir>               Build only the code in the given subdirectory.
  <package>/<dir>.<target>      Build only the target in the given
                                  subdirectory.
""")
