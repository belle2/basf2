import os, re, platform
from distutils import sysconfig
import config


# build options
AddOption('--color', dest = 'color', nargs = 1, default = 'off', action = 'store', help = 'Enable color output. Possible values are: off, light, dark')
AddOption('--verbose', dest = 'verbose', action = 'store_true', default = False, help='Enable verbose output')
AddOption('--local', dest = 'local', action = 'store_true', default = False, help='Enable faster build of local code. No code in the central release should depend on the local code!')
AddOption('--symlink', dest = 'symlink', action = 'store_true', default = False, help='Use symbolic links instead of copies for header files')
AddOption('--extra-libpath', dest = 'extralibpath', action = 'store', help = 'Additional library path')
AddOption('--extra-ccflags', dest = 'extraccflags', action = 'store', help = 'Additional compiler flags')

SetOption('warn', 'no-fortran-cxx-mix')
try:
    __import__(multiprocessing)
    SetOption('num_jobs', multiprocessing.cpu_count())
except:
    pass

# get the sub directory name for architecture and build option dependent files
if not os.environ.has_key('BELLE2_SUBDIR'):
    print 'Belle II software environment is not set up.'
    print '-> Execute "setuprel" in your local release directory.'
    Exit(1)
subdir = os.environ['BELLE2_SUBDIR']

# check for the externals
if not os.environ.has_key('BELLE2_EXTERNALS_DIR'):
    print 'externals are not set up.'
    print '-> Execute "setuprel" in your local release directory.'
    Exit(1)
extsubdir = os.environ.get('BELLE2_EXTERNALS_SUBDIR', subdir)

# check for root
if not os.environ.has_key('ROOTSYS'):
    print 'root is not set up.'
    print '-> Execute "setuprel" in your local release directory.'
    Exit(1)

# create construction environment
global_env = Environment(ENV = os.environ,
                         tools = ['default', 'root_dict', 'sym_link', 'process_dir', 'reg_map', 'output', 'autoclean_dir'],
                         BUILDERS = {},
                         BUILDDIR = os.path.join('#build', subdir),
                         INCDIR = '#include',
                         LIBDIR = os.path.join('#lib', subdir),
                         BINDIR = os.path.join('#bin', subdir),
                         MODDIR = os.path.join('#modules', subdir),
                         DATADIR = '#data',
                         EXTDIR = os.environ['BELLE2_EXTERNALS_DIR'],
                         EXTINCDIR = os.path.join('$EXTDIR', 'include'),
                         EXTLIBDIR = os.path.join('$EXTDIR', 'lib', extsubdir),
                         EXTBINDIR = os.path.join('$EXTDIR', 'bin', extsubdir),
                         CCFLAGS = ['-Wall', '-I$EXTINCDIR', '-I' + sysconfig.get_python_inc()],
                         CPPDEFINES = {'_PACKAGE_': '\\"$PACKAGE\\"'},
                         CPPPATH = ['include'],
                         LIBPATH = ['$LIBDIR', '$EXTLIBDIR', os.path.join(os.environ['ROOTSYS'], 'lib')],
                         DATAOBJECT_LIBS = [],
                         TOOLS_LIBS = {},
                         TOOLS_LIBPATH = {},
                         TEST_LIBS = [],
                         TEST_FILES = [])

# recalculate MD5 sums only if the time stamp differs
global_env.Decider('MD5-timestamp')

# cache implicit dependencies (#includes)
SetOption('implicit_cache', 1)

# include extra library paths and compiler flags
if GetOption('extralibpath'):
    global_env.Append(LIBPATH = GetOption('extralibpath').split(':'))
if GetOption('extraccflags'):
    global_env.Append(CCFLAGS = GetOption('extraccflags').split())

# check for debug flag
option = os.environ['BELLE2_OPTION']
if option == 'debug':
    global_env.Append(CCFLAGS = ['-Wextra', '-g'])
    global_env.Append(FORTRANFLAGS = '-g')
elif option == 'opt':
    global_env.Append(CCFLAGS = ['-Wextra', '-O3'])
    global_env.Append(FORTRANFLAGS = '-O3')
elif option == 'intel':
    intel_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'icpc')):
            intel_dir = dir
            break
    if not intel_dir:
        print 'Intel compiler not found.'
        Exit(1)
    (base_dir, bin, arch) = intel_dir.rsplit(os.sep, 2)
    global_env.PrependENVPath('INCLUDE', os.path.join(base_dir, 'include'))
    global_env.PrependENVPath('LIB', os.path.join(base_dir, 'lib', arch))
    global_env.PrependENVPath('PATH', intel_dir)
    global_env.PrependENVPath('LD_LIBRARY_PATH', os.path.join(base_dir, 'lib', arch))
    global_env['CC'] = 'icc'
    global_env['CXX'] = 'icpc'
    global_env['FC'] = 'ifort'
    global_env['AR'] = 'xiar'
    global_env['LD'] = 'xild'
    global_env.Append(CCFLAGS = ['-wd383,981,1419'])
elif option == 'clang':
    clang_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'clang')):
            clang_dir = dir
            break
    if not clang_dir:
        print 'clang compiler not found.'
        Exit(1)
    global_env['CC'] = 'clang'
    global_env['CXX'] = 'clang++'
else:
    print 'Aborted because of unknown build option:', option
    Exit(1)

# use central release as repository if it is set up
repository = None
if os.environ.has_key('BELLE2_RELEASE_DIR'):
    repository = os.environ['BELLE2_RELEASE_DIR']
    global_env.Repository(repository)

# set variant directory for object files
VariantDir(global_env['BUILDDIR'], '.', duplicate = 0)


# check for required packages and configure the environment
if (not global_env.GetOption('clean')) and (not global_env.GetOption('help')):
    if not config.configure(global_env):
        Exit(1)

# loop over directory entries and filter out package directories
exclude_dirs = ['build', 'include', 'lib', 'bin', 'modules', 'data']
local_packages = []
for entry in os.listdir(os.getcwd()):
    if entry.find('.') > -1 or os.path.isfile(entry) or entry in exclude_dirs:
        continue

    # we are in a package directory
    global_env['PACKAGE'] = entry
    local_packages.append(entry)

    global_env.ProcessDirectory(entry, False, None)

# loop over directory entries in central release
if repository and not GetOption('local'):
    for entry in os.listdir(repository):
        if entry.find('.') > -1 or os.path.isfile(os.path.join(repository, entry)) or entry in exclude_dirs + local_packages:
            continue

        # we are in a package directory
        global_env['PACKAGE'] = entry

        global_env.ProcessDirectory(entry, False, repository)


# build global dataobjects library
empty_file = Command(os.path.join(global_env['BUILDDIR'], 'empty.cc'), '', Touch('$TARGET'))
lib = global_env.SharedLibrary(os.path.join(global_env['LIBDIR'], 'dataobjects'), empty_file,
                               LIBS = global_env['DATAOBJECT_LIBS'] + ['framework'],
                               LINKFLAGS = '-Wl,--no-as-needed')
global_env.Alias('lib', lib)

# build global test executable
if len(global_env['TEST_FILES']) > 0:
    test = global_env.Program(os.path.join(global_env['BINDIR'], 'test_all'),
                              global_env['TEST_FILES'], LIBS = global_env['TEST_LIBS'])
    global_env.Alias('test_all', test)
    global_env.Alias('tests', test)

# auto clean include and modules dir
#
# If one renames header files, scons will install the new header but leave the
# old one since it no longer knows about it This can lead to problems because
# if one forgets to fix all includes of that file it will still build/run fine
# on that system but break on other systems. To get rid of this problem, we
# search the include folder and delete all files which would not be
# built/installed by scons

global_env.RemoveNonTargets(global_env["INCDIR"])
global_env.RemoveNonTargets(global_env["MODDIR"])


from SCons.Script.Main import OptionsParser
Help(OptionsParser.format_help() + """
Targets:
  <default> (=no target)        Build everything.
  lib                           Build only libraries.
  bin                           Build only executables.
  modules                       Build only modules.
  tests                         Build only tests.
  test_all                      Build only the overall test executable.
  data                          Build only data files
                                  (copy them to the data directory).
  include                       Build only header files
                                  (copy them to the include directory).
  scripts                       Build only scripts
                                  (copy them to the lib directory).
  <package>                     Build only the code in the given package.
  <package>.<target>            Build only the target in the given package,
                                  where the target can be lib, bin, etc.
  <package>/<dir>               Build only the code in the given subdirectory.
  <package>/<dir>.<target>      Build only the target in the given
                                  subdirectory.                                
""")
