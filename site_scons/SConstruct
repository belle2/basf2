import os, re, platform
from distutils import sysconfig
import config


# determine whether we have an analysis or a local release
analysis = os.environ.has_key('BELLE2_ANALYSIS_DIR')

# build options
AddOption('--color', dest = 'color', nargs = 1, default = 'off', action = 'store', help = 'Enable color output. Possible values are: off, light, dark')
AddOption('--verbose', dest = 'verbose', action = 'store_true', default = False, help='Enable verbose output')
if not analysis:
    AddOption('--local', dest = 'local', action = 'store_true', default = False, help='Enable faster build of local code. No code in the central release should depend on the local code!')
AddOption('--symlink', dest = 'symlink', action = 'store_true', default = False, help='Use symbolic links instead of copies')
AddOption('--extra-libpath', dest = 'extralibpath', action = 'store', help = 'Additional library path')
AddOption('--extra-ccflags', dest = 'extraccflags', action = 'store', help = 'Additional compiler flags')

SetOption('warn', 'no-fortran-cxx-mix')
try:
    __import__(multiprocessing)
    SetOption('num_jobs', multiprocessing.cpu_count())
except:
    pass

setup_message = '-> Execute "setuprel" in your local release directory.'
if analysis:
    setup_message = '-> Execute "setupana" in your local analysis directory.'

# get the sub directory name for architecture and build option dependent files
if not os.environ.has_key('BELLE2_SUBDIR'):
    print 'Belle II software environment is not set up.'
    print setup_message
    Exit(1)
subdir = os.environ['BELLE2_SUBDIR']

# check for the externals
if not os.environ.has_key('BELLE2_EXTERNALS_DIR'):
    print 'externals are not set up.'
    print setup_message
    Exit(1)
extsubdir = os.environ.get('BELLE2_EXTERNALS_SUBDIR', subdir)

# check for root
if not os.environ.has_key('ROOTSYS'):
    print 'root is not set up.'
    print setup_message
    Exit(1)

# create construction environment
global_env = Environment(ENV = os.environ,
                         tools = ['default', 'root_dict', 'sym_link', 'process_dir', 'reg_map', 'output', 'autoclean_dir'],
                         BUILDERS = {},
                         BUILDDIR = os.path.join('#build', subdir),
                         INCDIR = '#include',
                         LIBDIR = os.path.join('#lib', subdir),
                         BINDIR = os.path.join('#bin', subdir),
                         MODDIR = os.path.join('#modules', subdir),
                         DATADIR = '#data',
                         EXTDIR = os.environ['BELLE2_EXTERNALS_DIR'],
                         EXTINCDIR = os.path.join('$EXTDIR', 'include'),
                         EXTLIBDIR = os.path.join('$EXTDIR', 'lib', extsubdir),
                         EXTBINDIR = os.path.join('$EXTDIR', 'bin', extsubdir),
                         LINK='g++',
                         SHLINK='g++',
                         CCFLAGS = ['-Wall', '-I$EXTINCDIR', '-I' + sysconfig.get_python_inc(), '-std=c++11'],
                         CPPDEFINES = {'_PACKAGE_': '\\"$PACKAGE\\"'},
                         CPPPATH = ['include'],
                         LIBPATH = ['$LIBDIR', sysconfig.get_config_var('LIBDIR'), '$EXTLIBDIR', os.path.join(os.environ['ROOTSYS'], 'lib')],
                         DATAOBJECT_LIBS = [],
                         TOOLS_LIBS = {},
                         TOOLS_LIBPATH = {},
                         TEST_LIBS = [],
                         TEST_FILES = [])

# recalculate MD5 sums only if the time stamp differs
global_env.Decider('MD5-timestamp')

# cache implicit dependencies (#includes)
SetOption('implicit_cache', 1)

# include extra library paths and compiler flags
if GetOption('extralibpath'):
    global_env.Append(LIBPATH = GetOption('extralibpath').split(':'))
if GetOption('extraccflags'):
    global_env.Append(CCFLAGS = GetOption('extraccflags').split())

# check for debug flag
option = os.environ['BELLE2_OPTION']
if option == 'debug':
    global_env.Append(CCFLAGS = ['-Wextra', '-g'])
    global_env.Append(FORTRANFLAGS = '-g')
elif option == 'opt':
    global_env.Append(CCFLAGS = ['-Wextra', '-O3'])
    global_env.Append(FORTRANFLAGS = '-O3')
elif option == 'intel':
    intel_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'icpc')):
            intel_dir = dir
            break
    if not intel_dir:
        print 'Intel compiler not found.'
        Exit(1)
    (base_dir, bin, arch) = intel_dir.rsplit(os.sep, 2)
    global_env.PrependENVPath('INCLUDE', os.path.join(base_dir, 'include'))
    global_env.PrependENVPath('LIB', os.path.join(base_dir, 'lib', arch))
    global_env.PrependENVPath('PATH', intel_dir)
    global_env.PrependENVPath('LD_LIBRARY_PATH', os.path.join(base_dir, 'lib', arch))
    global_env['CC'] = 'icc'
    global_env['CXX'] = 'icpc'
    global_env['FC'] = 'ifort'
    global_env['AR'] = 'xiar'
    global_env['LD'] = 'xild'
    global_env['LINK'] = 'icpc'
    global_env['SHLINK'] = 'icpc'
    global_env.Append(CCFLAGS = ['-wd383,981,1419'])
elif option == 'clang':
    clang_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'clang')):
            clang_dir = dir
            break
    if not clang_dir:
        print 'clang compiler not found.'
        Exit(1)
    global_env['CC'] = 'clang'
    global_env['CXX'] = 'clang++'
else:
    print 'Aborted because of unknown build option:', option
    Exit(1)

# central release
repository = None
if analysis:
    global_env.Append(CCFLAGS = ['-I' + os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'include')])
    global_env.Append(LIBPATH = [os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)])
else:
    # use central release as repository if it is set up
    if os.environ.has_key('BELLE2_RELEASE_DIR'):
        repository = os.environ['BELLE2_RELEASE_DIR']
        global_env.Repository(repository)

# set variant directory for object files
VariantDir(global_env['BUILDDIR'], '.', duplicate = 0)


# check for required packages and configure the environment
if (not global_env.GetOption('clean')) and (not global_env.GetOption('help')):
    if not config.configure(global_env):
        Exit(1)

# remove C++11 flag for cint
global_env['CINTFLAGS'] = global_env['CCFLAGS'][:]
global_env['CINTFLAGS'].remove('-std=c++11')

# process the analysis directory
if analysis:
    global_env['PACKAGE'] = os.path.basename(os.environ['BELLE2_ANALYSIS_DIR'])
    global_env.ProcessDirectory('.', True, None)

# process the package directories
else:
    # loop over directory entries and select package directories
    exclude_dirs = ['build', 'include', 'lib', 'bin', 'modules', 'data']
    local_packages = []
    for entry in os.listdir(os.getcwd()):
        if entry.find('.') > -1 or os.path.isfile(entry) or entry in exclude_dirs:
            continue

        # we are in a package directory
        global_env['PACKAGE'] = entry
        local_packages.append(entry)

        global_env.ProcessDirectory(entry, False, None)

    # loop over directory entries in central release
    if repository and not GetOption('local'):
        for entry in os.listdir(repository):
            if entry.find('.') > -1 or os.path.isfile(os.path.join(repository, entry)) or entry in exclude_dirs + local_packages:
                continue

            # we are in a package directory
            global_env['PACKAGE'] = entry

            global_env.ProcessDirectory(entry, False, repository)


# build global dataobjects library
empty_file = Command(os.path.join(global_env['BUILDDIR'], 'empty.cc'), '', Touch('$TARGET'))
release_libs = []
if analysis:
    for entry in os.listdir(os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)):
        if entry.endswith('_dataobjects' + global_env.subst('$SHLIBSUFFIX')):
            release_libs.append(entry[len(global_env.subst('$SHLIBPREFIX')): -len(global_env.subst('$SHLIBSUFFIX'))])
    
lib = global_env.SharedLibrary(os.path.join(global_env['LIBDIR'], 'dataobjects'), empty_file,
                               LIBS = global_env['DATAOBJECT_LIBS'] + ['framework'] + release_libs,
                               LINKFLAGS = '-Wl,--no-as-needed')
global_env.Alias('lib', lib)

# build global test executable
if len(global_env['TEST_FILES']) > 0:
    test = global_env.Program(os.path.join(global_env['BINDIR'], 'test_all'),
                              global_env['TEST_FILES'], LIBS = global_env['TEST_LIBS'])
    global_env.Alias('test_all', test)
    global_env.Alias('tests', test)

# auto clean include and modules dir
#
# If one renames header files, scons will install the new header but leave the
# old one since it no longer knows about it This can lead to problems because
# if one forgets to fix all includes of that file it will still build/run fine
# on that system but break on other systems. To get rid of this problem, we
# search the include folder and delete all files which would not be
# built/installed by scons

global_env.RemoveNonTargets(global_env["INCDIR"])
global_env.RemoveNonTargets(global_env["MODDIR"])
global_env.RemoveNonTargets(global_env["LIBDIR"])
global_env.RemoveNonTargets(global_env["BINDIR"])
global_env.RemoveNonTargets(global_env["DATADIR"])


from SCons.Script.Main import OptionsParser
Help(OptionsParser.format_help() + """
Targets:
  <default> (=no target)        Build everything.
  lib                           Build only libraries.
  bin                           Build only executables.
  modules                       Build only modules.
  tests                         Build only tests.
  test_all                      Build only the overall test executable.
  data                          Build only data files
                                  (copy them to the data directory).
  include                       Build only header files
                                  (copy them to the include directory).
  scripts                       Build only scripts
                                  (copy them to the lib directory).
  <package>                     Build only the code in the given package.
  <package>.<target>            Build only the target in the given package,
                                  where the target can be lib, bin, etc.
  <package>/<dir>               Build only the code in the given subdirectory.
  <package>/<dir>.<target>      Build only the target in the given
                                  subdirectory.                                
""")
