#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import config
import subprocess


# determine whether we have an analysis or a local release
analysis = 'BELLE2_ANALYSIS_DIR' in os.environ

# build options
AddOption('--color', dest='color', nargs=1, default='off', action='store',
          help='Enable color output. Possible values are: off, light, dark')
AddOption('--verbose', dest='verbose', action='store_true', default=False, help='Enable verbose output')
if not analysis:
    AddOption('--local', dest='local', action='store_true', default=False,
              help='Enable faster build of local code. No code in the central release should depend on the local code!')
AddOption('--no-symlink', dest='no-symlink', action='store_true', default=False, help='Use copies instead of symbolic links')
AddOption('--extra-libpath', dest='extralibpath', action='store', help='Additional library path')
AddOption('--extra-ccflags', dest='extraccflags', action='store', help='Additional compiler flags')
AddOption('--ignore-externals-version', dest='check_externals', action='store_false', default=True,
          help="if given the externals version will not checked for consistency between .externals and the environment")
AddOption('--light', dest='light', action='store_true', default=False, help='Build a light release')
SetOption('warn', 'no-fortran-cxx-mix')
try:
    import multiprocessing
    SetOption('num_jobs', multiprocessing.cpu_count())
except:
    pass

setup_message = '-> Execute "b2setup" in your local release directory.'
if analysis:
    setup_message = '-> Execute "b2setup" in your local analysis directory.'

# get the sub directory name for architecture and build option dependent files
if 'BELLE2_SUBDIR' not in os.environ:
    print('Belle II software environment is not set up.')
    print(setup_message)
    Exit(1)
subdir = os.environ['BELLE2_SUBDIR']

# check for the externals
if 'BELLE2_EXTERNALS_DIR' not in os.environ:
    print('externals are not set up.')
    print(setup_message)
    Exit(1)
extsubdir = os.environ.get('BELLE2_EXTERNALS_SUBDIR', subdir)

# check for root
if 'ROOTSYS' not in os.environ:
    print('root is not set up.')
    print(setup_message)
    Exit(1)

if GetOption("check_externals"):
    if "BELLE2_EXTERNALS_VERSION" in os.environ and os.path.exists(".externals"):
        ext_version = open(".externals").read().strip()
        if ext_version != os.environ["BELLE2_EXTERNALS_VERSION"]:
            print("externals version (%s) differs from the one defined in .externals (%s)" \
                % (os.environ["BELLE2_EXTERNALS_VERSION"], ext_version))
            print("Please run b2setup again.")
            Exit(1)

# create construction environment
global_env = Environment(
    ENV=os.environ,
    tools=['default', 'root_dict', 'sym_link', 'process_dir', 'reg_map', 'output', 'autoclean_dir',
           'check_libraries', 'strip_debug'],
    BUILDERS={},
    BUILDDIR=os.path.join('#build', subdir),
    INCDIR='#include',
    LIBDIR=os.path.join('#lib', subdir),
    BINDIR=os.path.join('#bin', subdir),
    MODDIR=os.path.join('#modules', subdir),
    DATADIR='#data',
    EXTDIR=os.environ['BELLE2_EXTERNALS_DIR'],
    EXTINCDIR=os.path.join('$EXTDIR', 'include'),
    EXTLIBDIR=os.path.join('$EXTDIR', 'lib', extsubdir),
    EXTBINDIR=os.path.join('$EXTDIR', 'bin', extsubdir),
    LINK='g++',
    SHLINK='g++',
    # for now, add the include folder here, as the path set via
    # CPPPATH below seems to be ignored for C file compiles
    CCFLAGS=['-Wall', '-isystem$EXTINCDIR', '-Iinclude/'],
    CXXFLAGS=['-std=c++17'],
    FORTRANFLAGS=['-std=legacy'],
    # disable warnings when compiling dictionaries, too much root problems
    # involved
    ROOTCLING_EXTRA_CCFLAGS=["-w"],
    CPPDEFINES={'_PACKAGE_': '\\"$PACKAGE\\"'},
    CPPPATH=['include'],
    LIBPATH=['$LIBDIR', '$EXTLIBDIR', os.path.join(os.environ['ROOTSYS'], 'lib')],
    DATAOBJECT_LIBS=[],
    TOOLS_LIBS={},
    TOOLS_LIBPATH={},
    TEST_LIBS=[],
    TEST_FILES=[],
    LINKFLAGS=[
        # don't add library dependencies which we don't actually need
        "-Wl,--as-needed",
        # and make sure we don't allow undefined symbols
        "-Wl,--no-undefined",
        # not even in shared libraries
        "-Wl,--no-allow-shlib-undefined",
        # but, for simplicity let's copy the needed entries from dependent
        # libraries first. That is if a->b and b->c than "a" using symbol from
        # "c" will also compile. This is not 100% what we might want because it
        # leads to implicit dependencies which are hard to track but we get too
        # many errors otherwise, especially since framework/core/Module.h pulls
        # in an dependency to boost_python so let's keep it for now.
        "-Wl,--copy-dt-needed-entries"
    ],
)

# recalculate MD5 sums only if the file changed in the last 10 minutes
SetOption("max_drift", 600)

# cache implicit dependencies (#includes)
SetOption('implicit_cache', 1)

# disable source code checks
global_env.SourceCode(".", None)

# include extra library paths and compiler flags
if GetOption('extralibpath'):
    global_env.Append(LIBPATH=GetOption('extralibpath').split(':'))
if GetOption('extraccflags'):
    global_env.Append(CCFLAGS=GetOption('extraccflags').split())

# check for debug flag
option = os.environ['BELLE2_OPTION']
if option == 'debug':
    global_env.Append(CCFLAGS=['-Wextra', '-Wshadow', '-Wstack-usage=200000', '-g'])
    global_env.Append(FORTRANFLAGS='-g')
elif option == 'opt':
    global_env.Append(CCFLAGS=['-Wextra', '-Wshadow', '-Wstack-usage=200000', '-O3', '-flto'])
    global_env.Append(FORTRANFLAGS='-O3')
    # Parallel LTO avoids sequential bottlenecks when large libraries are
    # linked, but causes oversubscription when linking libraries concurrently.
    # Performance and RAM usage measurements suggest that between these two
    # evils, oversubscription is the better choice.
    global_env.Append(LINKFLAGS='-flto=' + str(GetOption('num_jobs')))
    # LTO requires some binutils wrappers that preserve the GCC IR
    global_env['AR'] = 'gcc-ar'
    global_env['RANLIB'] = 'gcc-ranlib'
elif option == 'intel':
    intel_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'icpc')):
            intel_dir = dir
            break
    if not intel_dir:
        print('Intel compiler not found.')
        Exit(1)
    (base_dir, bin, arch) = intel_dir.rsplit(os.sep, 2)
    global_env.PrependENVPath('INCLUDE', os.path.join(base_dir, 'include'))
    global_env.PrependENVPath('LIB', os.path.join(base_dir, 'lib', arch))
    global_env.PrependENVPath('PATH', intel_dir)
    global_env.PrependENVPath('LD_LIBRARY_PATH', os.path.join(base_dir, 'lib', arch))
    global_env['CC'] = 'icc'
    global_env['CXX'] = 'icpc'
    global_env['FC'] = 'ifort'
    global_env['AR'] = 'xiar'
    global_env['LD'] = 'xild'
    global_env['LINK'] = 'icpc'
    global_env['SHLINK'] = 'icpc'
    global_env.Append(CCFLAGS=['-wd383,981,1292,1419', '-Wshadow'])
elif option == 'clang':
    clang_dir = None
    for dir in os.environ.get('PATH', '').split(os.pathsep):
        if os.path.isfile(os.path.join(dir, 'clang')):
            clang_dir = dir
            break
    if not clang_dir:
        print('clang compiler not found.')
        Exit(1)
    # clang has trouble with c-files under SL5 due to a problem with the glibc.
    # https://llvm.org/bugs/show_bug.cgi?id=5960
    # So we compile c files with gcc and only c++ with clang for now
    # global_env['CC'] = 'clang'
    global_env['CXX'] = 'clang++'
    # enable a few extra warnings warnings but disable the missing braces warning, because it can lead
    # to false positives in conjuction with std::array : https://llvm.org/bugs/show_bug.cgi?id=21629
    global_env.Append(CCFLAGS=["-O2", "-Wno-missing-braces", '-Wshadow', '-Wno-unused-command-line-argument'],
                      CXXFLAGS=["-Wheader-hygiene"])
    # make sure clang uses the correct paths to the gcc std c++ and not the
    # system ones. First we disable the default c++ include path
    global_env.Append(CXXFLAGS=["-nostdinc++"])
    # now let's look what gcc uses as includes. Let's call the g++ to give us
    # the search path. But we have to make sure that gcc is set to english so
    # that the search path works
    gcc_search_path = subprocess.check_output(["g++", "-v", "-x", "c++", "--syntax-only", "/dev/null"],
                                              stderr=subprocess.STDOUT, env=dict(os.environ, LC_ALL="C"), encoding="utf8")
    is_search_path = False
    for line in gcc_search_path.splitlines():
        if line.startswith("End of search list"):
            break
        # ok, here we process all lines in the g++ default include path. If they
        # have c++ in the name we take them
        if is_search_path and line.find("c++") >= 0:
            global_env.Append(CXXFLAGS=["-isystem%s" % line.strip()])
        # search path starts after this line
        if line.startswith("#include <...> search starts here:"):
            is_search_path = True
else:
    print('Aborted because of unknown build option:', option)
    Exit(1)

# allow overriding some things from command line (e.g. to enable scan-build)
override_from_environment = ['CC', 'CXX', 'LD']
for v in override_from_environment:
    if v in os.environ:
        print("Note: Overriding variable %s ('%s') from environment ($%s='%s')." % (v, global_env[v], v, os.environ[v]))
        global_env[v] = os.environ[v]

if os.environ.get("BELLE2_USE_CCACHE", "no").lower() in ["yes", "true", "on", "1"]:
    print("Note: Using ccache to memorize the build.")
    global_env["CC"] = "ccache " + global_env["CC"]
    global_env["CXX"] = "ccache " + global_env["CXX"]
    global_env["ENV"]["CCACHE_BASEDIR"] = Dir("#.").abspath
    # Note :
    # ccache can take a prefix commands with CCACHE_PREFIX like e.g. time
    # It may also replace the compiler with CCACHE_CC for other tools

# central release
repository = None
if analysis:
    global_env.Append(CCFLAGS=['-I' + os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'include')])
    global_env.Append(LIBPATH=[os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)])
else:
    # use central release as repository if it is set up
    if 'BELLE2_RELEASE_DIR' in os.environ:
        repository = os.environ['BELLE2_RELEASE_DIR']
        global_env.Repository(repository)

# set variant directory for object files
VariantDir(global_env['BUILDDIR'], '.', duplicate=0)


# check for required packages and configure the environment
if (not global_env.GetOption('clean')) and (not global_env.GetOption('help')):
    if not config.configure(global_env):
        Exit(1)

# cling remembers include paths to be able to find them at run-time, so only use -I here
# remove all compiler warnings
global_env['CLINGFLAGS'] = ["-std=c++17"] + [s.replace('-isystem', '-I') for s in global_env['CCFLAGS']
                                             if not (s.startswith("-W") or s.startswith('-wd'))] + \
                           ["-noIncludePaths"]

special_targets = ['tests', 'b2test-units', 'include', 'lib', 'bin', 'modules', 'data', 'scripts']
explicit_package_targets = [p.rstrip('/') for p in COMMAND_LINE_TARGETS if p.rstrip('/') not in special_targets and
                            '/' not in p.rstrip('/') and os.path.isdir(p)]

# make the static library containing the main() function for test executables
global_env.Library(os.path.join(global_env['LIBDIR'], 'test_main'), "$BUILDDIR/site_scons/test_main.cc")

# process the analysis directory
if analysis:
    global_env['PACKAGE'] = os.path.basename(os.environ['BELLE2_ANALYSIS_DIR'])
    global_env['AVAILABLE_PACKAGES'] = []
    global_env.ProcessDirectory('.', True, None)

# process the package directories
else:
    # loop over directory entries and select package directories
    exclude_dirs = ['build', 'include', 'lib', 'bin', 'modules', 'data', 'site_scons']
    available_packages = {}
    for entry in os.listdir(os.getcwd()):
        if entry.find('.') > -1 or os.path.isfile(entry) or entry in exclude_dirs:
            continue

        available_packages[entry] = None

    # loop over directory entries in central release
    if repository and not GetOption('local'):
        for entry in os.listdir(repository):
            if (entry.find('.') > -1 or os.path.isfile(os.path.join(repository, entry)) or
               (entry in exclude_dirs + available_packages.keys())):
                continue

            available_packages[entry] = repository

    # retain only packages specified in the .light file if the light option is given
    if GetOption('light'):
        light_path = '.' if os.path.exists('.light') else release
        light_packages = [entry.strip('/') for entry in open(os.path.join(light_path, '.light')).read().split() if entry.endswith('/')]
        selected_packages = {}
        for package in light_packages:
            if package in available_packages.keys():
                selected_packages[package] = available_packages[package]
        available_packages = selected_packages

    # we looped over all of them and know what's available so let's compile
    # whatever was selected
    global_env['AVAILABLE_PACKAGES'] = set(available_packages.keys())
    for package, repository in sorted(available_packages.items()):
        if explicit_package_targets and package not in explicit_package_targets:
            continue
        global_env['PACKAGE'] = package
        global_env.ProcessDirectory(package, False, repository)

    # for global things (e.g. tests) no package should be set
    del global_env['PACKAGE']


# build global dataobjects library
empty_file = Command(os.path.join(global_env['BUILDDIR'], 'empty.cc'), '', Touch('$TARGET'))
release_libs = []
if analysis:
    for entry in os.listdir(os.path.join(os.environ['BELLE2_RELEASE_DIR'], 'lib', subdir)):
        if entry.endswith('_dataobjects' + global_env.subst('$SHLIBSUFFIX')):
            release_libs.append(entry[len(global_env.subst('$SHLIBPREFIX')): -len(global_env.subst('$SHLIBSUFFIX'))])

lib = global_env.SharedLibrary(os.path.join(global_env['LIBDIR'], 'dataobjects'), empty_file,
                               LIBS=global_env['DATAOBJECT_LIBS'] + ['framework'] + release_libs,
                               LINKFLAGS='-Wl,--no-as-needed')
global_env.Alias('lib', lib)

# build global test executable
if len(global_env['TEST_FILES']) > 0:
    test = global_env.Program(os.path.join(global_env['BINDIR'], 'b2test-units'),
                              global_env['TEST_FILES'], LIBS=global_env['TEST_LIBS'])
    global_env.Alias('b2test-units', test)
    global_env.Alias('tests', test)

# build sphinx documentation if the --sphinx option is used
AddOption("--sphinx", dest="sphinx", action="store_true", default=False, help="if given sphinx documentation will be generated")
if global_env.GetOption("sphinx"):
    sphinx_targets = ['html', 'latex']
    for sphinx_target in sphinx_targets:
        tools_doc = global_env.Command('build/tools_doc', [], 'ln -sf %s/doc $TARGET' % os.environ.get('BELLE2_TOOLS'))
        sphinx = global_env.Command('build/%s' % sphinx_target, 'index.rst', 'sphinx-build -b %s -c site_scons/sphinx -d build/doctrees . $TARGET' % sphinx_target)
        global_env.Depends(sphinx, ['scripts', 'data', 'lib', 'bin', tools_doc])
        global_env.SideEffect('PreventParallelSphinxBuilds', sphinx)
        global_env.AlwaysBuild(sphinx)
        global_env.Alias(sphinx_target, sphinx)

# auto clean include and modules dir
#
# If one renames header files, scons will install the new header but leave the
# old one since it no longer knows about it This can lead to problems because
# if one forgets to fix all includes of that file it will still build/run fine
# on that system but break on other systems. To get rid of this problem, we
# search the include folder and delete all files which would not be
# built/installed by scons

if explicit_package_targets:
    print("Performing a quick build for given packages. Note that any removed targets " \
        "(e.g. modules, include files) will remain until you run a full build without any explicit target packages.")
elif not global_env.GetOption('help'):
    # make sure we don't do cleanup on --help
    global_env.RemoveNonTargets(global_env["INCDIR"])
    global_env.RemoveNonTargets(global_env["MODDIR"])
    global_env.RemoveNonTargets(global_env["LIBDIR"])
    global_env.RemoveNonTargets(global_env["BINDIR"])
    global_env.RemoveNonTargets(global_env["DATADIR"])

# run the library dependency check after everything has been declared
global_env.CheckLibraryDependencies()

from SCons.Script.Main import OptionsParser
Help(OptionsParser.format_help() + """
Targets:
  <default> (=no target)        Build everything.
  lib                           Build only libraries.
  bin                           Build only executables.
  modules                       Build only modules.
  tests                         Build only tests.
  b2unittests                   Build only the overall test executable.
  data                          Build only data files
                                  (copy them to the data directory).
  include                       Build only header files
                                  (copy them to the include directory).
  scripts                       Build only scripts
                                  (copy them to the lib directory).
  <package>                     Build only the code in the given package.
  <package>.<target>            Build only the target in the given package,
                                  where the target can be lib, bin, etc.
  <package>/<dir>               Build only the code in the given subdirectory.
  <package>/<dir>.<target>      Build only the target in the given
                                  subdirectory.
""")
