/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2010 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Peter Kvasnicka, Zbynek Drasal                           *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <svd/modules/svdDigitizer/SVDcheater.h>
#include <framework/logging/Logger.h>

using namespace Belle2;

double SVDcheater::getPitchZ(int iLayer, int iLadder, int iSensor) const
{
  switch (iLayer) {
    case 3:
      return m_pitchZ3 * Unit::um;
    case 4:
      return m_pitchZ4 * Unit::um;
    case 5:
      return m_pitchZ5 * Unit::um;
    case 6:
      return m_pitchZ6 * Unit::um;
    default:
      B2FATAL("SVDcheater: Incorrect layer number - should not happen!");
  }
  return 0.0; // in case...
}

double SVDcheater::getPitchRPhi(int iLayer, int iLadder, int iSensor) const
{
  switch (iLayer) {
    case 3:
      return m_pitchRPhi3 * Unit::um;
    case 4:
      return m_pitchRPhi4 * Unit::um;
    case 5:
      return m_pitchRPhi5 * Unit::um;
    case 6:
      return m_pitchRPhi6 * Unit::um;
    default:
      B2FATAL("SVDcheater: Incorrect layer number - should not happen!");
  }
  return 0.0; // in case...
}


double SVDcheater::getResolutionZ(int iLayer, int iLadder, int iSensor, double theta) const
{
  switch (iLayer) {
    case 3:
      return SVD_ResFunc_z3(theta / Unit::deg) * Unit::um;
    case 4:
      return SVD_ResFunc_z4(theta / Unit::deg) * Unit::um;
    case 5:
      return SVD_ResFunc_z5(theta / Unit::deg) * Unit::um;
    case 6:
      return SVD_ResFunc_z6(theta / Unit::deg) * Unit::um;
    default:
      B2FATAL("SVDcheater: Incorrect layer number - should not happen!");
  }
  return 0.0; // in case...
}

double SVDcheater::getResolutionRPhi(int iLayer, int iLadder, int iSensor, double theta) const
{
  switch (iLayer) {
    case 3:
      return SVD_ResFunc_rphi3(theta / Unit::deg) * Unit::um;
    case 4:
      return SVD_ResFunc_rphi4(theta / Unit::deg) * Unit::um;
    case 5:
      return SVD_ResFunc_rphi5(theta / Unit::deg) * Unit::um;
    case 6:
      return SVD_ResFunc_rphi6(theta / Unit::deg) * Unit::um;
    default:
      B2FATAL("SVDcheater: Incorrect layer number - should not happen!");
  }
  return 0.0; // in case...
}

/* Machine-generated spline interpolants */

double SVDcheater::SVD_ResFunc_rphi3(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.205761, 0.207039, 0.212314, 0.225734, 0.240385,
                          0.253165, 0.280112, 0.3003, 0.27027, 0.3003,
                          0.280112, 0.253165, 0.240385, 0.225734, 0.212314,
                          0.207039, 0.205761, 0.207039, 0.212314, 0.225734,
                          0.240385, 0.253165, 0.280112, 0.3003, 0.27027,
                          0.3003, 0.280112, 0.253165, 0.240385, 0.225734,
                          0.212314, 0.207039, 0.205761
                        };
  const double fB[33] = { 0.000156509, 0.00021337, 0.000955882, 0.00157139, 0.00117968,
                          0.00193917, 0.00298186, 0.000274122, 5.41535e-09, -0.000274143,
                          -0.0029818, -0.00193939, -0.00117887, -0.0015744, -0.000944646,
                          -0.000255307, -2.32409e-20, 0.000255307, 0.000944646, 0.0015744,
                          0.00117887, 0.00193939, 0.0029818, 0.000274143, -5.41535e-09,
                          -0.000274122, -0.00298186, -0.00193917, -0.00117968, -0.00157139,
                          -0.000955882, -0.00021337, -0.000156509
                        };
  const double fC[33] = { -1.42982e-05, 1.99843e-05, 5.42669e-05, 7.28377e-06, -4.64548e-05,
                          0.000122404, -1.81359e-05, -0.000252638, 0.000238932, -0.000252639,
                          -1.81262e-05, 0.000122367, -4.63151e-05, 6.76227e-06, 5.62132e-05,
                          1.27207e-05, 1.28099e-05, 1.27207e-05, 5.62132e-05, 6.76227e-06,
                          -4.63151e-05, 0.000122367, -1.81262e-05, -0.000252639, 0.000238932,
                          -0.000252638, -1.81359e-05, 0.000122404, -4.64548e-05, 7.28377e-06,
                          5.42669e-05, 1.99843e-05, 10
                        };
  const double fD[33] = { 1.14275e-06, 1.14275e-06, -1.5661e-06, -1.79129e-06, 5.62864e-06,
                          -4.68467e-06, -7.81673e-06, 8.19282e-06, -8.19285e-06, 7.8171e-06,
                          4.6831e-06, -5.62273e-06, 1.76925e-06, 1.64836e-06, -1.44975e-06,
                          2.97407e-09, -2.97407e-09, 1.44975e-06, -1.64836e-06, -1.76925e-06,
                          5.62273e-06, -4.6831e-06, -7.8171e-06, 8.19285e-06, -8.19282e-06,
                          7.81673e-06, 4.68467e-06, -5.62864e-06, 1.79129e-06, 1.5661e-06,
                          -1.14275e-06, -1.14275e-06, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_rphi4(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.189036, 0.188679, 0.200401, 0.204082, 0.212314,
                          0.224215, 0.230415, 0.226757, 0.204082, 0.226757,
                          0.230415, 0.224215, 0.212314, 0.204082, 0.200401,
                          0.188679, 0.189036, 0.188679, 0.200401, 0.204082,
                          0.212314, 0.224215, 0.230415, 0.226757, 0.204082,
                          0.226757, 0.230415, 0.224215, 0.212314, 0.204082,
                          0.200401, 0.188679, 0.189036
                        };
  const double fB[33] = { -0.00162829, 0.0010626, 0.000787356, 0.000408692, 0.0011519,
                          0.00102378, 0.00018313, -0.000993665, -5.63402e-08, 0.000993891,
                          -0.00018375, -0.00102153, -0.0011603, -0.000377367, -0.000904262,
                          -0.000626301, 0, 0.000626301, 0.000904262, 0.000377367,
                          0.0011603, 0.00102153, 0.00018375, -0.000993891, 5.63402e-08,
                          0.000993665, -0.00018313, -0.00102378, -0.0011519, -0.000408692,
                          -0.000787356, -0.0010626, 0.00162829
                        };
  const double fC[33] = { 0.000208698, 6.03911e-05, -8.79155e-05, 5.00491e-05, 2.4272e-05,
                          -3.70842e-05, -4.69809e-05, -7.06987e-05, 0.000120379, -7.06818e-05,
                          -4.70823e-05, -3.66955e-05, 2.28184e-05, 5.54747e-05, -0.000108164,
                          0.00013596, -7.33302e-05, 0.00013596, -0.000108164, 5.54747e-05,
                          2.28184e-05, -3.66955e-05, -4.70823e-05, -7.06818e-05, 0.000120379,
                          -7.06987e-05, -4.69809e-05, -3.70842e-05, 2.4272e-05, 5.00491e-05,
                          -8.79155e-05, 6.03911e-05, 10
                        };
  const double fD[33] = { -4.94355e-06, -4.94355e-06, 4.59882e-06, -8.59236e-07, -2.04521e-06,
                          -3.29888e-07, -7.90595e-07, 3.18463e-06, -3.18435e-06, 7.86651e-07,
                          3.46227e-07, 1.9838e-06, 1.08854e-06, -5.45463e-06, 8.13748e-06,
                          -6.97635e-06, 6.97635e-06, -8.13748e-06, 5.45463e-06, -1.08854e-06,
                          -1.9838e-06, -3.46227e-07, -7.86651e-07, 3.18435e-06, -3.18463e-06,
                          7.90595e-07, 3.29888e-07, 2.04521e-06, 8.59236e-07, -4.59882e-06,
                          4.94355e-06, 4.94355e-06, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_rphi5(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.184162, 0.185185, 0.194932, 0.198807, 0.201613,
                          0.211416, 0.224719, 0.239808, 0.215827, 0.239808,
                          0.224719, 0.211416, 0.201613, 0.198807, 0.194932,
                          0.185185, 0.184162, 0.185185, 0.194932, 0.198807,
                          0.201613, 0.211416, 0.224719, 0.239808, 0.215827,
                          0.239808, 0.224719, 0.211416, 0.201613, 0.198807,
                          0.194932, 0.185185, 0.184162
                        };
  const double fB[33] = { -0.00097624, 0.000859675, 0.000768453, 0.000153103, 0.000623474,
                          0.0011358, 0.00176517, 0.000320999, -3.37788e-08, -0.000320864,
                          -0.00176555, -0.00113445, -0.000628507, -0.000134322, -0.000838544,
                          -0.000598092, -2.32409e-20, 0.000598092, 0.000838544, 0.000134322,
                          0.000628507, 0.00113445, 0.00176555, 0.000320864, 3.37788e-08,
                          -0.000320999, -0.00176517, -0.0011358, -0.000623474, -0.000153103,
                          -0.000768453, -0.000859675, 0.00097624
                        };
  const double fC[33] = { 0.000139974, 4.36173e-05, -5.27395e-05, -8.79556e-06, 5.58326e-05,
                          -4.59968e-06, 6.75368e-05, -0.000211954, 0.000195903, -0.000211944,
                          6.7476e-05, -4.36661e-06, 5.49611e-05, -5.54267e-06, -6.48796e-05,
                          8.89248e-05, -2.91155e-05, 8.89248e-05, -6.48796e-05, -5.54267e-06,
                          5.49611e-05, -4.36661e-06, 6.7476e-05, -0.000211944, 0.000195903,
                          -0.000211954, 6.75368e-05, -4.59968e-06, 5.58326e-05, -8.79556e-06,
                          -5.27395e-05, 4.36173e-05, 10
                        };
  const double fD[33] = { -3.21189e-06, -3.21189e-06, 1.4648e-06, 2.15427e-06, -2.01441e-06,
                          2.40455e-06, -9.31637e-06, 6.79762e-06, -6.79745e-06, 9.31401e-06,
                          -2.39475e-06, 1.97759e-06, -2.01679e-06, -1.9779e-06, 5.12681e-06,
                          -3.93468e-06, 3.93468e-06, -5.12681e-06, 1.9779e-06, 2.01679e-06,
                          -1.97759e-06, 2.39475e-06, -9.31401e-06, 6.79745e-06, -6.79762e-06,
                          9.31637e-06, -2.40455e-06, 2.01441e-06, -2.15427e-06, -1.4648e-06,
                          3.21189e-06, 3.21189e-06, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_rphi6(double x) const
{
  const int fNp = 31, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 160;
  const double fX[31] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160
                        };
  const double fY[31] = { 0.189036, 0.196078, 0.19802, 0.201613, 0.211864,
                          0.225734, 0.239234, 0.241546, 0.217391, 0.241546,
                          0.239234, 0.225734, 0.211864, 0.201613, 0.19802,
                          0.196078, 0.189036, 0.196078, 0.19802, 0.201613,
                          0.211864, 0.225734, 0.239234, 0.241546, 0.217391,
                          0.241546, 0.239234, 0.225734, 0.211864, 0.201613,
                          0.19802
                        };
  const double fB[31] = { 0.00118019, 0.000338755, 0.000159959, 0.000681752, 0.00126641,
                          0.00148881, 0.000989343, -0.000702508, 4.08355e-08, 0.000702345,
                          -0.000988894, -0.00149045, -0.00126033, -0.000704457, -7.52249e-05,
                          -0.000654985, 2.12231e-12, 0.000654985, 7.52249e-05, 0.000704457,
                          0.00126033, 0.00149045, 0.000988899, -0.000702366, 7.6104e-08,
                          0.000702062, -0.000988062, -0.00149349, -0.00124899, -0.000746771,
                          8.26909e-05
                        };
  const double fC[31] = { -5.86375e-05, -2.55057e-05, 7.62608e-06, 4.45533e-05, 1.39128e-05,
                          8.32733e-06, -5.82745e-05, -0.000110911, 0.000146038, -0.000110923,
                          -5.8201e-05, 8.04557e-06, 1.49663e-05, 4.06208e-05, 2.23024e-05,
                          -8.02784e-05, 0.000145777, -8.02784e-05, 2.23024e-05, 4.06208e-05,
                          1.49664e-05, 8.0453e-06, -5.82e-05, -0.000110927, 0.000146049,
                          -0.000110949, -5.8063e-05, 7.52018e-06, 1.69299e-05, 3.3292e-05,
                          10
                        };
  const double fD[31] = { 1.10439e-06, 1.10439e-06, 1.23091e-06, -1.02135e-06, -1.86181e-07,
                          -2.22006e-06, -1.75454e-06, 4.28248e-06, -4.28268e-06, 1.7574e-06,
                          2.20822e-06, 2.30692e-07, 8.55151e-07, -6.10616e-07, -3.41936e-06,
                          7.53518e-06, -7.53518e-06, 3.41936e-06, 6.10615e-07, -8.55147e-07,
                          -2.30703e-07, -2.20818e-06, -1.75755e-06, 4.28292e-06, -4.2833e-06,
                          1.76288e-06, 2.18611e-06, 3.13657e-07, 5.45404e-07, 5.45404e-07,
                          4.64097
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_z3(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.0609756, 0.123762, 0.115473, 0.0909091, 0.0636943,
                          0.0578035, 0.0531915, 0.0512821, 0.0384615, 0.0512821,
                          0.0531915, 0.0578035, 0.0636943, 0.0909091, 0.115473,
                          0.123762, 0.0609756, 0.123762, 0.115473, 0.0909091,
                          0.0636943, 0.0578035, 0.0531915, 0.0512821, 0.0384615,
                          0.0512821, 0.0531915, 0.0578035, 0.0636943, 0.0909091,
                          0.115473, 0.123762, 0.0609756
                        };
  const double fB[33] = { 0.0120842, 0.00159902, -0.00213093, -0.00293127, -0.00167773,
                          -0.000289499, -0.000315109, -0.00040649, 4.18124e-07, 0.000404817,
                          0.000319708, 0.000272774, 0.00174003, 0.0026988, 0.00299854,
                          -0.00483697, -1.85927e-19, 0.00483697, -0.00299854, -0.0026988,
                          -0.00174003, -0.000272774, -0.000319708, -0.000404817, -4.18124e-07,
                          0.00040649, 0.000315109, 0.000289499, 0.00167773, 0.00293127,
                          0.00213093, -0.00159902, -0.0120842
                        };
  const double fC[33] = { -0.00069314, -0.000355379, -1.76167e-05, -6.24173e-05, 0.000187772,
                          -4.89487e-05, 4.63877e-05, -5.55258e-05, 7.58712e-05, -5.56512e-05,
                          4.71403e-05, -5.18337e-05, 0.000198559, -0.000102683, 0.000132657,
                          -0.000916208, 0.00139991, -0.000916208, 0.000132657, -0.000102683,
                          0.000198559, -5.18337e-05, 4.71403e-05, -5.56512e-05, 7.58712e-05,
                          -5.55258e-05, 4.63877e-05, -4.89487e-05, 0.000187772, -6.24173e-05,
                          -1.76167e-05, -0.000355379, 10
                        };
  const double fD[33] = { 1.12587e-05, 1.12587e-05, -1.49335e-06, 8.33963e-06, -7.89068e-06,
                          3.17788e-06, -3.39711e-06, 2.18995e-06, -2.19204e-06, 3.42638e-06,
                          -3.29913e-06, 8.34643e-06, -1.00414e-05, 7.84466e-06, -3.49622e-05,
                          7.72038e-05, -7.72038e-05, 3.49622e-05, -7.84466e-06, 1.00414e-05,
                          -8.34643e-06, 3.29913e-06, -3.42638e-06, 2.19204e-06, -2.18995e-06,
                          3.39711e-06, -3.17788e-06, 7.89068e-06, -8.33963e-06, 1.49335e-06,
                          -1.12587e-05, -1.12587e-05, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_z4(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.0380228, 0.0595238, 0.100503, 0.08, 0.0684932,
                          0.0543478, 0.0456621, 0.042735, 0.0320513, 0.042735,
                          0.0456621, 0.0543478, 0.0684932, 0.08, 0.100503,
                          0.0595238, 0.0380228, 0.0595238, 0.100503, 0.08,
                          0.0684932, 0.0543478, 0.0456621, 0.042735, 0.0320513,
                          0.042735, 0.0456621, 0.0543478, 0.0684932, 0.08,
                          0.100503, 0.0595238, 0.0380228
                        };
  const double fB[33] = { -0.00308488, 0.00525453, 0.000810657, -0.00235431, -0.000996241,
                          -0.00135638, -0.000427547, -0.000417266, -1.0674e-07, 0.000417693,
                          0.000426373, 0.00136065, 0.000980337, 0.00241365, -0.00103214,
                          -0.00442794, 0, 0.00442794, 0.00103214, -0.00241365,
                          -0.000980337, -0.00136065, -0.000426373, -0.000417693, 1.0674e-07,
                          0.000417266, 0.000427547, 0.00135638, 0.000996241, 0.00235431,
                          -0.000810657, -0.00525453, 0.00308488
                        };
  const double fC[33] = { 0.000736553, 9.73885e-05, -0.000541776, 0.00022528, -8.94733e-05,
                          5.34593e-05, 3.94242e-05, -3.83962e-05, 5.92542e-05, -3.83642e-05,
                          3.92321e-05, 5.41958e-05, -9.22272e-05, 0.000235559, -0.000580138,
                          0.000240558, 0.000202236, 0.000240558, -0.000580138, 0.000235559,
                          -9.22272e-05, 5.41958e-05, 3.92321e-05, -3.83642e-05, 5.92542e-05,
                          -3.83962e-05, 3.94242e-05, 5.34593e-05, -8.94733e-05, 0.00022528,
                          -0.000541776, 9.73885e-05, 10
                        };
  const double fD[33] = { -2.13055e-05, -2.13055e-05, 2.55685e-05, -1.04918e-05, 4.76442e-06,
                          -4.67834e-07, -2.59402e-06, 1.62751e-06, -1.62697e-06, 2.58654e-06,
                          4.98788e-07, -4.88077e-06, 1.09262e-05, -2.71899e-05, 2.73566e-05,
                          -1.27743e-06, 1.27743e-06, -2.73566e-05, 2.71899e-05, -1.09262e-05,
                          4.88077e-06, -4.98788e-07, -2.58654e-06, 1.62697e-06, -1.62751e-06,
                          2.59402e-06, 4.67834e-07, -4.76442e-06, 1.04918e-05, -2.55685e-05,
                          2.13055e-05, 2.13055e-05, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_z5(double x) const
{
  const int fNp = 33, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 180;
  const double fX[33] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160, 170, 180
                        };
  const double fY[33] = { 0.0381679, 0.0578035, 0.0990099, 0.0793651, 0.0694444,
                          0.0537634, 0.0456621, 0.0429185, 0.0321888, 0.0429185,
                          0.0456621, 0.0537634, 0.0694444, 0.0793651, 0.0990099,
                          0.0578035, 0.0381679, 0.0578035, 0.0990099, 0.0793651,
                          0.0694444, 0.0537634, 0.0456621, 0.0429185, 0.0321888,
                          0.0429185, 0.0456621, 0.0537634, 0.0694444, 0.0793651,
                          0.0990099, 0.0578035, 0.0381679
                        };
  const double fB[33] = { -0.00345555, 0.00521238, 0.00085863, -0.00217841, -0.00101462,
                          -0.00144362, -0.000345626, -0.000427376, -1.19565e-07, 0.000427855,
                          0.000344311, 0.0014484, 0.000996801, 0.00224489, -0.00110673,
                          -0.00428647, -3.71854e-19, 0.00428647, 0.00110673, -0.00224489,
                          -0.000996801, -0.0014484, -0.000344311, -0.000427855, 1.19565e-07,
                          0.000427376, 0.000345626, 0.00144362, 0.00101462, 0.00217841,
                          -0.00085863, -0.00521238, 0.00345555
                        };
  const double fC[33] = { 0.000758938, 0.000107855, -0.000543229, 0.000239525, -0.000123145,
                          8.02455e-05, 2.95535e-05, -3.77285e-05, 5.90913e-05, -3.76926e-05,
                          2.93383e-05, 8.10705e-05, -0.00012623, 0.000251039, -0.000586201,
                          0.000268227, 0.000160419, 0.000268227, -0.000586201, 0.000251039,
                          -0.00012623, 8.10705e-05, 2.93383e-05, -3.76926e-05, 5.90913e-05,
                          -3.77285e-05, 2.95535e-05, 8.02455e-05, -0.000123145, 0.000239525,
                          -0.000543229, 0.000107855, 10
                        };
  const double fD[33] = { -2.17028e-05, -2.17028e-05, 2.60918e-05, -1.2089e-05, 6.7797e-06,
                          -1.68973e-06, -2.24273e-06, 1.61366e-06, -1.61307e-06, 2.23436e-06,
                          1.72441e-06, -6.91002e-06, 1.25756e-05, -2.7908e-05, 2.84809e-05,
                          -3.59359e-06, 3.59359e-06, -2.84809e-05, 2.7908e-05, -1.25756e-05,
                          6.91002e-06, -1.72441e-06, -2.23436e-06, 1.61307e-06, -1.61366e-06,
                          2.24273e-06, 1.68973e-06, -6.7797e-06, 1.2089e-05, -2.60918e-05,
                          2.17028e-05, 2.17028e-05, 4.64102
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}

double SVDcheater::SVD_ResFunc_z6(double x) const
{
  const int fNp = 31, fKstep = 0;
  const double fDelta = -1, fXmin = -180, fXmax = 160;
  const double fX[31] = { -180, -170, -160, -150, -140,
                          -130, -120, -110, -90, -70,
                          -60, -50, -40, -30, -20,
                          -10, 0, 10, 20, 30,
                          40, 50, 60, 70, 90,
                          110, 120, 130, 140, 150,
                          160
                        };
  const double fY[31] = { 0.0380228, 0.0584795, 0.0990099, 0.0806452, 0.0694444,
                          0.0546448, 0.0456621, 0.0431034, 0.0323276, 0.0431034,
                          0.0456621, 0.0546448, 0.0694444, 0.0806452, 0.0990099,
                          0.0584795, 0.0380228, 0.0584795, 0.0990099, 0.0806452,
                          0.0694444, 0.0546448, 0.0456621, 0.0431034, 0.0323276,
                          0.0431034, 0.0456621, 0.0546448, 0.0694444, 0.0806452,
                          0.0990099
                        };
  const double fB[31] = { -0.00308327, 0.00511198, 0.000931465, -0.00218815, -0.0010485,
                          -0.00141797, -0.000414326, -0.000387135, -1.06684e-07, 0.000387562,
                          0.000413152, 0.00142224, 0.0010326, 0.00224747, -0.00115283,
                          -0.00428582, 3.21586e-11, 0.00428582, 0.00115283, -0.00224747,
                          -0.00103259, -0.00142226, -0.000413065, -0.000387886, 1.87863e-06,
                          0.000380372, 0.00043373, 0.00134712, 0.00131251, 0.00120295,
                          0.00274531
                        };
  const double fC[31] = { 0.000719156, 0.000100368, -0.00051842, 0.000206458, -9.24928e-05,
                          5.55454e-05, 4.48191e-05, -4.21001e-05, 6.14515e-05, -4.20681e-05,
                          4.46271e-05, 5.62815e-05, -9.52453e-05, 0.000216732, -0.000556762,
                          0.000243463, 0.000185119, 0.000243463, -0.000556762, 0.000216732,
                          -9.52442e-05, 5.62775e-05, 4.46421e-05, -4.21242e-05, 6.16125e-05,
                          -4.26878e-05, 4.80236e-05, 4.3315e-05, -4.67757e-05, 3.58201e-05,
                          10
                        };
  const double fD[31] = { -2.06263e-05, -2.06263e-05, 2.41626e-05, -9.96504e-06, 4.93461e-06,
                          -3.57543e-07, -2.89731e-06, 1.72586e-06, -1.72533e-06, 2.88984e-06,
                          3.88481e-07, -5.05089e-06, 1.03992e-05, -2.57831e-05, 2.66742e-05,
                          -1.9448e-06, 1.94479e-06, -2.66742e-05, 2.57831e-05, -1.03992e-05,
                          5.05072e-06, -3.87845e-07, -2.89221e-06, 1.72895e-06, -1.73834e-06,
                          3.02372e-06, -1.56956e-07, -3.00302e-06, 2.75319e-06, 2.75319e-06,
                          4.64097
                        };
  int klow = 0;
  if (x <= fXmin) klow = 0;
  else if (x >= fXmax) klow = fNp - 1;
  else {
    if (fKstep) {
      // Equidistant knots, use histogramming
      klow = int((x - fXmin) / fDelta);
      if (klow < fNp - 1) klow = fNp - 1;
    } else {
      int khig = fNp - 1, khalf;
      // Non equidistant knots, binary search
      while (khig - klow > 1)
        if (x > fX[khalf=(klow+khig)/2]) klow = khalf;
        else khig = khalf;
    }
  }
  // Evaluate now
  double dx = x - fX[klow];
  return (fY[klow] + dx*(fB[klow] + dx*(fC[klow] + dx*fD[klow])));
}


