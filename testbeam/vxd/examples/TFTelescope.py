#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This steering file will demonstrate one version of track finding in the telescope. It
# will use fitted tracks found using PXD+SVD only and extrapolate them to the telescope planes
# to create a track candidate including clusters from PXD+SVD+Telescope.
# Please Note: - This is only meant as workaround until a proper track finding for the telescope is implemented!!!
#              - Also a proper alignment should be performed before or the extrapolation will not work
import os
from sys import argv
from time import time
from basf2 import *
from beamparameters import add_beamparameters

numEvents = 250

# true if pxd hits should be used for track finding
usePXD = True

# want display?
wantDisplay = False

# magnet on or off
magnetOn = True

# number of tracks generated by the particle gun
numTracks = 1


# nominal sector maps (ie. no layer excluded)
# magnet off svd and pxd
secMaps_MagOff_PXDSVD = {
    'default': 'TB2016Test8Feb2016MagnetOffPXDSVD-moreThan1500MeV_PXDSVD',
}

# magnet off only svd
secMaps_MagOff_SVD = {
    'default': 'TB2016Test8Feb2016MagnetOffSVD-moreThan1500MeV_SVD',
}

# magnet on svd and pxd
secMaps_MagOn_PXDSVD = {
    'default': 'TB2016Test8Feb2016MagnetOnPXDSVD-moreThan1500MeV_PXDSVD',
}

# magnet on only svd
secMaps_MagOn_SVD = {
    'default': 'TB2016Test8Feb2016MagnetOnSVD-moreThan1500MeV_SVD',
}


set_log_level(LogLevel.ERROR)
set_random_seed(12345)

eventinfosetter = register_module('EventInfoSetter')
eventinfosetter.param('expList', [0])
eventinfosetter.param('runList', [1])
eventinfosetter.param('evtNumList', [numEvents])

eventinfoprinter = register_module('EventInfoPrinter')

gearbox = register_module('Gearbox')
gearbox.param('fileName', 'testbeam/vxd/FullVXDTB2016.xml')


pxdDigitizer = register_module('PXDDigitizer')
svdDigitizer = register_module('SVDDigitizer')
telDigitizer = register_module('TelDigitizer')

pxdClusterizer = register_module('PXDClusterizer')
svdClusterizer = register_module('SVDClusterizer')
telClusterizer = register_module('TelClusterizer')


evtgeninput = register_module('EvtGenInput')
evtgeninput.logging.log_level = LogLevel.WARNING

# ParticleGun
particlegun = register_module('ParticleGun')
# number of primaries per event
particlegun.param('nTracks', 1)
# DESY electrons:
particlegun.param('pdgCodes', [11])
# momentum magnitude 2 GeV/c or something above or around.
# At DESY we can have up to 6 GeV/c(+-5%) electron beam.
# Beam divergence divergence and spot size is adjusted similar to reality
# See studies of Benjamin Schwenker
particlegun.param('momentumGeneration', 'normal')
particlegun.param('momentumParams', [6.0, 6.0 * 0.05])
# momentum direction must be around theta=90, phi=180
particlegun.param('thetaGeneration', 'normal')
particlegun.param('thetaParams', [90., 0.005])
particlegun.param('phiGeneration', 'normal')
particlegun.param('phiParams', [0.0, 0.005])
# gun position must be in positive values of x.
# Magnet wall starts at 424mm and ends at 590mm
# Plastic 1cm shielding is at 650mm
# Aluminium target at 750mm to "simulate" 15m air between collimator and TB setup
particlegun.param('vertexGeneration', 'normal')
particlegun.param('xVertexParams', [-100, 0.])
particlegun.param('yVertexParams', [0, 0.3])
particlegun.param('zVertexParams', [0, 0.3])
particlegun.param('independentVertices', True)


geometry = register_module('Geometry')
if not magnetOn:
    geometry.param('excludedComponents', ['MagneticField'])


g4sim = register_module('FullSim')
g4sim.param('StoreAllSecondaries', True)


# key to select the sector map
key = 'default'

# select sector map; differentiate between magnet on/off and pxd+svd and only svd
if magnetOn:
    if usePXD:
        secSetup = secMaps_MagOn_PXDSVD[key]
    else:
        secSetup = secMaps_MagOn_SVD[key]
else:  # magnet off
    if usePXD:
        secSetup = secMaps_MagOff_PXDSVD[key]
    else:
        secSetup = secMaps_MagOff_SVD[key]


# debuggin output
print('the Key: ' + key)
print('SectorMap used ' + secSetup)

# recheck the settings !!!!!!!!
# vxdtf to find the tracks, input is the store array with reduced clusters!!
trackColName = 'caTracks'
vxdtf = register_module('VXDTF')
vxdtf.logging.log_level = LogLevel.DEBUG
vxdtf.logging.debug_level = 2
param_vxdtf = {'sectorSetup': secSetup,
               'GFTrackCandidatesColName': trackColName,  # 'caTracks',
               'tuneCutoffs': 0.51,
               'displayCollector': 2,
               # 'InfoBoardName': 'VXDTFInfoBoard',
               'artificialMomentum': 6.0  # needed for the case with no B-field; do not use as default as it creates strange peak!
               # do _NOT_ set the svdClusterName this will mess up with the hits used in GenFit
               # 'svdClustersName' : clusterColName
               # 'calcQIType': 'kalman'
               }
vxdtf.param(param_vxdtf)
vxdtf.set_name('VXDTF')


GFTracksColName = 'gfTracks'
trackfitter = register_module('GenFitter')
# trackfitter.logging.log_level = LogLevel.ERROR #DEBUG
trackfitter.param('GFTrackCandidatesColName', trackColName)  # 'caTracks')
trackfitter.param('FilterId', 'Kalman')
trackfitter.param('GFTracksColName', GFTracksColName)
trackfitter.param('UseClusters', True)
trackfitter.param('PDGCodes', [11])
trackfitter.set_name('GenFit')


telTF = register_module('TelTrackFinder')
telTF.param('inputTracksName', GFTracksColName)
telTF.param('outputTrackCandsName', 'telTrackCands')
telTF.param('inputClustersName', '')  # name of the telescope clusters
telTF.param('distanceCut', 2)  # distance between track and clusters in units of the fit uncertainty (same cut for u and v)
telTF.param('minTelLayers', 4)  # minmum telescope layers required to accept a track candidate (1..6)
telTF.logging.log_level = LogLevel.WARNING
telTF.logging.debug_level = 1

# use the Genfit module in the testbeam package as the one in the tracking package does not support the telescope
telTrackfitter = register_module('GenFitterVXDTB')
telTrackfitter.param('GFTrackCandidatesColName', 'telTrackCands')  # 'caTracks') ##
telTrackfitter.param('FilterId', 'Kalman')
telTrackfitter.param('GFTracksColName', 'telTracks')
telTrackfitter.param('UseClusters', True)
telTrackfitter.param('PDGCodes', [11])
telTrackfitter.set_name('GenFitTB')

doPXD = 0
if usePXD:
    doPXD = 1
track_finder_mc_truth = register_module('TrackFinderMCTruth')
track_finder_mc_truth.logging.log_level = LogLevel.INFO
# select which detectors you would like to use
param_track_finder_mc_truth = {
    'UseCDCHits': 0,
    'UseSVDHits': 1,
    'UsePXDHits': doPXD,
    'MinimalNDF': 6,
    'WhichParticles': ['primary'],
    'GFTrackCandidatesColName': 'mcTracks',
}
track_finder_mc_truth.param(param_track_finder_mc_truth)


setupGenfit = register_module('SetupGenfitExtrapolation')

eventCounter = register_module('EventCounter')
eventCounter.logging.log_level = LogLevel.INFO
eventCounter.param('stepSize', 25)

analyzer = register_module('TFAnalizer')
analyzer.logging.log_level = LogLevel.INFO
analyzer.logging.debug_level = 11
param_analyzer = {'printExtentialAnalysisData': False, 'caTCname': 'telTrackCands'}
analyzer.param(param_analyzer)


if wantDisplay:
    display = register_module('Display')
    display.param('options', 'HTMS')  # default
    # display.param('assignHitsToPrimaries', 0)
    display.param('showAllPrimaries', False)
    # display.param('showCharged', False)
    display.param('showTrackLevelObjects', True)
    display.param('automatic', False)
    display.param('useClusters', True)
    display.param('fullGeometry', True)
    display.param('showTrackCandidates', True)
    # display.param('GFTrackCandidatesColName', 'caTracksJKL')


log_to_file('VXDTFModuleDemoOutput.txt', append=False)


# Create paths
main = create_path()

main.add_module(eventinfosetter)
main.add_module(eventinfoprinter)
main.add_module(particlegun)
main.add_module(gearbox)
main.add_module(geometry)
main.add_module(setupGenfit)
main.add_module(g4sim)

main.add_module(pxdDigitizer)
main.add_module(pxdClusterizer)
main.add_module(svdDigitizer)
main.add_module(svdClusterizer)
main.add_module(telDigitizer)
main.add_module(telClusterizer)

main.add_module(eventCounter)

# first find tracks in SVD+PXD only (used as input for the telescope track finder)
main.add_module(vxdtf)
main.add_module(trackfitter)

# find tracks including the telescope planes
main.add_module(telTF)
main.add_module(telTrackfitter)

# took this out since mc track finder and analyzer dont support telescope cluster
# main.add_module(track_finder_mc_truth)
# main.add_module(analyzer)


if wantDisplay:
    main.add_module(display)

# print the list of modules
modList = main.modules()
print("\nList of used module")
for modItem in modList:
    print(modItem.type())


# Process events
process(main)


print('Event Statistics :')
print(statistics)
