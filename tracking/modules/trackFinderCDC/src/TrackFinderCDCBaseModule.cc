/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2015 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Oliver Frost                                             *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <tracking/modules/trackFinderCDC/TrackFinderCDCBaseModule.h>

#include <framework/datastore/StoreArray.h>
#include <framework/datastore/StoreObjPtr.h>
#include <framework/dataobjects/EventMetaData.h>

#include <tracking/trackFindingCDC/rootification/StoreWrappedObjPtr.h>

#include <cdc/geometry/CDCGeometryPar.h>

//in type
#include <cdc/dataobjects/CDCHit.h>
#include <tracking/trackFindingCDC/eventtopology/CDCWireHitTopology.h>
#include <tracking/trackFindingCDC/topology/CDCWireTopology.h>

//out type

#include "genfit/TrackCand.h"

using namespace std;
using namespace Belle2;
using namespace TrackFindingCDC;

TrackFinderCDCBaseModule::TrackFinderCDCBaseModule(ETrackOrientation trackOrientation) :
  Module(),
  m_param_cdcHitsStoreArrayName(""),
  m_param_trackOrientationString(""),
  m_param_tracksStoreObjName("CDCTrackVector"),
  m_param_gfTrackCandsStoreArrayName(""),
  m_trackOrientation(trackOrientation)
{
  setDescription("This a base module for all track finders in the CDC");
  addParam("CDCHitsStoreArrayName",
           m_param_cdcHitsStoreArrayName,
           "Name of the input StoreArray of the CDCHits.",
           string(""));

  addParam("TrackOrientation",
           m_param_trackOrientationString,
           "Option which orientation of tracks shall be generate. Valid options are '' (default of the finder), 'none' (one orientation, algorithm dependent), 'symmetric', 'outwards', 'downwards'.",
           string(""));

  addParam("TracksStoreObjName",
           m_param_tracksStoreObjName,
           "Name of the output StoreObjPtr of the tracks generated within this module.",
           std::string("CDCTrackVector"));

  addParam("GFTrackCandsStoreArrayName",
           m_param_gfTrackCandsStoreArrayName,
           "Name of the output StoreArray of the Genfit track candidates generated by this module.",
           string(""));
}

TrackFinderCDCBaseModule::~TrackFinderCDCBaseModule()
{
}

void TrackFinderCDCBaseModule::initialize()
{
  // Input StoreArray of CDCHits
  StoreArray <CDCHit>::required(m_param_cdcHitsStoreArrayName);

  // Output StoreArray
  StoreArray <genfit::TrackCand>::registerPersistent(m_param_gfTrackCandsStoreArrayName);

  StoreWrappedObjPtr< std::vector<CDCTrack> >::registerTransient(m_param_tracksStoreObjName);

  if (m_param_trackOrientationString == string("")) {
    // Keep the default value in this case, if the user did not specify anything.
  } else if (m_param_trackOrientationString == string("none")) {
    m_trackOrientation = c_None;
  } else if (m_param_trackOrientationString == string("symmetric")) {
    m_trackOrientation = c_Symmetric;
  } else if (m_param_trackOrientationString == string("outwards")) {
    m_trackOrientation = c_Outwards;
  } else if (m_param_trackOrientationString == string("downwards")) {
    m_trackOrientation = c_Downwards;
  } else {
    B2WARNING("Unexpected 'TrackOrientation' parameter of track finder module : '" << m_param_trackOrientationString << "'. Default to none");
    m_trackOrientation = c_None;
  }


  // Preload geometry during initialization
  // Marked as unused intentionally to avoid a compile warning
  CDC::CDCGeometryPar& cdcGeo __attribute__((unused)) = CDC::CDCGeometryPar::Instance();
  CDCWireTopology& topo __attribute__((unused)) = CDCWireTopology::getInstance();
}

void TrackFinderCDCBaseModule::beginRun()
{
}

void TrackFinderCDCBaseModule::event()
{
  // Try to fetch the CDCHits from the datastore
  B2DEBUG(100, "Getting the CDCHits from the data store");
  StoreArray <CDCHit> storedCDCHits(m_param_cdcHitsStoreArrayName);
  B2DEBUG(100, "  storedCDCHits.getEntries() == " << storedCDCHits.getEntries());

  // Create the wirehits - translate the CDCHits and attach the geometry.
  B2DEBUG(100, "Creating all CDCWireHits");
  CDCWireHitTopology& wireHitTopology = CDCWireHitTopology::getInstance();
  size_t nHits = wireHitTopology.fill(m_param_cdcHitsStoreArrayName);
  if (nHits == 0) {
    B2WARNING("Event with no hits");
  }


  // Generate the tracks
  std::vector<CDCTrack> generatedTracks;
  generatedTracks.reserve(20);
  generate(generatedTracks);

  // Now aquire the store vector
  StoreWrappedObjPtr< std::vector<CDCTrack> > storedTracks(m_param_tracksStoreObjName);
  storedTracks.create();
  std::vector<CDCTrack>& outputTracks = *storedTracks;

  // Copy Tracks to output fixing their orientation
  if (m_trackOrientation == c_None) {
    std::swap(generatedTracks, outputTracks);
  } else if (m_trackOrientation == c_Symmetric) {
    outputTracks.reserve(2 * generatedTracks.size());
    for (const CDCTrack & track : generatedTracks) {
      outputTracks.push_back(track.reversed());
      outputTracks.push_back(std::move(track));
    }
  } else if (m_trackOrientation == c_Outwards) {
    outputTracks.reserve(generatedTracks.size());
    for (const CDCTrack & track : generatedTracks) {
      outputTracks.push_back(std::move(track));
      CDCTrack& lastTrack = outputTracks.back();
      const CDCRecoHit3D& firstHit = lastTrack.front();
      const CDCRecoHit3D& lastHit = lastTrack.back();
      if (lastHit.getRecoPos3D().polarR() > firstHit.getRecoPos3D().polarR()) {
        lastTrack.reverse();
      }
    }
  } else if (m_trackOrientation == c_Downwards) {
    outputTracks.reserve(generatedTracks.size());
    for (const CDCTrack & track : generatedTracks) {
      outputTracks.push_back(std::move(track));
      CDCTrack& lastTrack = outputTracks.back();
      const CDCRecoHit3D& firstHit = lastTrack.front();
      const CDCRecoHit3D& lastHit = lastTrack.back();
      if (lastHit.getRecoPos3D().y() > firstHit.getRecoPos3D().y()) {
        lastTrack.reverse();
      }
    }
  } else {
    B2WARNING("Unexpected 'TrackOrientation' parameter of track finder module : '" << m_trackOrientation << "'. No tracks generated.");
  }

  // Create the gftracks
  StoreArray<genfit::TrackCand> storedGFTrackCands(m_param_gfTrackCandsStoreArrayName);
  storedGFTrackCands.create();
  for (const CDCTrack & track : outputTracks) {
    genfit::TrackCand gfTrackCand;
    if (track.fillInto(gfTrackCand)) {
      storedGFTrackCands.appendNew(gfTrackCand);
    }
  }
}

void TrackFinderCDCBaseModule::generate(std::vector<CDCTrack>& tracks)
{

}

void TrackFinderCDCBaseModule::endRun()
{
}

void TrackFinderCDCBaseModule::terminate()
{
}
