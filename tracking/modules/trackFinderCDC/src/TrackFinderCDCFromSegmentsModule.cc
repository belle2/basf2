/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2015 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Oliver Frost                                             *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <tracking/modules/trackFinderCDC/TrackFinderCDCFromSegmentsModule.h>

#include <tracking/trackFindingCDC/rootification/StoreWrappedObjPtr.h>

using namespace std;
using namespace Belle2;
using namespace TrackFindingCDC;



TrackFinderCDCFromSegmentsModule::TrackFinderCDCFromSegmentsModule(ETrackOrientation trackOrientation) :
  TrackFinderCDCBaseModule(trackOrientation),
  m_param_segmentsStoreObjName("CDCRecoSegment2DVector"),
  m_minimalHitsForSingleSegmentTrackBySuperLayerId()
{
  if (not hasParam<std::string>("SegmentsStoreObjName")) {
    addParam("SegmentsStoreObjName",
             m_param_segmentsStoreObjName,
             "Name of the output StoreObjPtr of the segments generated by this module.",
             string("CDCRecoSegment2DVector"));
  }

  addParam("MinimalHitsForSingleSegmentTrackBySuperLayerId",
           m_minimalHitsForSingleSegmentTrackBySuperLayerId,
           "Map of super layer ids to minimum hit number, "
           "for which left over segments shall be forwarded as tracks, "
           "if the exceed the minimal hit requirement. Default empty.",
           map<TrackFindingCDC::ISuperLayerType, size_t>());
}



void TrackFinderCDCFromSegmentsModule::initialize()
{
  TrackFinderCDCBaseModule::initialize();

  // Synchronise a possible external definition of SegmentsStoreObjName with the local value.
  // Does nothing in the normal case.
  m_param_segmentsStoreObjName = getParamValue<std::string>("SegmentsStoreObjName");

  StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> >::required(m_param_segmentsStoreObjName);
}



void TrackFinderCDCFromSegmentsModule::generate(std::vector<CDCTrack>& tracks)
{
  // Aquire the store vector
  StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> > storedRecoSegments(m_param_segmentsStoreObjName);
  if (not storedRecoSegments) {
    B2WARNING("The segments have not been created.");
    return;
  }

  std::vector<CDCRecoSegment2D>& segments = *storedRecoSegments;

  // Regenerate the do not use flag
  for (const CDCRecoSegment2D & segment : segments) {
    for (const CDCRecoHit2D & recoHit2D : segment) {
      const CDCWireHit& wireHit = recoHit2D.getWireHit();
      wireHit.getAutomatonCell().unsetDoNotUseFlag();
    }
  }

  generate(segments, tracks);

  if (not m_minimalHitsForSingleSegmentTrackBySuperLayerId.empty()) {
    /// Instance of the leftover single segment tracks creator.
    for (const CDCRecoSegment2D & segment : segments) {
      if (segment.getAutomatonCell().hasDoNotUseFlag()) continue;

      ISuperLayerType iSuperLayer = segment.getISuperLayer();
      if (m_minimalHitsForSingleSegmentTrackBySuperLayerId.count(iSuperLayer) and
          segment.size() >=  m_minimalHitsForSingleSegmentTrackBySuperLayerId[iSuperLayer]) {

        if (segment.getTrajectory2D().isFitted()) {
          tracks.push_back(CDCTrack(segment));
          segment.setAndForwardDoNotUseFlag();
          for (const CDCRecoSegment2D & segment : segments) {
            segment.receiveDoNotUseFlag();
          }
        }
      }
    }
  }
}
