/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2013 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Nils Braun                                               *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <tracking/modules/trackFinderOutputCombiner/NaiveCombinerModule.h>

//datastore types
#include <framework/datastore/StoreArray.h>
#include <framework/datastore/StoreObjPtr.h>
#include <framework/datastore/DataStore.h>

#include <framework/gearbox/Const.h>
#include <cdc/dataobjects/CDCHit.h>

#include <genfit/TrackCand.h>
#include <tracking/mcMatcher/TrackMatchLookUp.h>


using namespace Belle2;

REG_MODULE(NaiveCombiner);

NaiveCombinerModule::NaiveCombinerModule() : Module()
{
  setDescription("Tries to combine the two outputs of two implementations of the track finder algorithm.");

  addParam("TracksFromLegendreFinder",
           m_param_tracksFromLegendreFinder,
           "Good TrackCandidates collection name from the legendre finder.",
           std::string("LegendreTrackCands"));
  addParam("MCTrackCands",
           m_param_mcTrackCands,
           "When UseMCInformation is enabled, you need to set the MCTrackCands here.",
           std::string("MCTrackCands"));

  addParam("CDCHits",
           m_param_cdcHitsColName,
           "Name of the collection containing the tracks generated by a legendre algorithm.",
           std::string("CDCHits"));

  addParam("NotAssignedTracksFromLocalFinder",
           m_param_notAssignedTracksFromLocalFinder,
           "TrackCandidates collection name from the local finder.",
           std::string("LocalTrackCands"));

  addParam("ResultTrackCands",
           m_param_resultTrackCands,
           "TrackCandidates collection name from the combined results of the two recognition algorithm. The CDCHits are assumed to come from the parameter CDCHits.",
           std::string("DumbResultTrackCands"));

  addParam("UseMCInformation",
           m_param_useMCInformation,
           "Uses the MC information from the MCTrackFinder and the MCMatcher to merge tracks.",
           false);
}

void NaiveCombinerModule::initialize()
{
  StoreArray<genfit::TrackCand> legendreTrackCands(m_param_tracksFromLegendreFinder);
  StoreArray<genfit::TrackCand> localTrackCands(m_param_notAssignedTracksFromLocalFinder);

  legendreTrackCands.isRequired();
  localTrackCands.isRequired();

  StoreArray<CDCHit> cdcHits(m_param_cdcHitsColName);

  StoreArray<genfit::TrackCand> resultTrackCands(m_param_resultTrackCands);
  resultTrackCands.registerInDataStore();

  if (m_param_useMCInformation) {
    StoreArray<genfit::TrackCand> mcTrackCands(m_param_mcTrackCands);
    mcTrackCands.isRequired();
    mcTrackCands.requireRelationTo(legendreTrackCands);
    mcTrackCands.requireRelationTo(localTrackCands);
  }
}

void addTrackToTrack(const genfit::TrackCand& trackCand, genfit::TrackCand* otherTrackCand)
{
  for (int cdcHitID : trackCand.getHitIDs(Const::CDC)) {
    otherTrackCand->addHit(Const::CDC, cdcHitID);
  }
}

void NaiveCombinerModule::event()
{
  StoreArray<genfit::TrackCand> resultTrackCandsDumb(m_param_resultTrackCands);
  StoreArray<genfit::TrackCand> goodTrackCands(m_param_tracksFromLegendreFinder);
  StoreArray<genfit::TrackCand> localTrackCands(m_param_notAssignedTracksFromLocalFinder);

  // if we do not use the mc information, we just throw all the tracks into one store array
  // if we use the mc information we add up all the track cands that are matched together
  if (not m_param_useMCInformation) {
    for (const genfit::TrackCand& trackCand : goodTrackCands) {
      resultTrackCandsDumb.appendNew(trackCand);
    }
    for (const genfit::TrackCand& trackCand : localTrackCands) {
      resultTrackCandsDumb.appendNew(trackCand);
    }
  } else {
    StoreArray<genfit::TrackCand> mcTrackCands(m_param_mcTrackCands);

    TrackMatchLookUp trackMatchLookUpForLegendre(m_param_mcTrackCands, m_param_tracksFromLegendreFinder);
    TrackMatchLookUp trackMatchLookUpForLocal(m_param_mcTrackCands, m_param_notAssignedTracksFromLocalFinder);

    std::vector<std::vector<genfit::TrackCand>> legendreTrackList;
    std::vector<std::vector<genfit::TrackCand>> localTrackList;

    std::map<const genfit::TrackCand*, int> mcTrackCandToIdMap;

    for (int mcID = 0; mcID < mcTrackCands.getEntries(); mcID++) {
      const genfit::TrackCand* mcTrackCand = mcTrackCands[mcID];
      mcTrackCandToIdMap[mcTrackCand] = mcID;
    }

    legendreTrackList.resize(mcTrackCands.getEntries());
    localTrackList.resize(mcTrackCands.getEntries());

    for (const genfit::TrackCand& legendreTrackCand : goodTrackCands) {
      const genfit::TrackCand* matchedMCTrackCand = trackMatchLookUpForLegendre.getMatchedMCTrackCand(legendreTrackCand);
      if (matchedMCTrackCand != nullptr) {
        B2INFO(mcTrackCandToIdMap[matchedMCTrackCand])
        legendreTrackList[mcTrackCandToIdMap[matchedMCTrackCand]].push_back(legendreTrackCand);
      }
    }

    for (const genfit::TrackCand& localTrackCand : localTrackCands) {
      const genfit::TrackCand* matchedMCTrackCand = trackMatchLookUpForLocal.getMatchedMCTrackCand(localTrackCand);

      if (matchedMCTrackCand != nullptr) {
        B2INFO(mcTrackCandToIdMap[matchedMCTrackCand])
        localTrackList[mcTrackCandToIdMap[matchedMCTrackCand]].push_back(localTrackCand);
      }
    }

    for (int mcID = 0; mcID < mcTrackCands.getEntries(); mcID++) {
      if (legendreTrackList[mcID].size() > 0 or localTrackList[mcID].size() > 0) {
        genfit::TrackCand* resultTrackCand = resultTrackCandsDumb.appendNew();
        for (const genfit::TrackCand& legendreTrackCand : legendreTrackList[mcID]) {
          addTrackToTrack(legendreTrackCand, resultTrackCand);
        }
        for (const genfit::TrackCand& localTrackCand : localTrackList[mcID]) {
          addTrackToTrack(localTrackCand, resultTrackCand);
        }
      }
    }
  }
}

