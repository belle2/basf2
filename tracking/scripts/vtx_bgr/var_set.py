##########################################################################
# basf2 (Belle II Analysis Software Framework)                           #
# Author: The Belle II Collaboration                                     #
#                                                                        #
# See git log for contributors and copyright holders.                    #
# This file is licensed under LGPL-3.0, see LICENSE.md.                  #
##########################################################################


import numpy as np
import math
from ROOT import Belle2, TVector3

# Name of target variable for training
target = 'isSignal'

# Names of input variables
var_set = [
    "x_pos_0",
    "y_pos_0",
    "z_pos_0",
    "layer_0",
    "size_0",
    "sizeU_0",
    "sizeV_0",
    "seedCharge_0",
    "clusterCharge_0",
    "x_pos_1",
    "y_pos_1",
    "z_pos_1",
    "layer_1",
    "size_1",
    "sizeU_1",
    "sizeV_1",
    "seedCharge_1",
    "clusterCharge_1",
    "x_pos_2",
    "y_pos_2",
    "z_pos_2",
    "layer_2",
    "size_2",
    "sizeU_2",
    "sizeV_2",
    "seedCharge_2",
    "clusterCharge_2",
    "x_pos_3",
    "y_pos_3",
    "z_pos_3",
    "layer_3",
    "size_3",
    "sizeU_3",
    "sizeV_3",
    "seedCharge_3",
    "clusterCharge_3",
    "seed_pT",
    "seed_tanLambda",
    "first_vtx_layer",
    "last_vtx_layer",
]


def extract_target(reco_track):
    """
    Returns classifier label (target) for input Belle2.RecoTrack
    The track is Signal, if all VTXClusters have a related VTXTrueHit.
    Tracks from background overlay do not have VTXTrueHits and are not signal.

    Args:
    reco_track: Belle2.RecoTrack

    Returns:
    bool: truth target (or label) of input reco_track

    """

    for hit in reco_track.getSortedVTXHitList():
        trueHit = hit.getRelated('VTXTrueHits')
        if not trueHit:
            return False

    return True


def extract_features(reco_track):
    """
    Returns array of features values extracted from Belle2.RecoTrack.

    Args:
    reco_track: Belle2.RecoTrack

    Returns:
    np.ndarray: Array of features of reco_track.
    """

    # Output array
    data = np.zeros((len(var_set),))

    # List of VTXClusters associated with track
    vtx_hits = reco_track.getSortedVTXHitList()

    # Hit 0
    hit = vtx_hits[0]
    sensor_info = Belle2.VXD.GeoCache.get(hit.getSensorID())
    position = sensor_info.pointToGlobal(TVector3(hit.getU(), hit.getV(), 0), True)

    data[0] = position.X()
    data[1] = position.Y()
    data[2] = position.Z()
    data[3] = hit.getSensorID().getLayerNumber()
    data[4] = hit.getSize()
    data[5] = hit.getUSize()
    data[6] = hit.getVSize()
    data[7] = hit.getSeedCharge()
    data[8] = hit.getCharge()

    # Hit 1
    hit = vtx_hits[1]
    sensor_info = Belle2.VXD.GeoCache.get(hit.getSensorID())
    position = sensor_info.pointToGlobal(TVector3(hit.getU(), hit.getV(), 0), True)

    data[9] = position.X()
    data[10] = position.Y()
    data[11] = position.Z()
    data[12] = hit.getSensorID().getLayerNumber()
    data[13] = hit.getSize()
    data[14] = hit.getUSize()
    data[15] = hit.getVSize()
    data[16] = hit.getSeedCharge()
    data[17] = hit.getCharge()

    # Hit 2
    hit = vtx_hits[2]
    sensor_info = Belle2.VXD.GeoCache.get(hit.getSensorID())
    position = sensor_info.pointToGlobal(TVector3(hit.getU(), hit.getV(), 0), True)

    data[18] = position.X()
    data[19] = position.Y()
    data[20] = position.Z()
    data[21] = hit.getSensorID().getLayerNumber()
    data[22] = hit.getSize()
    data[23] = hit.getUSize()
    data[24] = hit.getVSize()
    data[25] = hit.getSeedCharge()
    data[26] = hit.getCharge()

    # Hit 3
    if len(vtx_hits) <= 3:
        data[27] = 0
        data[28] = 0
        data[29] = 0
        data[30] = 0
        data[31] = 0
        data[32] = 0
        data[33] = 0
        data[34] = 0
        data[35] = 0
    else:
        hit = vtx_hits[3]
        sensor_info = Belle2.VXD.GeoCache.get(hit.getSensorID())
        position = sensor_info.pointToGlobal(TVector3(hit.getU(), hit.getV(), 0), True)

        data[27] = position.X()
        data[28] = position.Y()
        data[29] = position.Z()
        data[30] = hit.getSensorID().getLayerNumber()
        data[31] = hit.getSize()
        data[32] = hit.getUSize()
        data[33] = hit.getVSize()
        data[34] = hit.getSeedCharge()
        data[35] = hit.getCharge()

    # Variables from the track fit seed generated by VXDTF2 fitters, not estimate of a full track fit.
    # Presently, the TripletFit is used. But this may change.
    # qi = reco_track.getQualityIndicator()
    momentum = reco_track.getMomentumSeed()
    seed_pt = momentum.Perp()
    # seed_mom = momentum.Mag()
    seed_tan_lambda = np.divide(1.0, math.tan(momentum.Theta()))

    data[36] = seed_pt
    data[37] = seed_tan_lambda

    layers = [hit.getSensorID().getLayerNumber() for hit in vtx_hits]
    data[38] = min(layers)
    data[39] = max(layers)

    return data
