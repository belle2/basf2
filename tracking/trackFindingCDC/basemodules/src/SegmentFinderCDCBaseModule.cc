/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2015 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Oliver Frost                                             *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/
#include <tracking/trackFindingCDC/basemodules/SegmentFinderCDCBaseModule.h>

#include <tracking/trackFindingCDC/rootification/StoreWrappedObjPtr.h>

#include <tracking/trackFindingCDC/mclookup/CDCMCTrackStore.h>
#include <tracking/trackFindingCDC/mclookup/CDCSimHitLookUp.h>

#include <tracking/trackFindingCDC/fitting/CDCRiemannFitter.h>
#include <tracking/trackFindingCDC/eventtopology/CDCWireHitTopology.h>

#include <framework/datastore/StoreArray.h>


using namespace std;
using namespace Belle2;
using namespace TrackFindingCDC;

SegmentFinderCDCBaseModule::SegmentFinderCDCBaseModule(ETrackOrientation segmentOrientation) :
  TrackFinderCDCBaseModule(),
  m_param_segmentsStoreObjName("CDCRecoSegment2DVector"),
  m_param_segmentOrientationString(""),
  m_param_fitSegments(true),
  m_param_createGFTrackCands(false),
  m_segmentOrientation(segmentOrientation)
{
  addParam("SegmentsStoreObjName",
           m_param_segmentsStoreObjName,
           "Name of the output StoreObjPtr of the segments generated by this module.",
           string(m_param_segmentsStoreObjName));

  addParam("FitSegments",
           m_param_fitSegments,
           "Switch to indicate if the segments shall be fitted after they have been generated.",
           bool(m_param_fitSegments));

  addParam("SegmentOrientation",
           m_param_segmentOrientationString,
           "Option which orientation of segments shall be generate. Valid options are '' (default of the finder), 'none' (one orientation, algorithm dependent), 'symmetric', 'outwards', 'downwards'.",
           string(m_param_segmentOrientationString));

  addParam("CreateGFTrackCands",
           m_param_createGFTrackCands,
           "Switch for the creation of one genfit::TrackCand for each segment.",
           bool(m_param_createGFTrackCands));

}


void SegmentFinderCDCBaseModule::initialize()
{
  TrackFinderCDCBaseModule::initialize();
  StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> >::registerTransient(m_param_segmentsStoreObjName);

  if (m_param_segmentOrientationString == string("")) {
    // Keep the default value in this case, if the user did not specify anything.
  } else if (m_param_segmentOrientationString == string("none")) {
    m_segmentOrientation = c_None;
  } else if (m_param_segmentOrientationString == string("symmetric")) {
    m_segmentOrientation = c_Symmetric;
  } else if (m_param_segmentOrientationString == string("outwards")) {
    m_segmentOrientation = c_Outwards;
  } else if (m_param_segmentOrientationString == string("downwards")) {
    m_segmentOrientation = c_Downwards;
  } else {
    B2WARNING("Unexpected 'SegmentOrientation' parameter of segment finder module : '" << m_param_segmentOrientationString <<
              "'. Defaults to none");
    m_segmentOrientation = c_None;
  }

}

void SegmentFinderCDCBaseModule::event()
{
  size_t nHits = prepareHits();
  if (nHits == 0) return;

  // Generate the segments
  std::vector<CDCRecoSegment2D> generatedSegments;
  generatedSegments.reserve(90);
  generateSegments(generatedSegments);

  if (generatedSegments.size() != 0) {

    // Fit the segments if requested
    if (m_param_fitSegments) {
      const CDCRiemannFitter& fitter = CDCRiemannFitter::getFitter();
      for (const CDCRecoSegment2D& segment : generatedSegments) {
        CDCTrajectory2D& trajectory2D = segment.getTrajectory2D();
        fitter.update(trajectory2D, segment);
      }
    }

    // Now aquire the store vector
    StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> > storedRecoSegments(m_param_segmentsStoreObjName);
    storedRecoSegments.create();
    std::vector<CDCRecoSegment2D>& outputSegments = *storedRecoSegments;
    outputSegments.clear();

    /// Copy segments to output fixing their segmentOrientation
    if (m_segmentOrientation == c_None) {
      std::swap(generatedSegments, outputSegments);
    } else if (m_segmentOrientation == c_Symmetric) {
      outputSegments.reserve(2 * generatedSegments.size());
      for (const CDCRecoSegment2D& segment : generatedSegments) {
        outputSegments.push_back(segment.reversed());
        outputSegments.push_back(std::move(segment));
      }
    } else if (m_segmentOrientation == c_Outwards) {
      outputSegments.reserve(generatedSegments.size());
      for (const CDCRecoSegment2D& segment : generatedSegments) {
        outputSegments.push_back(std::move(segment));
        CDCRecoSegment2D& lastSegment = outputSegments.back();
        const CDCRecoHit2D& firstHit = lastSegment.front();
        const CDCRecoHit2D& lastHit = lastSegment.back();
        if (lastHit.getRecoPos2D().cylindricalR() < firstHit.getRecoPos2D().cylindricalR()) {
          lastSegment.reverse();
        }
      }
    } else if (m_segmentOrientation == c_Downwards) {
      outputSegments.reserve(generatedSegments.size());
      for (const CDCRecoSegment2D& segment : generatedSegments) {
        outputSegments.push_back(std::move(segment));
        CDCRecoSegment2D& lastSegment = outputSegments.back();
        const CDCRecoHit2D& firstHit = lastSegment.front();
        const CDCRecoHit2D& lastHit = lastSegment.back();
        if (lastHit.getRecoPos2D().y() > firstHit.getRecoPos2D().y()) {
          lastSegment.reverse();
        }
      }
    } else {
      B2WARNING("Unexpected 'SegmentOrientation' parameter of segment finder module : '" << m_segmentOrientation <<
                "'. No segments generated.");
    }


    // Put code to generate gf track cands here if requested.
    if (m_param_createGFTrackCands) {
      StoreArray<genfit::TrackCand> storedGFTrackCands(m_param_gfTrackCandsStoreArrayName);
      storedGFTrackCands.create();
      for (const CDCRecoSegment2D& segment : outputSegments) {
        genfit::TrackCand* ptrTrackCand = storedGFTrackCands.appendNew();
        segment.fillInto(*ptrTrackCand);
      }
    }
  }

  copyRemainingHits();
}


