/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2015 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Oliver Frost                                             *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#include <tracking/trackFindingCDC/basemodules/TrackFinderCDCFromSegmentsModule.h>

#include <tracking/trackFindingCDC/rootification/StoreWrappedObjPtr.h>

using namespace std;
using namespace Belle2;
using namespace TrackFindingCDC;



TrackFinderCDCFromSegmentsModule::TrackFinderCDCFromSegmentsModule() :
  TrackFinderCDCBaseModule(),
  m_param_segmentsStoreObjName("CDCRecoSegment2DVector"),
  m_minimalHitsForSingleSegmentTrackBySuperLayerId()
{
  if (not hasParam<std::string>("SegmentsStoreObjName")) {
    addParam("SegmentsStoreObjName",
             m_param_segmentsStoreObjName,
             "Name of the output StoreObjPtr of the segments generated by this module.",
             string("CDCRecoSegment2DVector"));
  }

  addParam("MinimalHitsForSingleSegmentTrackBySuperLayerId",
           m_minimalHitsForSingleSegmentTrackBySuperLayerId,
           "Map of super layer ids to minimum hit number, "
           "for which left over segments shall be forwarded as tracks, "
           "if the exceed the minimal hit requirement. Default empty.",
           map<TrackFindingCDC::ISuperLayer, size_t>());
}



void TrackFinderCDCFromSegmentsModule::initialize()
{
  TrackFinderCDCBaseModule::initialize();

  // Synchronise a possible external definition of SegmentsStoreObjName with the local value.
  // Does nothing in the normal case.
  m_param_segmentsStoreObjName = getParamValue<std::string>("SegmentsStoreObjName");

  StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> >::required(m_param_segmentsStoreObjName);
}



void TrackFinderCDCFromSegmentsModule::generate(std::vector<CDCTrack>& tracks)
{
  // Aquire the store vector
  StoreWrappedObjPtr< std::vector<CDCRecoSegment2D> > storedRecoSegments(m_param_segmentsStoreObjName);
  if (not storedRecoSegments) {
    B2WARNING("The segments have not been created.");
    return;
  }

  std::vector<CDCRecoSegment2D>& segments = *storedRecoSegments;

  generate(segments, tracks);

  // Create tracks from left over segments
  for (const CDCRecoSegment2D& segment : segments) {
    segment.unsetAndForwardMaskedFlag();
  }

  for (const CDCTrack& track : tracks) {
    track.unsetAndForwardMaskedFlag();
  }

  for (const CDCRecoSegment2D& segment : segments) {
    segment.receiveMaskedFlag();
  }


  if (not m_minimalHitsForSingleSegmentTrackBySuperLayerId.empty()) {

    for (const CDCRecoSegment2D& segment : segments) {
      if (segment.getAutomatonCell().hasMaskedFlag()) continue;

      ISuperLayer iSuperLayer = segment.getISuperLayer();
      if (m_minimalHitsForSingleSegmentTrackBySuperLayerId.count(iSuperLayer) and
          segment.size() >=  m_minimalHitsForSingleSegmentTrackBySuperLayerId[iSuperLayer]) {

        if (segment.getTrajectory2D().isFitted()) {
          tracks.push_back(CDCTrack(segment));
          segment.setAndForwardMaskedFlag();
          for (const CDCRecoSegment2D& segment : segments) {
            segment.receiveMaskedFlag();
          }
        }
      }
    }
  }
}
