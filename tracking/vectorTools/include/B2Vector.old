/**************************************************************************
 * BASF2 (Belle Analysis Framework 2)                                     *
 * Copyright(C) 2013 - Belle II Collaboration                             *
 *                                                                        *
 * Author: The Belle II Collaboration                                     *
 * Contributors: Jakob Lettenbichler                                      *
 *               Eugenio Paoloni                                          *
 *                                                                        *
 * This software is provided "as is" without any warranty.                *
 **************************************************************************/

#pragma once

// #include <tracking/trackFindingVXD/FilterTools/TBranchLeafType.h>


#include <framework/core/FrameworkExceptions.h>
#include <framework/logging/Logger.h>

#include <TBranch.h>
#include <TTree.h>
#include <string>

#include <typeinfo>
#include <cxxabi.h>

#include <algorithm>    // std::move (ranges)
#include <utility>      // std::move (objects)

#include <type_traits>

namespace Belle2 {

  /** A fast and root compatible alternative to TVector3.
   *
   * Goals:
   * - vectorizable
   * - root compatible
   * - fixed size
   * - featureset comparable to TVector3
   * - interface/member functions compatible to TVector3
   * 
   * DataType: shall be the data type one wants to store in the B2Vector (e.g. double)
   * nSize: number of entries in the vector (e.g. 3, like TVector3)
   */

  template< typename DataType>
  class B2Vector3 {
	DataType m_coordinates[3];
  public:



/** *********************************************** EXCEPTIONS *********************************************** */


	/** this exception is thrown by the CircleFit and occurs when the track is too straight */
	BELLE2_DEFINE_EXCEPTION(outOfBounds, "B2Vector3::access operator: given index is out of bounds!");



/** *********************************************** CONSTRUCTORS *********************************************** */


	/** Constructor expecting 3 coordinates */
	B2Vector3( const DataType x, const DataType y, const DataType z): m_coordinates({x, y, z}) {};


	/** Constructor using a hard copy */
	B2Vector3(const DataType coordinates[3]): m_coordinates(coordinates) {};


	/** Constructor using a reference */
	B2Vector3(const DataType (& coordinates)[3]) {
	  for (unsigned i = 0 ; i < 3; ++i) {
		m_coordinates[i] = coordinates[i];
	  }
	};


	/** Constructor using a pointer */
	B2Vector3(const DataType (* coordinates)[3]) {
	  for (unsigned i = 0 ; i < 3; ++i) {
		m_coordinates[i] = (*coordinates)[i];
	  }
	};


	/** *********************************************** OPERATORS *********************************************** */


	/** safe member access (with boundary check!) should always be used! */
	DataType operator () (unsigned i) const {
	  return this->at(i);
	}


	/** unsafe member access - should only be used, if .at(i) is too slow! */
	DataType & operator[](unsigned i) {
	  return m_coordinates[i];
	}


	/** unsafe member access - should only be used, if .at(i) is too slow! */
	DataType & operator[](unsigned i) const
	{ return m_coordinates[i]; }


	/** Returns the name of the B2Vector.
	 * 
	 */
	const std::string name(void) const;



/** *********************************************** MEMBER ACCESS *********************************************** */


	/** safe member access (with boundary check!) should always be used! */
	DataType at(unsigned i) const;

	/** access variable X (= .at(0) ) */
	inline DataType x(void)  const { return m_coordinates[0]; }
	
	/** access variable Y (= .at(1) ) */
	inline DataType y(void)  const { return m_coordinates[1]; }
	
	/** access variable Z (= .at(2) ) */
	inline DataType z(void)  const { return m_coordinates[2]; }
	
	/** access variable X (= .at(0) ) */
	inline DataType X(void)  const { return m_coordinates[0]; }
	
	/** access variable Y (= .at(1) ) */
	inline DataType Y(void)  const { return m_coordinates[1]; }
	
	/** access variable Z (= .at(2) ) */
	inline DataType Z(void)  const { return m_coordinates[2]; }
	
	/** access variable X (= .at(0) ) */
	inline DataType Px(void) const { return m_coordinates[0]; }
	
	/** access variable Y (= .at(1) ) */
	inline DataType Py(void) const { return m_coordinates[1]; }
	
	/** access variable Z (= .at(2) ) */
	inline DataType Pz(void) const { return m_coordinates[2]; }


/** *********************************************** MISCELLANEOUS *********************************************** */


	/** Creates and sets the addresses of the leaves to store the values of this B2Vector3.
	 * 
	 * @param t  the pointer to the TTree that will contain the TBranch of this B2Vector3.
	 * @param branchName the name of the TBranch that will host this B2Vector3.
	 * @param variableName some extra name you can pass to identify this vector.
	 *
	 * The leaves will be named as the Type::variable_nEntry, where nEntry is the nth entry of the B2Vector3
	 */
	void persist(TTree* t, const std::string& branchName, const std::string& variableName) {
	  
	  std::string leafList;
	  for (unsigned i = 0; i < 3; ++i) {
		leafList += this->name() + "::" + variableName;
		leafList += std::to_string(i);
		leafList += TBranchLeafType(m_coordinates[i]);
	  }

	  TBranch* branch = new TBranch(t, branchName.c_str() , & m_coordinates, leafList.c_str());
	  t->GetListOfBranches()->Add(branch);
	}

  }; //B2Vector3 - end

  
  /** safe member access (with boundary check!) should always be used! */
  inline B2Vector3::DataType at(unsigned i) {
	switch(i) {
	  case 0:
		return B2Vector3::m_coordinates[0];
	  case 1:
		return B2Vector3::m_coordinates[1];
	  case 2:
		return B2Vector3::m_coordinates[2];
	  default:
		B2ERROR("B2Vector3::access operator: given index is out of bounds! returning 0");
		return 0.;
	}
	return 0.;
  }
  
  
  /** Returns the name of the B2Vector3.
   * 
   */
  inline const std::string B2Vector3::name(void)  {
	char* realname(NULL);
	int status(0);
	realname = abi::__cxa_demangle(typeid(*this).name(), 0, 0, &status);
	std::string name(realname);
	free(realname);
	return name ;
  }

}
