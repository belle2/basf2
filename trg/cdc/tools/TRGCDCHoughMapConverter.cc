/**************************************************************************
 * basf2 (Belle II Analysis Software Framework)                           *
 * Author: The Belle II Collaboration                                     *
 *                                                                        *
 * See git log for contributors and copyright holders.                    *
 * This file is licensed under LGPL-3.0, see LICENSE.md.                  *
 **************************************************************************/

//-----------------------------------------------------------------------------
// Description : This program is not completed.
//-----------------------------------------------------------------------------

#define TRG_SHORT_NAMES

#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include "trg/trg/Utilities.h"

using namespace std;
using namespace Belle2;

#define DEBUG_LEVEL   0
#define NAME          "TRGCDCHoughMapConverter"
#define VERSION       "version 0.00[2015/07/23]"

int
main(int argc, char* argv[])
{

  cout << NAME << " ... " << VERSION << endl;
  const string tab = "    ";

  //...Check arguments...
  if (argc != 3) {
    cout << NAME << " !!! two arguments necessary" << endl
         << tab << " 1 : input mapping file name" << endl
         << tab << " 2 : output mapping file name" << endl;
    return -1;
  }

  //...Date...
  string ts0 = TRGUtil::dateStringF();
  // string ts1 = TRGUtil::dateString();

  //...1st argument : input Hough mapping file name...
  const string iname = argv[1];

  //...2nd argument : output Hough mapping file name
  const string oname = argv[2];

  cout << "    input mapping file  : " << iname << endl;
  cout << "    output mapping file : " << oname << endl;

  //...Open input file...
  ifstream ifile(iname.c_str(), ios::in);
  if (ifile.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << iname << endl;
    return -2;
  }

  //...Open output file...
  ofstream ofile(oname.c_str(), ios::out);
  if (ofile.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << oname << endl;
    return -3;
  }

  //...Read configuration data
  char b[800];
  vector<unsigned> tsf2h[9][400];  // [super layer][local id]
  while (! ifile.eof()) {
    ifile.getline(b, 800);
    string l(b);

    if (b[0] == '#') continue;

    const unsigned hx = stoi(TRGUtil::carstring(l));
    l = TRGUtil::cdrstring(l);
    const unsigned hy = stoi(TRGUtil::carstring(l));
    l = TRGUtil::cdrstring(l);

    const unsigned hcid = hy * 1000 + hx;

    while (1) {
      const unsigned tsl = stoi(TRGUtil::carstring(l));
      l = TRGUtil::cdrstring(l);
      const unsigned tsi = stoi(TRGUtil::carstring(l));
      l = TRGUtil::cdrstring(l);
      tsf2h[tsl][tsi].push_back(hcid);

      if (l.size() == 0) break;
    }
  }

  //...Make a mirror image...
  // vector<unsigned> tsf2hm[9][400];  // [super layer][local id]
  for (unsigned tsl = 0; tsl < 9; tsl += 2) {
    for (unsigned tsi = 0; tsi < 400; tsi++) {

      if (tsf2h[tsl][tsi].size() == 0) continue;

      //...Find y min...
      unsigned miny = 25;
      for (unsigned k = 0; k < tsf2h[tsl][tsi].size(); k++) {
        const unsigned hcid = tsf2h[tsl][tsi][k];
        const unsigned y = hcid / 1000;
        if (y < miny) miny = y;
      }

      //...Find x values...

      cout << "tsf " << tsl << " " << tsi << " x=";

      for (unsigned k = 0; k < tsf2h[tsl][tsi].size(); k++) {
        const unsigned hcid = tsf2h[tsl][tsi][k];
        const unsigned y = hcid / 1000;
        if (y != miny) continue;
        const unsigned x = hcid % 1000;
        cout << " " << x;
      }
      cout << endl;
    }
  }


  //...Output...
  ofile << "# This file is generated by " << NAME << "[" << VERSION << "]"
        << endl;
  ofile << "# Source file is " << iname << endl;
  ofile << "# " << ts0 << endl;
  ofile << "#" << endl;
  for (unsigned j = 1; j < 17; j++) {
    for (unsigned i = 0; i < 160; i++) {
      const unsigned hcid = j * 1000 + i;
      ofile << i << " " << j;

      for (unsigned tsl = 0; tsl < 9; tsl += 2) {
        for (unsigned tsi = 0; tsi < 400; tsi++) {
          for (unsigned k = 0; k < tsf2h[tsl][tsi].size(); k++) {
            if (tsf2h[tsl][tsi][k] == hcid)
              ofile << " " << tsl << " " << tsi;
          }
        }
      }
      ofile << endl;
    }
  }

  return 0;
}
