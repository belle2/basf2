#define TRG_SHORT_NAMES

#include <iostream>
#include <fstream>
#include <cmath>
#include <cstdio>
#include <vector>
#include <math.h>
#include <iomanip>
#include "trg/trg/Utilities.h"

using namespace std;
using namespace Belle2;

#define NAME          "HoughMapping"
#define VERSION       "version 0.00"

struct XY {double x ; double y ;};
struct Plane { unsigned x;  unsigned y ;};
void superLayer(const unsigned id);

vector<int> TS;
vector<vector<int> > HPcellx(160, TS);
vector<vector<vector<int> > >HPcelly(16,HPcellx);
ofstream outputm("minus_total.dat");

vector<int> pTS;
vector<vector<int> > pHPcellx(160, pTS);
vector<vector<vector<int> > >pHPcelly(16,pHPcellx);
ofstream outputmp("plus_total.dat");




//...C++ for TSIM...
const string fnc = "HoughMappingMinus.cc";
const string fncp = "HoughMappingPlus.cc";
ofstream outc(fnc);
ofstream outcp(fncp);

int
main(int, char **) {

    cout << NAME << " ... " << VERSION << endl;
    const string tab = "    ";

    //...Date...
    string ts = TRGUtil::dateString();

    outc << "// This file is generated by " << NAME << "(" << VERSION << ")"
         << endl;
    outc << "// " << ts << endl << endl;
    outc << "#define TRGCDC_SHORT_NAMES" << endl;
    outc << "#include \"trg/trg/State.h\"" << endl;
    outc << "#include \"trg/cdc/Tracker2D.h\"" << endl;
    outc << "using namespace std;" << endl;
    outc << "using namespace Belle2;" << endl;
    outc << "void" << endl;
    outc << "TCTracker2D::HoughMappingMinus(void) {" << endl;

    outc << "    //...TS hit map..." << endl;
    outc << "    TRGState SL0_TS = _ts.subset(0, 160);" << endl;
    outc << "    TRGState SL2_TS = _ts.subset(160, 192);" << endl;
    outc << "    TRGState SL4_TS = _ts.subset(160 + 192, 256);" << endl;
    outc << "    TRGState SL6_TS = _ts.subset(160 + 192 + 256, 320);" << endl;
    outc << "    TRGState SL8_TS = _ts.subset(160 + 192 + 256 + 320, 384);"
         << endl;

 outcp << "// This file is generated by " << NAME << "(" << VERSION << ")"
         << endl;
    outcp << "// " << ts << endl << endl;
    outcp << "#define TRGCDC_SHORT_NAMES" << endl;
    outcp << "#include \"trg/trg/State.h\"" << endl;
    outcp << "#include \"trg/cdc/Tracker2D.h\"" << endl;
    outcp << "using namespace std;" << endl;
    outcp << "using namespace Belle2;" << endl;
    outcp << "void" << endl;
    outcp << "TCTracker2D::HoughMappingPlus(void) {" << endl;

    outcp << "    //...TS hit map..." << endl;
    outcp << "    TRGState SL0_TS = _ts.subset(0, 160);" << endl;
    outcp << "    TRGState SL2_TS = _ts.subset(160, 192);" << endl;
    outcp << "    TRGState SL4_TS = _ts.subset(160 + 192, 256);" << endl;
    outcp << "    TRGState SL6_TS = _ts.subset(160 + 192 + 256, 320);" << endl;
    outcp << "    TRGState SL8_TS = _ts.subset(160 + 192 + 256 + 320, 384);"<< endl;

    outc << "    //...Hough cells..." << endl;
    outcp << "    //...Hough cells..." << endl;

    for (unsigned i = 0; i < 5; i++)
        for (unsigned j = 1; j < 17; j++){
                        outc << "    TRGState SL" << to_string(i * 2) << "_row"
                             << to_string(j) << "(160);" << endl;

                        outcp << "    TRGState SL" << to_string(i * 2) << "_row"
                              << to_string(j) << "(160);" << endl;
           }

    for (unsigned sl = 0; sl <5 ; sl++)
        superLayer(sl);

        for(int a=0;a<16;a++){

                        for(int b=0;b<160;b++){
							outputm<<b<<" "<<a+1<<" ";

                                for(int c=0;c<HPcelly[a][b].size();c++)
						{
							outputm<<HPcelly[a][b][c]<<" ";
						}
							outputm<<" "<<endl;
                                              }
                             }
        for(int d=0;d<16;d++){

                        for(int e=0;e<160;e++){
							outputmp<<e<<" "<<d+1<<" ";
                                for(int f=0;f<pHPcelly[d][e].size();f++)
						{
							outputmp<<pHPcelly[d][e][f]<<" ";
						}
							outputmp<<" "<<endl;
                                              }
                             }

    outc << endl << "}" << endl;
 cout << NAME << " ... " << VERSION << endl;
      outcp << endl << "}" << endl;
 cout << NAME << " ... " << VERSION << endl;

    //...Date...
    outc.close();


    //...Termination...
    cout << "Files generated" << endl;
    cout << "    c++ for tsim firmware : " << fnc << endl;
    cout << "    c++ for tsim firmware : " << fncp << endl;
//  cout << "    text file for axial super layer : " <<

}
void
superLayer(const unsigned id) {
    double tmp = 0;
    int tmpi = 0;
    int tmpj = 0;

    if (id == 0) {
        tmp = 19.8;
        tmpi = 160;
        tmpj = 0;
    }
    else if (id == 1) {
        tmp = 40.16;
        tmpi = 192;
        tmpj = 2;
    }
    else if (id == 2) {
        tmp = 62.0;
        tmpi = 256;
        tmpj = 4;
    }
    else if (id == 3) {
        tmp = 83.84;
        tmpi = 320;
        tmpj = 6;
    }
    else if (id == 4) {
        tmp = 105.68;
        tmpi = 384;
        tmpj = 8;
    }
    else {
        cout << NAME << " !!! bad super layer ID" << endl;
        exit(-1);
    }

    //Hough Plane Parameter
    //Theta Range (X Axial)
    const double PI2=2*M_PI;
    //log10(r) Range (Y Axial)
    //cm
    const double minY=1.823908740944321;
    const double maxY=3.204119982655926;
    const int SL = tmpj;
    //other const
    const unsigned nX=160;
    const unsigned nY=16;
    //const unsigned oder=1000;

    //Radious of SL_center cell
    const double r_SL0 = tmp;

    //Number of TS each SL
    const int N_TS_SL0 = tmpi;

    //Hough Plane database SL-0
    vector <XY> xymatrix;
    XY xy={0,0};

/////////////////////////////////////////////////base of ts

    for(int i=0 ; i<N_TS_SL0 ; i++) {
     	xy.x=r_SL0*cos((PI2/N_TS_SL0)*i);
	xy.y=r_SL0*sin((PI2/N_TS_SL0)*i);
        xymatrix.push_back(xy);
    }
///////////////////////////////////////////////////HP to TS

    const double r0=minY;
    const double theta0=0;
    const double dr=(maxY-minY)/nY;
    const float dtheta=PI2/nX;
    double r1 ;
    double r2 ;
    double rminus ;
    double rplus ;
    double theta1 ;
    double theta2 ;
    double minus1 ;
    double minus2 ;
    double plus1 ;
    double plus2 ;

    const string vh = "UT3_0_SL" + to_string(id * 2) + ".vhd";
    const string vhp = "UT3_0_SL" + to_string(id * 2) + "_p.vhd";
    ofstream outputf(vh);
    ofstream outputfp(vhp);

   //generate firware code(Minus)
     outputf<<"library IEEE;"<<endl;
     outputf<<"use IEEE.STD_LOGIC_1164.ALL;"<<endl;
     outputf<<" "<<endl;
     outputf<<" "<<endl;
     outputf<<"entity UT3_0_SL"<<SL<<" is"<<endl;
     outputf<<" "<<endl;
     outputf<<"Port ("<<endl;
     outputf<<"		  SL"<<SL<<"_row1  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row2  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row3  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row4  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row5  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<" 	  SL"<<SL<<"_row6  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row7  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row8  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row9  : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row10 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row11 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row12 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row13 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row14 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row15 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_row16 : out  STD_LOGIC_VECTOR (79 downto 40);"<<endl;
     outputf<<"		  SL"<<SL<<"_TS    : in   STD_LOGIC_VECTOR ("<<tmpi/2<<" downto 0));"<<endl;

     outputf<<"end UT3_0_SL"<<SL<<";"<<endl;
     outputf<<" "<<endl;
     outputf<<" "<<endl;
     outputf<<"architecture Behavioral of UT3_0_SL"<<SL<<" is"<<endl;
     outputf<<" "<<endl;
     outputf<<"begin"<<endl;
     outputf<<" "<<endl;

   //generate firware code(Plus)
     outputfp<<"library IEEE;"<<endl;
     outputfp<<"use IEEE.STD_LOGIC_1164.ALL;"<<endl;
     outputfp<<" "<<endl;
     outputfp<<" "<<endl;
     outputfp<<"entity UT3_0_SL"<<SL<<"_P is"<<endl;
     outputfp<<" "<<endl;
     outputfp<<"Port ("<<endl;
     outputfp<<"           SL"<<SL<<"_row1  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row2  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row3  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row4  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row5  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row6  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row7  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row8  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row9  : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row10 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row11 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row12 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row13 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row14 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row15 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_row16 : out  STD_LOGIC_VECTOR (39 downto 0);"<<endl;
     outputfp<<"           SL"<<SL<<"_TS    : in   STD_LOGIC_VECTOR ("<<tmpi/2<<" downto 0));"<<endl;

     outputfp<<"end UT3_0_SL"<<SL<<"_P;"<<endl;
     outputfp<<" "<<endl;
     outputfp<<" "<<endl;
     outputfp<<"architecture Behavioral of UT3_0_SL"<<SL<<"_P is"<<endl;
     outputfp<<" "<<endl;
     outputfp<<"begin"<<endl;
     outputfp<<" "<<endl;


    //vertical
    for(int k=0 ; k<16 ; k++) {

    //horizontal
        for(int t=0 ; t<160 ; t++) {
            double  j=t%160;
            double  ff=0;
            double  ii=0;
            double  ffp=0;
            double  iip=0;

            if(j>39 && j<80)
            outputf <<"SL"<<SL<<"_row"<<k+1<<"("<<j<<")<=";
	    if(j>=0 && j<40)
            outputfp <<"SL"<<SL<<"_row"<<k+1<<"("<<j<<")<=";
            outc << "    SL" << SL << "_row" << k + 1 << ".set(" << j << ", ";
            outcp << "    SL" << SL << "_row" << k + 1 << ".set(" << j << ", ";
            bool first = true;
	    bool firstp = true;

            theta1= theta0+ j* dtheta;
            theta2= theta0+ (j+1)* dtheta;

            //TS
            for(int i=0 ; i<N_TS_SL0 ; i++) {   //HP_0(0,0) to TS_SL_0  Save Date


                r1=(((xymatrix[i].x)*(xymatrix[i].x))+((xymatrix[i].y)*(xymatrix[i].y)))/((2*xymatrix[i].x*cos(theta1))+(2*xymatrix[i].y*sin(theta1)));
                r2=(((xymatrix[i].x)*(xymatrix[i].x))+((xymatrix[i].y)*(xymatrix[i].y)))/((2*xymatrix[i].x*cos(theta2))+(2*xymatrix[i].y*sin(theta2)));

                rplus=(((xymatrix[i].x)*(xymatrix[i].x))+((xymatrix[i].y)*(xymatrix[i].y)))/(2*xymatrix[i].x*cos(theta1+dtheta/10000)+(2*xymatrix[i].y*sin(theta1+dtheta/10000)));
                rminus=(((xymatrix[i].x)*(xymatrix[i].x))+((xymatrix[i].y)*(xymatrix[i].y)))/(2*xymatrix[i].x*cos(theta2+dtheta/10000)+(2*xymatrix[i].y*sin(theta2+dtheta/10000)));

                if(r1<0) {
                    r1=1;
                }
                if(r2<0) {
                    r2=1;
                }
                if(rminus<0) {
                    rminus=1;
                }
                if(rplus<0) {
                    rplus=1;
                }

                minus1=r0+(k+1)*dr-log10(r1);
                minus2=r0+k*dr-log10(r2);

                plus1=r0+(k+1)*dr-log10(r2);
                plus2=r0+k*dr-log10(r1);



//minus
////////////////////////////////////////////////////////////////

                if( r1!=1 && r2!=1 ) {
                    if ( r2<=rminus  ) {
                        if(minus1*minus2 <=0.0 ) {

                                HPcelly[k][j].push_back(SL);
                                HPcelly[k][j].push_back(i);

                            if (! first)
                                outc << " or ";

                            if(ff!=0)
				{
				if(j>39 && j<80)
                                outputf<<"or ";
                                }

			        ff++;
                                ii=i;
				 if(j>39 && j<80)
                                outputf<<"SL"<<SL<<"_TS("<<i<<") ";

                                outc << "SL" << SL << "_TS[" << i << "]";
                                first = false;
                            }
                       }
                   }


                else if (r2 ==1 && r1 != 1) {

                    if( r2<=rminus  ) {
                        if (r2 == 1 && minus1 > 0)
                      {
                                HPcelly[k][j].push_back(SL);
                                HPcelly[k][j].push_back(i);

                                if (! first)
                                    outc << " or ";

                                if(ff!=0){
					 if(j>39 && j<80)
                                 	   outputf<<"or ";
					}
                                    ff++;
                                    ii=i;
				 if(j>39 && j<80)
                                outputf<<"SL"<<SL<<"_TS("<<i<<") ";

                                outc << "SL" << SL << "_TS[" << i << "]";
                                first = false;
                            }
                   }
}


//plus
                if( r1!=1 && r2!=1 )
                        {
                            if ( r1>=rplus  )
                                {
                                    if(plus1*plus2 <=0.0 )
                                    {
                                        pHPcelly[k][j].push_back(SL);
                                        pHPcelly[k][j].push_back(i);
                                        if (! firstp)
                                            outcp << " or ";

                                        if(ffp!=0){
						if(j>=0 && j<40)
                                           		 outputfp<<"or ";
						  }
                                            ffp++;
                                            iip=i;
						if(j>=0 && j<40)
                                            	outputfp<<"SL"<<SL<<"_TS("<<i<<") ";

                                            outcp << "SL" << SL << "_TS[" << i << "]";
                                            firstp = false;
                                    }

                                }

                        }

                else if(r1==1 && r2!=1)
                        {
                            if( r1>=rplus  )
                                {
                                    if( r1==1 && plus1>0 )
                                        {
                                            pHPcelly[k][j].push_back(SL);
                                            pHPcelly[k][j].push_back(i);
                                            if (! firstp)
                                                outcp << " or ";

                                            if(ffp!=0){
							if(j>=0 && j<40)
                                       			     outputfp<<"or ";
						      }
                                            ffp++;
                                            iip=i;
					    if(j>=0 && j<40)
                                            outputfp<<"SL"<<SL<<"_TS("<<i<<") ";

                                            outcp << "SL" << SL << "_TS[" << i << "]";
                                            firstp = false;
                                        }
                                }
                        }
                }





			 if(j>39 && j<80)
                        outputf<<";"<<endl;
     			 if(j>=0 && j<40)
                        outputfp<<";"<<endl;
                        outc<<");"<<endl;
                        outcp<<");"<<endl;

            }
       }
                        outputf<<" "<<endl;
			outputf<<"end Behavioral;"<<endl;
			outputfp<<" "<<endl;
                        outputfp<<"end Behavioral;"<<endl;
    return  ;
}



