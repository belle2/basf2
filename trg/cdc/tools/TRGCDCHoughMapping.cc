#define TRG_SHORT_NAMES

#include <iostream>
#include <fstream>
#include <cmath>
#include <cstdio>
#include <vector>
#include <math.h>
#include <iomanip>
#include "trg/trg/Utilities.h"

using namespace std;
using namespace Belle2;

#define NAME          "HoughMapping"
#define VERSION       "version 0.01"

struct XY {double x; double y;};
struct Plane {unsigned x; unsigned y;};
void superLayer(const unsigned id);

//Hough Plane Parameter
//Theta Range (X Axial)
const double PI2 = 2 * M_PI;
//log10(r/cm) Range (Y Axial)
const double minY = 1.823908740944321;
const double maxY = 3.204119982655926;
//cell number
const unsigned nX = 160;
const unsigned nY = 16;

vector<int> TS;
vector<vector<int>> HPcellx(nX, TS);
vector<vector<vector<int>>> HPcelly(nY, HPcellx);
ofstream outputm("minus_total.dat");

vector<int> pTS;
vector<vector<int>> pHPcellx(nX, pTS);
vector<vector<vector<int>>> pHPcelly(nY, pHPcellx);
ofstream outputmp("plus_total.dat");


//...C++ for TSIM...
const string fnc = "HoughMappingMinus.cc";
const string fncp = "HoughMappingPlus.cc";
ofstream outc(fnc);
ofstream outcp(fncp);

int
main(int, char**)
{
  cout << NAME << " ... " << VERSION << endl;

  //...Date...
  string ts = TRGUtil::dateString();

  outc << "// This file is generated by " << NAME << "(" << VERSION << ")"
       << endl;
  outc << "// " << ts << endl << endl;
  outc << "#define TRGCDC_SHORT_NAMES" << endl;
  outc << "#include \"trg/trg/State.h\"" << endl;
  outc << "#include \"trg/cdc/Tracker2D.h\"" << endl;
  outc << "using namespace std;" << endl;
  outc << "using namespace Belle2;" << endl;
  outc << "void" << endl;
  outc << "TCTracker2D::HoughMappingMinus(void) {" << endl;

  outc << "    //...TS hit map..." << endl;
  outc << "    TRGState SL0_TS = _ts.subset(0, 160);" << endl;
  outc << "    TRGState SL2_TS = _ts.subset(160, 192);" << endl;
  outc << "    TRGState SL4_TS = _ts.subset(160 + 192, 256);" << endl;
  outc << "    TRGState SL6_TS = _ts.subset(160 + 192 + 256, 320);" << endl;
  outc << "    TRGState SL8_TS = _ts.subset(160 + 192 + 256 + 320, 384);"
       << endl;

  outcp << "// This file is generated by " << NAME << "(" << VERSION << ")"
        << endl;
  outcp << "// " << ts << endl << endl;
  outcp << "#define TRGCDC_SHORT_NAMES" << endl;
  outcp << "#include \"trg/trg/State.h\"" << endl;
  outcp << "#include \"trg/cdc/Tracker2D.h\"" << endl;
  outcp << "using namespace std;" << endl;
  outcp << "using namespace Belle2;" << endl;
  outcp << "void" << endl;
  outcp << "TCTracker2D::HoughMappingPlus(void) {" << endl;

  outcp << "    //...TS hit map..." << endl;
  outcp << "    TRGState SL0_TS = _ts.subset(0, 160);" << endl;
  outcp << "    TRGState SL2_TS = _ts.subset(160, 192);" << endl;
  outcp << "    TRGState SL4_TS = _ts.subset(160 + 192, 256);" << endl;
  outcp << "    TRGState SL6_TS = _ts.subset(160 + 192 + 256, 320);" << endl;
  outcp << "    TRGState SL8_TS = _ts.subset(160 + 192 + 256 + 320, 384);" << endl;

  outc << "    //...Hough cells..." << endl;
  outcp << "    //...Hough cells..." << endl;

  for (unsigned isl = 0; isl < 5; isl++)
    for (unsigned iy = 1; iy < nY + 1; iy++) {
      outc << "    TRGState SL" << to_string(isl * 2) << "_row"
           << to_string(iy) << "(160);" << endl;

      outcp << "    TRGState SL" << to_string(isl * 2) << "_row"
            << to_string(iy) << "(160);" << endl;
    }

  for (unsigned isl = 0; isl < 5 ; isl++)
    superLayer(isl);

  for (unsigned iy = 0; iy < nY; iy++) {
    for (unsigned ix = 0; ix < nX; ix++) {
      outputm << ix << " " << iy + 1 << " ";
      outputmp << ix << " " << iy + 1 << " ";
      for (unsigned c = 0; c < HPcelly[iy][ix].size(); c++) {
        outputm << HPcelly[iy][ix][c] << " ";
      }
      for (unsigned c = 0; c < pHPcelly[iy][ix].size(); c++) {
        outputmp << pHPcelly[iy][ix][c] << " ";
      }
      outputm << " " << endl;
      outputmp << " " << endl;
    }
  }

  outc << endl << "}" << endl;
  cout << NAME << " ... " << VERSION << endl;
  outcp << endl << "}" << endl;
  cout << NAME << " ... " << VERSION << endl;

  //...Date...
  outc.close();

  //...Termination...
  cout << "Files generated" << endl;
  cout << "    c++ for tsim firmware : " << fnc << endl;
  cout << "    c++ for tsim firmware : " << fncp << endl;
}

void
superLayer(const unsigned id)
{
  //Radius of SL_center cell
  double r_SL = 0;
  //Number of TS each SL
  int N_TS_SL = 0;
  int SL = 2 * id;

  if (id == 0) {
    r_SL = 19.8;
    N_TS_SL = 160;
  } else if (id == 1) {
    r_SL = 40.16;
    N_TS_SL = 192;
  } else if (id == 2) {
    r_SL = 62.0;
    N_TS_SL = 256;
  } else if (id == 3) {
    r_SL = 83.84;
    N_TS_SL = 320;
  } else if (id == 4) {
    r_SL = 105.68;
    N_TS_SL = 384;
  } else {
    cout << NAME << " !!! bad super layer ID" << endl;
    exit(-1);
  }

  //Hough Plane database
  vector<XY> xymatrix;
  XY xy = {0, 0};

/////////////////////////////////////////////////base of ts

  for (int i = 0; i < N_TS_SL; ++i) {
    xy.x = r_SL * cos((PI2 / N_TS_SL) * i);
    xy.y = r_SL * sin((PI2 / N_TS_SL) * i);
    xymatrix.push_back(xy);
  }
///////////////////////////////////////////////////HP to TS

  const double r0 = minY;
  const double theta0 = 0;
  const double dr = (maxY - minY) / nY;
  const double dtheta = PI2 / nX;
  double r1;
  double r2;
  double theta1;
  double theta2;
  double minus1;
  double minus2;
  double plus1;
  double plus2;

  const string vh = "UT3_0_SL" + to_string(id * 2) + ".vhd";
  const string vhp = "UT3_0_SL" + to_string(id * 2) + "_p.vhd";
  ofstream outputf(vh);
  ofstream outputfp(vhp);

  //generate firware code(Minus)
  outputf << "library IEEE;" << endl;
  outputf << "use IEEE.STD_LOGIC_1164.ALL;" << endl;
  outputf << " " << endl;
  outputf << " " << endl;
  outputf << "entity UT3_0_SL" << SL << " is" << endl;
  outputf << " " << endl;
  outputf << "Port (" << endl;
  outputf << "		  SL" << SL << "_row1  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row2  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row3  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row4  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row5  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << " 	  SL" << SL << "_row6  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row7  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row8  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row9  : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row10 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row11 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row12 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row13 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row14 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row15 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_row16 : out  STD_LOGIC_VECTOR (79 downto 40);" << endl;
  outputf << "		  SL" << SL << "_TS    : in   STD_LOGIC_VECTOR (" << N_TS_SL / 2 << " downto 0));" << endl;

  outputf << "end UT3_0_SL" << SL << ";" << endl;
  outputf << " " << endl;
  outputf << " " << endl;
  outputf << "architecture Behavioral of UT3_0_SL" << SL << " is" << endl;
  outputf << " " << endl;
  outputf << "begin" << endl;
  outputf << " " << endl;

  //generate firmware code(Plus)
  outputfp << "library IEEE;" << endl;
  outputfp << "use IEEE.STD_LOGIC_1164.ALL;" << endl;
  outputfp << " " << endl;
  outputfp << " " << endl;
  outputfp << "entity UT3_0_SL" << SL << "_P is" << endl;
  outputfp << " " << endl;
  outputfp << "Port (" << endl;
  outputfp << "           SL" << SL << "_row1  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row2  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row3  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row4  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row5  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row6  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row7  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row8  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row9  : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row10 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row11 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row12 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row13 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row14 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row15 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_row16 : out  STD_LOGIC_VECTOR (39 downto 0);" << endl;
  outputfp << "           SL" << SL << "_TS    : in   STD_LOGIC_VECTOR (" << N_TS_SL / 2 << " downto 0));" << endl;

  outputfp << "end UT3_0_SL" << SL << "_P;" << endl;
  outputfp << " " << endl;
  outputfp << " " << endl;
  outputfp << "architecture Behavioral of UT3_0_SL" << SL << "_P is" << endl;
  outputfp << " " << endl;
  outputfp << "begin" << endl;
  outputfp << " " << endl;


  //vertical
  for (unsigned k = 0 ; k < nY ; ++k) {
    //horizontal
    for (unsigned j = 0 ; j < nX ; ++j) {
      double  ff = 0;
      double  ffp = 0;

      if (j > 39 && j < 80)
        outputf << "SL" << SL << "_row" << k + 1 << "(" << j << ")<=";
      if (j < 40)
        outputfp << "SL" << SL << "_row" << k + 1 << "(" << j << ")<=";
      outc << "    SL" << SL << "_row" << k + 1 << ".set(" << j << ", ";
      outcp << "    SL" << SL << "_row" << k + 1 << ".set(" << j << ", ";
      bool first = true;
      bool firstp = true;

      theta1 = theta0 + j * dtheta;
      theta2 = theta0 + (j + 1) * dtheta;

      //TS
      for (int i = 0 ; i < N_TS_SL ; i++) {
        // calculate r(phi) at Hough cell borders phi1 and phi2
        r1 = ((xymatrix[i].x * xymatrix[i].x) + (xymatrix[i].y * xymatrix[i].y)) /
             ((2 * xymatrix[i].x * cos(theta1)) + (2 * xymatrix[i].y * sin(theta1)));
        r2 = ((xymatrix[i].x * xymatrix[i].x) + (xymatrix[i].y * xymatrix[i].y)) /
             ((2 * xymatrix[i].x * cos(theta2)) + (2 * xymatrix[i].y * sin(theta2)));

        /* Check whether f(phi) = log(r(phi)) crosses the Hough cell
         * defined by (phi1, phi2, log(r1), log(r2))
         * The slope determines the charge of the track.
         *
         * Since f is not defined for all phi, 3 cases can occur:
         * 1. f(phi1) and f(phi2) both defined:
         *    compare f(phi1) and f(phi2) to log(r1) and log(r2),
         *    get slope from f(phi2) - f(phi1)
         * 2. f(phi1) defined, f(phi2) not defined (or vice-versa):
         *    compare f(phi1) to log(r1) and log(r2),
         *    slope is known
         * 3. f(phi1) and f(phi2) both not defined: no entry
         */

        //...minus...
        if (r1 >= 0 && r2 >= 0 && r1 < r2) {
          /* positive slope:
           * crossing if f(phi1) < log(r2) and f(phi2) > log(r1)
           */
          minus1 = r0 + (k + 1) * dr - log10(r1);
          minus2 = r0 + k * dr - log10(r2);
          if (minus1 * minus2 <= 0.0) {
            HPcelly[k][j].push_back(SL);
            HPcelly[k][j].push_back(i);

            if (! first)
              outc << " or ";

            if (ff != 0) {
              if (j > 39 && j < 80)
                outputf << "or ";
            }

            ff++;
            if (j > 39 && j < 80)
              outputf << "SL" << SL << "_TS(" << i << ") ";

            outc << "SL" << SL << "_TS[" << i << "]";
            first = false;
          }
        } else if (r2 < 0 && r1 >= 0) {
          /* positive slope, f(phi2) = inf:
           * crossing if f(phi1) < log(r2)
           */
          minus1 = r0 + (k + 1) * dr - log10(r1);
          if (minus1 > 0) {
            HPcelly[k][j].push_back(SL);
            HPcelly[k][j].push_back(i);

            if (! first)
              outc << " or ";

            if (ff != 0) {
              if (j > 39 && j < 80)
                outputf << "or ";
            }
            ff++;
            if (j > 39 && j < 80)
              outputf << "SL" << SL << "_TS(" << i << ") ";

            outc << "SL" << SL << "_TS[" << i << "]";
            first = false;
          }
        }

        //plus
        if (r1 >= 0 && r2 >= 0 && r2 < r1) {
          /* negative slope:
           * crossing if f(phi2) < log(r2) and f(phi1) > log(r1)
           */
          plus1 = r0 + (k + 1) * dr - log10(r2);
          plus2 = r0 + k * dr - log10(r1);
          if (plus1 * plus2 <= 0.0) {
            pHPcelly[k][j].push_back(SL);
            pHPcelly[k][j].push_back(i);
            if (! firstp)
              outcp << " or ";

            if (ffp != 0) {
              if (j < 40)
                outputfp << "or ";
            }
            ffp++;
            if (j < 40)
              outputfp << "SL" << SL << "_TS(" << i << ") ";

            outcp << "SL" << SL << "_TS[" << i << "]";
            firstp = false;
          }
        } else if (r1 < 0 && r2 >= 0) {
          /* negative slope, f(phi1) = inf:
           * crossing if f(phi2) < log(r2)
           */
          plus1 = r0 + (k + 1) * dr - log10(r2);
          if (plus1 > 0) {
            pHPcelly[k][j].push_back(SL);
            pHPcelly[k][j].push_back(i);
            if (! firstp)
              outcp << " or ";

            if (ffp != 0) {
              if (j < 40)
                outputfp << "or ";
            }
            ffp++;
            if (j < 40)
              outputfp << "SL" << SL << "_TS(" << i << ") ";

            outcp << "SL" << SL << "_TS[" << i << "]";
            firstp = false;
          }
        }
      }

      if (j > 39 && j < 80)
        outputf << ";" << endl;
      if (j < 40)
        outputfp << ";" << endl;
      outc << ");" << endl;
      outcp << ");" << endl;

    }
  }
  outputf << " " << endl;
  outputf << "end Behavioral;" << endl;
  outputfp << " " << endl;
  outputfp << "end Behavioral;" << endl;
  return;
}



