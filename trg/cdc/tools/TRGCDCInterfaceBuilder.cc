/**************************************************************************
 * basf2 (Belle II Analysis Software Framework)                           *
 * Author: The Belle II Collaboration                                     *
 *                                                                        *
 * See git log for contributors and copyright holders.                    *
 * This file is licensed under LGPL-3.0, see LICENSE.md.                  *
 **************************************************************************/

//-----------------------------------------------------------------------------
// Description : A program to generate VHDL code for the packages.
//-----------------------------------------------------------------------------

#define TRG_SHORT_NAMES

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <boost/algorithm/string.hpp>
#include <boost/lexical_cast.hpp>
#include "trg/trg/Utilities.h"

using namespace std;
using namespace Belle2;

#define DEBUG_LEVEL   1
#define NAME          "TRGCDCInterfaceBuilder"
#define VERSION       string("0.00")
#define ENV_PATH      "BELLE2_LOCAL_DIR"
#define FRONT_END     "/OpticalLinkFrontEnd.h"
#define MARKER_0      "VHDL : begin"
#define MARKER_1      "VHDL : end"
#define N_KEYWORDS    5
#define KEYWORD_0     "TRGOpticalLinkVersion"
#define KEYWORD_1     "VHDL : type"                  // TRGSignalVector
#define KEYWORD_2     "vector<const TRGSignalVector" // vector<TRGSignalVector
#define KEYWORD_3     "vector<const TRGSignal"       // vector<TRGSignal
#define KEYWORD_4     "TRGSignal"                    // TRGSignal

const string Keys[] = {
  KEYWORD_0,
  KEYWORD_1,
  KEYWORD_2,
  KEYWORD_3,
  KEYWORD_4
};
vector<string> Definitions;
unsigned LinesOfs2 = 0;
const string Out0name = ".TRGCDCInterfaceBuilder0.vhdl";
const string Out1name = ".TRGCDCInterfaceBuilder1.vhdl";
const string Out2name = ".TRGCDCInterfaceBuilder2.vhdl";
const string Out3name = ".TRGCDCInterfaceBuilder3.vhdl";
ofstream Ofs0(Out0name.c_str(), ios::out);
ofstream Ofs1(Out1name.c_str(), ios::out);
ofstream Ofs2(Out2name.c_str(), ios::out);
ofstream Ofs3(Out3name.c_str(), ios::out);
const string Tab = "    ";

void Parser(ifstream&);
void Parser0(const string&);
void ParserTS(const string&);
void ParserVTS(const string&);
void ParserVTS2(const string&);
void ParserTSV(const string&);
void ParserVTSV(const string&);

void TypeDefinition(const string& name, const string& line);
void TypeDefinition(const string& name, unsigned size, const string& base);
void Functions(const string& name, unsigned size);
void GetName(const string& line,
             string& name,
             string& base,
             bool& array,
             unsigned& size);

//---

void (* ParserN[N_KEYWORDS])(const string&) = {
  Parser0,
  ParserTSV,
  ParserVTSV,
  ParserVTS,
  ParserTS
};

int
main(int argc, char**)    // argv[]) {
{
//main(int argc) {

  cout << NAME << " ... " << VERSION << endl;

  //...Check arguments...
  if (argc > 2) {
    cout << NAME << " !!! no argument is necessary" << endl;
    return -1;
  }

  //...Date...
  // const string ts0 = TRGUtil::dateStringF();
  const string ts1 = TRGUtil::dateString();

  //...Get path to include directory...
  const string path = getenv(ENV_PATH);
  const string indir = path + "/include/trg/cdc";

  //...Temporary output file...
  if (Ofs0.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << Out0name << endl;
    return -2;
  }
  if (Ofs1.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << Out1name << endl;
    return -3;
  }
  if (Ofs2.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << Out2name << endl;
    return -4;
  }
  if (Ofs3.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << Out3name << endl;
    return -5;
  }

  //...Banner...
  Ofs0 << "-- Generated by " << NAME << " " << VERSION << endl;
  Ofs0 << "-- " << ts1 << endl;
  Ofs0 << "--" << endl;

  //...Front-end Link...
//  TRGCDCFrontEnd::implementation(TRGCDCFrontEnd::inner, outfile);
  const string fename = indir + FRONT_END;
  ifstream fefile(fename.c_str(), ios::in);
  if (fefile.fail()) {
    cout << NAME << " !!! can not open file" << endl
         << "    " << fename << endl;
    return -6;
  }

  //...Header...
  Ofs0 << "-- Data file : " << endl;
  Ofs0 << "--     " << fename << endl;
  Ofs0 << "--" << endl;
  Ofs0 << "" << endl;
  Ofs0 << "library IEEE;" << endl;
  Ofs0 << "use IEEE.STD_LOGIC_1164.all;" << endl << endl;
  Ofs0 << "package CDCTRG_pkg is" << endl << endl;

  Ofs1 << "package body CDCTRG_pkg is" << endl << endl;

  //...Frame...
  Ofs2 << Tab << "-- TRGFrame" << endl;
  Ofs2 << Tab << "function TRGFrame (" << endl;

  //...Frame body...
  Ofs3 << Tab << "begin" << endl;
  Ofs3 << Tab << "    return" << endl;

  //...Call the Parser...
  Parser(fefile);

  //...Copy Ofs2 and reopen it...
  Ofs2.close();
  string tmp = Out2name + ".tmp";
  string cmd = "cp " + Out2name + " " + tmp;
  system(cmd.c_str());
  ofstream ofs2(Out2name.c_str(), ios::app);

  //...For function body of TRGFrame...
  string tmq = Out2name + ".tmp2";
  cmd = "sed -e 's/std_logic_vector;/std_logic_vector is/g' " + tmp
        + " > " + tmq;
  system(cmd.c_str());

  //...Trailer...
  ofs2 << "end;" << endl << endl;

  //...End of writing tmp files...
  Ofs0.close();
  Ofs1.close();
  ofs2.close();
  Ofs3.close();

  //...Merge files...
  cmd = "cat " + Out0name + " " + Out2name + " " + Out1name + " "
        + tmq + " " + Out3name + " > TRGCDCInterfaceBuilder.vhdl";
  system(cmd.c_str());

  //...Termination...
  cout << NAME << " ... terminated" << endl;
}

void
Parser(ifstream& ifs)
{

  //...Main loop...
  char b[800];
  bool beginConversion = false;
  bool endConversion = false;
  while (! ifs.eof()) {
    ifs.getline(b, 800);
    string l(b);

    //...Check 'begin' and 'end' markers...
    string::size_type pos = l.find(MARKER_0);
    if (pos != string::npos) {
      beginConversion = true;
      continue;
    }
    pos = l.find(MARKER_1);
    if (pos != string::npos) {
      endConversion = true;
      continue;
    }

    //...Do convert...
    if (beginConversion && (! endConversion)) {

      //...Keyword loop...
      for (unsigned i = 0; i < N_KEYWORDS; i++) {

        //...Check keywords...
        pos = l.find(Keys[i].c_str());
        if (pos != string::npos) {
          ParserN[i](l);
          break;
        }
      }
    } else if (endConversion) {

      //...Do the final job...
      Ofs2 << ")" << endl;
      Ofs2 << Tab << "    return std_logic_vector;" << endl << endl;

      Ofs3 << ");" << endl;
      Ofs3 << Tab << "end TRGFrame;" << endl;
      Ofs3 << "end;" << endl;

      break;
    }
  }
}

//...Parser for the keyword TRGOpticalLinkVersion...
void
Parser0(const string& line)
{
  string l = line;
  // const string car0 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  const string car1 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  const string car2 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  Ofs0 << "-- Version : " << car1 << " " << car2 << endl;
  Ofs0 << "" << endl;
}

//...Parser for the keyword TRGSignal...
void
ParserTS(const string& l)
{
  string name;
  string none;
  bool array = false;
  unsigned size = 0;
  GetName(l, name, none, array, size);

  //...Termination mark...
  if (LinesOfs2) {
    Ofs2 << ";" << endl;
    Ofs3 << " &" << endl;
  }

  //...TRGFrame definition...
  char v = 'a' + LinesOfs2;
  Ofs2 << Tab << "    " << v << " : in " << name;

  //...TRGFrame body...
  Ofs3 << Tab << "    ToLogicVector(" << name << ")";

  ++LinesOfs2;
}

//...Parser for the keyword VHDL...
void
ParserTSV(const string& line)
{
  string l = line;
  // const string car0 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  // const string car1 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  // const string car2 = TRGUtil::carstring(l);
  l = TRGUtil::cdrstring(l);
  // const string car3 = TRGUtil::carstring(l);

  //...Definition...
  string m = TRGUtil::cdrstring(l);
  string car4 = TRGUtil::carstring(m);
  string vnv = car4;
  Definitions.push_back(car4);

  //...Look for array size...
  string last = car4;
  string top = "";
  while (1) {
    car4 = TRGUtil::carstring(m);
    m = TRGUtil::cdrstring(m);
    if (car4 == "downto") {
      top = last;
      break;
    }
    last = car4;
  }
  string dim;
  for (unsigned i = 0; i < top.size(); i++) {
    if (isdigit(top[i]))
      dim += top[i];
    else
      dim = "";
  }
  unsigned arraySize = boost::lexical_cast<int>(dim) + 1;

  //...Type definition...
  TypeDefinition(vnv, l);

  //...Functions...
  Functions(vnv, arraySize);
}

//...Parser for the keyword vector<TRGSignal...
void
ParserVTS(const string& l)
{

  string name;
  string base;
  bool array = false;
  unsigned size = 0;
  GetName(l, name, base, array, size);

  //...Check definitions...
  bool defined = false;
  for (unsigned i = 0; i < Definitions.size(); i++) {
    if (Definitions[i] == name) {
      defined = true;
      break;
    }
  }
  if (! defined)
    cout << "TRGCDCInterfaceBuilder::ParserVTS !!! " << name
         << " is not defined" << endl;

  //...Type definition...
  TypeDefinition(name, size, "std_logic");

  //...Functions...
  Functions(name, size);

  //...TRGFrame...
  ParserTS(l);
}

//...Parser for the keyword vector<TRGSignalVector...
void
ParserVTSV(const string& l)
{

  string name;
  string base;
  bool array = false;
  unsigned size = 0;
  GetName(l, name, base, array, size);

  //...Check definitions...
  bool defined = false;
  for (unsigned i = 0; i < Definitions.size(); i++) {
    if (Definitions[i] == name) {
      defined = true;
      break;
    }
  }
  if (! defined)
    cout << "TRGCDCInterfaceBuilder::ParserVTS !!! " << name
         << " is not defined" << endl;

  //...Type definition...
  TypeDefinition(name, size, base);

  //...Functions...
  Functions(name, size);

  //...TRGFrame...
  ParserTS(l);
}

void
TypeDefinition(const string& name, const string& l)
{

  //...Type definition...
  Ofs0 << Tab << "-- " << name << endl;
  Ofs0 << Tab << l << endl;
  Ofs0 << endl;
}

void
TypeDefinition(const string& name, unsigned size, const string& base)
{

  //...Type definition...
  Ofs0 << Tab << "-- " << name << endl;
  Ofs0 << Tab << "type " << name << " is array (" << size - 1
       << " downto 0) of " << base << ";" << endl;
  Ofs0 << endl;
}

void
Functions(const string& name, unsigned arraySize)
{

  //...Conersion function : ToLogicVector...
  Ofs0 << Tab << "-- " << name << endl;
  Ofs0 << Tab << "function ToLogicVector (a : in " << name
       << ") return std_logic_vector;" << endl;

  //...Body...
  Ofs1 << Tab << "-- " << name << " to std_logic_vector" << endl;
  Ofs1 << Tab << "function ToLogicVector (a : in " << name
       << ") return std_logic_vector is" << endl;
  Ofs1 << Tab << "begin" << endl;
  Ofs1 << Tab << "    return" << endl;
  for (unsigned i = arraySize; i > 0; --i) {
    if (i > 1)
      Ofs1 << Tab << "        a(" << i - 1 << ") &"
           << endl;
    else
      Ofs1 << Tab << "        a(" << i - 1 << ");"
           << endl;
  }
  Ofs1 << Tab << "end ToLogicVector;" << endl;
  Ofs1 << endl;

  //...Conersion function : to name...
  Ofs0 << Tab << "functino To" << name
       << " (a : in std_logic_vector) return " << name << ";" << endl;
  Ofs0 << endl;

  //...Body...
  Ofs1 << Tab << "-- std_logic_vector to " << name << endl;
  Ofs1 << Tab << "function To" << name
       << " (a : in std_logic_vector) return " << name << " is" << endl;
  Ofs1 << Tab << "begin" << endl;
  Ofs1 << Tab << "    return" << endl;
  for (unsigned i = arraySize; i > 0; --i) {
    if (i > 1)
      Ofs1 << Tab << "        a(" << i - 1 << ") &" << endl;
    else
      Ofs1 << Tab << "        a(" << i - 1 << ");" << endl;
  }
  Ofs1 << Tab << "end " << name << ";" << endl;
  Ofs1 << endl;
}

void
GetName(const string& line,
        string& name,
        string& base,
        bool& array,
        unsigned& size)
{

  string l = line;

  //...Is this a vector? Then make an array...
  array = false;
  string::size_type pos = l.find("std::vector");
  if (pos != string::npos)
    array = true;

  //...Keep the last word as a variable name...
  name = "";
  while (1) {
    string car = TRGUtil::carstring(l);
    l = TRGUtil::cdrstring(l);

    if (l.size() == 0) {
      name = car;
      break;
    }
  }

  //...Change variable name from C++ style...
  string vnv = name.substr(1, name.size() - 2);
  string vnf = vnv.substr(0, 1);
  boost::to_upper(vnf);
  vnv[0] = vnf[0];
  name = vnv;

  //...Array...
  size = 0;
  base = "";
  if (array) {

    //...Last part of a name must be size of array...
    string dim;
    for (unsigned i = 0; i < vnv.size(); i++) {
      if (isdigit(vnv[i])) {
        dim += vnv[i];
      } else {
        dim = "";
        base += vnv[i];
      }
    }
    size = boost::lexical_cast<int>(dim);
  }
}
