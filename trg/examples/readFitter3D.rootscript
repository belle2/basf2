#include <algorithm>

readFitter3D(){

  // Control readFitter3D
  // graphFlag=-1: don't plot, 0: plot all, 1: plot fit, 2: plot pdg and mcParticle Status
  int graphFlag = 1;
  // Choose if there is a condition in plotting fit results
  int conditionFlag = 1;

  gROOT->Reset();
  gROOT->SetStyle("Plain");
  gStyle->SetOptStat(111111111);
  gStyle->SetOptFit(1111111111);
  //gStyle->SetStatH(0.3);

  //Read file
  TFile* inFile = new TFile("Fitter3D.root");
  TTree* inTree = (TTree*)inFile->Get("m_treeTrackFitter3D");
  //Set branches
  TClonesArray* tSTrackFitter3D = new TClonesArray("TVectorD"); 
  TClonesArray* fitTrackFitter3D = new TClonesArray("TVectorD"); 
  TClonesArray* mcTrackFitter3D = new TClonesArray("TVectorD"); 
  TClonesArray* mcStatusTrackFitter3D = new TClonesArray("TVectorD"); 
  inTree->SetBranchAddress("tSTrackFitter3D", &tSTrackFitter3D);
  inTree->SetBranchAddress("fitTrackFitter3D", &fitTrackFitter3D);
  inTree->SetBranchAddress("mcTrackFitter3D", &mcTrackFitter3D);
  inTree->SetBranchAddress("mcStatusTrackFitter3D", &mcStatusTrackFitter3D);

  //Make Histogram
  TH1F* hpT    = new TH1F("histpT","Plot of pT",93,0.9,1.1);
  TH1F* hphi0   = new TH1F("hphi00","",87,0,360);
  TH1F* hz0     = new TH1F("histz0","Plot of z0",98,-25,25);
  TH1F* htheta = new TH1F("htheta","",130,20,150);
  hphi0->SetMinimum(0);
  hpT->SetMinimum(0);
  // MC Histograms
  TH1F* hMCpT    = new TH1F("histMCpT","Plot of pT",93,0.9,1.1);
  TH1F* hMCphi0   = new TH1F("hMCphi00","Plot of phi0",87,0,360);
  TH1F* hMCz0     = new TH1F("histMCz0","Plot of z0",98,-25,25);
  TH1F* hMCtheta = new TH1F("hMCtheta","Plot of theta",130,20,150);
  hMCphi0->SetMinimum(0);
  hMCpT->SetMinimum(0);

  // pt Resolutions
  const float ptResRange = 1;
  TH1F* hpT1    = new TH1F("histpT1","Plot Resolution pT=[0,1.5]GeV",93,-ptResRange,ptResRange);
  TH1F* hpT2    = new TH1F("histpT2","Plot Resolution pT=[1.5,2.5]GeV",93,-ptResRange,ptResRange);
  TH1F* hpT3    = new TH1F("histpT3","Plot Resolution pT=[2.5,3.5]GeV",93,-ptResRange,ptResRange);
  TH1F* hpT4    = new TH1F("histpT4","Plot Resolution pT=[3.5,inf]GeV",93,-ptResRange,ptResRange);

  // Fit Resolution
  TH1F* hRespT    = new TH1F("histRespT","Resolution plot of pT",93,-1,1);
  TH1F* hResphi0   = new TH1F("hResphi00","Resolution plot of phi0",87,-50,50);
  TH1F* hResz0     = new TH1F("histResz0","Resolution plot of z0",98,-30,30);
  TH1F* hRestheta = new TH1F("hRestheta","Resolution plot of theta",130,-50,50);
  hResphi0->SetMinimum(0);
  hRespT->SetMinimum(0);
  
  // For MC-Fit combined graph
  double mcPt[10000];
  double myPt[10000];
  double mcPhi0[10000];
  double myPhi0[10000];
  double mcZ0[10000];
  double myZ0[10000];
  double mcTheta[10000];
  double myTheta[10000];

  // For pdg id plot
  TH1F* hPDG = new TH1F("histPDG","Plot of pdg id",10001,-5000.5,5000.5);

  // For statusbit plot
  TH1F* hStatus = new TH1F("histStatus", "Plot of MCParticle status", 11, -0.5, 10.5);
  

  double Trg_PI = 3.141592653589793;

  //[0]=pt, [1]=phi0, [2]=z0(cm), [3]=cot [4]=charge
  TVectorD tempPar(5);
  TVectorD tempMCPar(5);
  // statusbit, pdg, charge
  TVectorD mcStatus(3);
  // 0: primary, 1: stable in generator, 2: left detector, 3: stopped in detector
  // 4: seen in PXD, 5: seen in SVD, 6: seen in CDC, 7: seen in TOP,
  // 8: seen in ECL, 9: seen in KLM, 10: Virtual and not go to Geant4
  bool mcStatusBit[11];
  int tempStatus;
  int countStrangeZ0=0;
  int countTracks=0;

  Double_t theta;
  Double_t MCtheta;
  cout<<"Number of events: "<<inTree->GetEntriesFast()<<endl;
  for(int event=0; event<inTree->GetEntriesFast();event++){
    //Get event
    inTree->GetEntry(event);
    //Number of tracks
    //cout<<"Number of tracks: "<<fitTrackFitter3D->GetEntriesFast()<<endl;
    countTracks += fitTrackFitter3D->GetEntriesFast();
    for(int track=0; track<tSTrackFitter3D->GetEntriesFast(); track++){
      tempPar = *(TVectorD*)fitTrackFitter3D->At(track);
      tempMCPar = *(TVectorD*)mcTrackFitter3D->At(track);
      mcStatus = *(TVectorD*)mcStatusTrackFitter3D->At(track);

      // Transform parameters
      if(tempPar[1]<0) tempPar[1] += 2*Trg_PI;
      tempPar[1] = tempPar[1]*180/Trg_PI;
      if(tempMCPar[1]<0) tempMCPar[1] += 2*Trg_PI;
      tempMCPar[1] = tempMCPar[1]*180/Trg_PI;

      theta = Trg_PI/2.-atan(tempPar[3]);
      theta*=180./Trg_PI;
      MCtheta=Trg_PI/2.-atan(tempMCPar[3]);
      MCtheta*=180./Trg_PI;

      // Pick condition
      //if((tempMCPar[2]*100>1 || tempMCPar[2]*100<-1) && conditionFlag == 1) continue;
      //if(!(tempMCPar[1]>100 && tempMCPar[1]<250) && conditionFlag == 1) continue;
      if(!(tempPar[0]>1.004) && conditionFlag == 1) continue;

      hpT->Fill(tempPar[0]);
      //myPt[event] = (tempPar[0]-tempMCPar[0])/tempMCPar[0];
      myPt[event] = tempPar[0];
      hMCpT->Fill(tempMCPar[0]);
      mcPt[event] = tempMCPar[0];
      hRespT->Fill(tempPar[0]-tempMCPar[0]);

      // Divide by MC pT
      if(tempMCPar[0]<1.5) {
        hpT1->Fill((tempPar[0]-tempMCPar[0])/tempMCPar[0]);
      }
      if(tempMCPar[0]>1.5 && tempMCPar[0]<2.5) {
        hpT2->Fill((tempPar[0]-tempMCPar[0])/tempMCPar[0]);
      }
      if(tempMCPar[0]>2.5 && tempMCPar[0]<3.5) {
        hpT3->Fill((tempPar[0]-tempMCPar[0])/tempMCPar[0]);
      }
      if(tempMCPar[0]>3.5) {
        hpT4->Fill((tempPar[0]-tempMCPar[0])/tempMCPar[0]);
      }


      hphi0->Fill(tempPar[1]);
      myPhi0[event] = tempPar[1];
      hMCphi0->Fill(tempMCPar[1]);
      mcPhi0[event] = tempMCPar[1];
      hResphi0->Fill(tempPar[1]-tempMCPar[1]);

      hz0->Fill(tempPar[2]*100);
      myZ0[event] = tempPar[2]*100;
      hMCz0->Fill(tempMCPar[2]*100);
      mcZ0[event] = tempMCPar[2]*100;
      hResz0->Fill(tempPar[2]*100-tempMCPar[2]);

      htheta->Fill(theta);
      myTheta[event]=theta;
      hMCtheta->Fill(MCtheta);
      mcTheta[event]=MCtheta;
      hRestheta->Fill(theta-MCtheta);


      // Calculate the status bit.
      tempStatus = mcStatus[0];
      for(int n=10; n>=0; n--) mcStatusBit[n]=0;
      for(int n=10; n>=0; n--){
        if(tempStatus >= pow(2,n)){
          tempStatus -= pow(2,n);
          mcStatusBit[n] = 1;
        }
      }
      // print status bit
      //for(int n=10; n>=0; n--) cout<<mcStatusBit[n];
      //cout<<endl;

      // statusbit, pdg, charge
      hPDG->Fill(mcStatus[1]);
      for(int n=0; n<10; n++){
        if(mcStatusBit[n] == 1){
          hStatus->Fill(n);
        }
      }

      float range = 1;
      if(tempMCPar[2]*100>range || tempMCPar[2]<-range) countStrangeZ0 +=1;

    } // track loop
  } // event loop

  cout<<"Strange Z0: "<<countStrangeZ0<<" ratio: "<<(double) countStrangeZ0/countTracks*100<<endl;
  cout<<"Tracks: "<<countTracks<<endl;

  if(graphFlag==0 || graphFlag==1){
    TCanvas *c1 = new TCanvas("c1", "", 1000, 500);
    c1->Divide(2,2);
    c1->cd(1);
    hpT->Draw();
    hMCpT->SetLineColor(2);
    hMCpT->Draw("same");
    c1->cd(2);
    hphi0->Draw();
    hMCphi0->SetLineColor(2);
    hMCphi0->Draw("same");
    c1->cd(3);
    hz0->SetMaximum(max(hz0->GetMaximum(),hMCz0->GetMaximum())*1.1);
    hz0->Draw();
    hMCz0->SetLineColor(2);
    hMCz0->Draw("same");
    c1->cd(4);
    htheta->Draw();
    hMCtheta->SetLineColor(2);
    hMCtheta->Draw("same");

    //c1->SaveAs("histFitter3D.pdf");
    TCanvas *c2 = new TCanvas("c2", "", 600, 600);

    gPtMCFit = new TGraph(10000,mcPt,myPt);
    gPhi0MCFit = new TGraph(10000,mcPhi0,myPhi0);
    gZ0MCFit = new TGraph(10000,mcZ0,myZ0);
    gThetaMCFit = new TGraph(10000,mcTheta,myTheta);

    c2->Divide(2,2);
    c2->cd(1);
    gPtMCFit->Draw("AP");
    c2->cd(2);
    gPhi0MCFit->Draw("AP");
    c2->cd(3);
    gZ0MCFit->SetMaximum(20);
    gZ0MCFit->SetMinimum(-20);
    gZ0MCFit->GetXaxis()->SetLimits(-20,20);
    gZ0MCFit->Draw("AP");
    c2->cd(4);
    gThetaMCFit->Draw("AP");

    TCanvas* c3 = new TCanvas("c3","",1000,500);
    c3->Divide(2,2);
    c3->cd(1);
    hpT1->Draw();
    c3->cd(2);
    hpT2->Draw();
    c3->cd(3);
    hpT3->Draw();
    c3->cd(4);
    hpT4->Draw();

    TCanvas *c5 = new TCanvas("c5", "", 1000, 500);
    c5->Divide(2,2);
    c5->cd(1);
    hRespT->Draw();
    c5->cd(2);
    hResphi0->Draw();
    c5->cd(3);
    hResz0->Draw();
    c5->cd(4);
    hRestheta->Draw();
  }

  if(graphFlag==0 || graphFlag==2){
    TCanvas* c4 = new TCanvas("c4","",500,500);
    c4->Divide(1,2);
    c4->cd(1);
    hPDG->Draw();
    c4->cd(2);
    hStatus->Draw();
  }

}
